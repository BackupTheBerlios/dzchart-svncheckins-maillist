<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dzchart-svncheckins] r152 - in utilities/dzLib/trunk: src	tests/dzfileutils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dzchart-svncheckins/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:dzchart-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BDzchart-svncheckins%5D%20r152%20-%20in%20utilities/dzLib/trunk%3A%20src%0A%09tests/dzfileutils&In-Reply-To=%3C200705281442.l4SEg3RQ022437%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000026.html">
   <LINK REL="Next"  HREF="000028.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dzchart-svncheckins] r152 - in utilities/dzLib/trunk: src	tests/dzfileutils</H1>
    <B>twm at mail.berlios.de</B> 
    <A HREF="mailto:dzchart-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BDzchart-svncheckins%5D%20r152%20-%20in%20utilities/dzLib/trunk%3A%20src%0A%09tests/dzfileutils&In-Reply-To=%3C200705281442.l4SEg3RQ022437%40sheep.berlios.de%3E"
       TITLE="[Dzchart-svncheckins] r152 - in utilities/dzLib/trunk: src	tests/dzfileutils">twm at mail.berlios.de
       </A><BR>
    <I>Mon May 28 16:42:03 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000026.html">[Dzchart-svncheckins] r151 - utilities/dzLib/trunk/src
</A></li>
        <LI>Next message: <A HREF="000028.html">[Dzchart-svncheckins] r153 - utilities/dzLib/trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27">[ date ]</a>
              <a href="thread.html#27">[ thread ]</a>
              <a href="subject.html#27">[ subject ]</a>
              <a href="author.html#27">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: twm
Date: 2007-05-28 16:41:55 +0200 (Mon, 28 May 2007)
New Revision: 152

Modified:
   utilities/dzLib/trunk/src/u_dzFileUtils.pas
   utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr
   utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj
   utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas
Log:
* added an Execute class method to TSimpleDirEnumerator to simplify usage
* New TDirectorySync class for synchronizing directories
* new class methods BackupFile and GetFileInfo in TFileSystem
* New TFileGenerationHandler class for automatically handling multiple generations of a file
* Bugfix: TFileSystem.CopyFileWithProgress no longer raises an exception if the user aborts
* Unit tests

Modified: utilities/dzLib/trunk/src/u_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-05-28 14:38:31 UTC (rev 151)
+++ utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-05-28 14:41:55 UTC (rev 152)
@@ -17,6 +17,8 @@
   {: raised by DelTree if the DirName parameter is not a valid directory name }
   EDirNotFound = class(EFileUtils);
   EPathTooLong = class(EFileUtils);
+  EInvalidPropertyCombination = class(EFileUtils);
+  EFileNotFound = class(EFileUtils);
 
 type
   TFileAttributes = (
@@ -30,6 +32,13 @@
 
   TFileAttributeSet = set of TFileAttributes;
 
+  TFileInfoRec = record
+  public
+    Filename: string;
+    Size: Int64;
+    Timestamp: TDateTime;
+  end;
+
 type
   {: a simple wrapper around FindFirst/FindNext which allows to search for
      specified attributes only (e.g. only directories), it automatically
@@ -58,6 +67,8 @@
     constructor Create(const _Mask: string);
     {: Destructor, will call FindClose if necessary }
     destructor Destroy; override;
+    {: creates a TSimpleDirEnumerator, calls its FindAll method and frees it }
+    class function Execute(const _Mask: string; _List: TStrings): integer;
     {: Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
        calls.
        @param Filename is the name of the file found, if result is true, if you need
@@ -140,6 +151,51 @@
   TCopyFileProgressEvt = procedure(_Status: TCopyProgressStatus;
     var _Continue: TCopyProgressStatus.TProgressResult) of object;
 
+  {: defines the action to take if a file already exists but has a different content }
+  TFileExistsAction = (feaIgnore, feaOverwrite);
+  TOnSyncing = procedure(_Sender: TObject; const _SrcDir, _DstDir: string) of object;
+  {: called if a destination file already exists
+     @param Action is the action to take, default is feaIgnore }
+  TOnFileExists = procedure(_Sender: TObject; const _SrcFile, _DstFile: TFileInfoRec; var _Action: TFileExistsAction) of object;
+  {: Synchronizes two directories }
+  TDirectorySync = class
+  private
+    FOnSyncingDir: TOnSyncing;
+    FOnSyncingFile: TOnSyncing;
+    FOnFileExists: TOnFileExists;
+//    FOnDifferentFileExists: TOnDifferentFileExists;
+//    FCheckContent: boolean;
+//    procedure doOnDifferentFileExists(const _Filename: string; var _Action: TFileExistsAction);
+    procedure doOnSyncingDir(const _SrcDir, _DstDir: string);
+    procedure doOnSyncingFile(const _SrcFile, _DstFile: string);
+    function doOnFileExists(const _SrcDir, _DstDir, _Filename: string): TFileExistsAction;
+  public
+    {: Checks if there are files in the source directory that are already in
+       the destination directory, for each file that exists, the OnFileExists
+       event is called. }
+    procedure CheckOneWay(const _SrcDir, _DstDir: string);
+    {: copies all files from DirA to DirB if they don't already exists
+       (not implemented: if CheckContent=true, the content existing files will be checked and if
+                         it doesn't match, OnDifferentFileExists is called ) }
+    procedure SyncOneWay(const _SrcDir, _DstDir: string);
+    {: calls SyncOneWay(DirA, DirB) and SyncOneWay(DirB, DirA)
+       (not implemented: if CheckContent=true, the content existing files will be checked and if
+                         it doesn't match, OnDifferentFileExists is called ) }
+    procedure SyncBothWays(const _DirA, _DirB: string);
+//    {: Not implemented: Called, if the content of an existing file is different }
+//    property OnDifferentFileExists: TOnDifferentFileExists read FOnDifferentFileExists write FOnDifferentFileExists;
+//    {: Not implemented: if true, OnDifferentFileExists will be called }
+//    property CheckContent: boolean read FCheckContent write FCheckContent default false;
+    {: called when a new directory is entered, to abort synchronization,
+       raise an exception (e.g. SysUtils.Abort), and catch it in the calling method }
+    property OnSyncingDir: TOnSyncing read FOnSyncingDir write FOnSyncingDir;
+    {: called when a file is being copied, to abort synchronization,
+      raise an exception (e.g. SysUtils.Abort), and catch it in the calling method }
+    property OnSyncingFile: TOnSyncing read FOnSyncingFile write FOnSyncingFile;
+    {: called from CheckOneWay if a destination file already exists }
+    property OnFileExists: TOnFileExists read FOnFileExists write FOnFileExists;
+  end;
+
   {: This class owns all utility functions as class methods so they don't pollute the name space }
   TFileSystem = class
   public
@@ -336,8 +392,51 @@
        @param ErrPos is the first error position, only valid it result = false
        @returns true, if the string is a valid filename, false otherwise }
     class function IsValidFilename(const _s: string; out _ErrPos: integer): boolean; overload;
+    {: creates a backup of the file appending the current date and time to the base
+       file name.
+       @param Filename is the name of the file to back up
+       @param BackupDir is a directory in which to create the backup file, if empty
+                        the same directory as the original file is used }
+    class procedure BackupFile(const _Filename: string; _BackupDir: string = '');
+    class function GetFileInfo(const _Filename: string): TFileInfoRec;
   end;
 
+type
+  {: callback event for generating a filename for the given generation }
+  TOnGenerateFilename = procedure(_Sender: TObject; _Generation: integer; var _Filename: string) of object;
+type
+  TFileGenerationHandler = class
+  private
+    FBaseName: string;
+    FSuffix: string;
+    FOnGenerateFilename: TOnGenerateFilename;
+    FMaxGenerations: integer;
+    FResultContainsNumber: boolean;
+    FOldestIsHighest: boolean;
+    FPrependZeros: integer;
+    function GenerateFilename(_Generation: integer): string;
+  public
+    {: @param BaseName is the base filename to which by default _&lt;n&gt; followed by
+                       the Suffix will be appended
+       @param Suffix is the suffix for the filename, usually an extension which
+                     must include the dot (.) }
+    constructor Create(const _BaseName, _Suffix: string);
+    {: generates the filename and returns it }
+    function Execute(_KeepOriginal: boolean): string;
+    {: the maximum of file generations that should be kept }
+    property MaxGenerations: integer read FMaxGenerations write FMaxGenerations default 5;
+    {: should the resulting filename contain a number? }
+    property ResultContainsNumber: boolean read FResultContainsNumber write FResultContainsNumber default false;
+    {: does the oldest file have the highest number? }
+    property OldestIsHighest: boolean read FOldestIsHighest write FOldestIsHighest default true;
+    property PrependZeros: integer read FPrependZeros write FPrependZeros default 0;
+    {: allows read access to the file's base name as passed to the constructor }
+    property BaseName: string read FBaseName;
+    property Suffix: string read FSuffix;
+    {: callback event for generating a filename for the given generation }
+    property OnGenerateFilename: TOnGenerateFilename read FOnGenerateFilename write FOnGenerateFilename;
+  end;
+
 {: This is an abbreviation for IncludeTrailingPathDelimiter }
 function itpd(const _Dirname: string): string; inline;
 
@@ -345,7 +444,9 @@
 
 uses
   FileCtrl,
-  u_dzMiscUtils;
+  u_dzMiscUtils,
+  u_dzStringUtils,
+  u_dzDateUtils;
 
 resourcestring
   STR_GETTEMPPATH_ERROR_DS = 'u_dzFileUtils.GetTempPath: %1:s (code: %0:d) calling Windows.GetTempPath';
@@ -388,6 +489,18 @@
   inherited;
 end;
 
+class function TSimpleDirEnumerator.Execute(const _Mask: string; _List: TStrings): integer;
+var
+  enum: TSimpleDirEnumerator;
+begin
+  enum := TSimpleDirEnumerator.Create(_Mask);
+  try
+    Result := enum.FindAll(_List);
+  finally
+    enum.Free;
+  end;
+end;
+
 function TSimpleDirEnumerator.FindAll(_List: TStrings): integer;
 var
   s: string;
@@ -525,7 +638,7 @@
   if _BaseDir = '' then
     _BaseDir := GetTempPath;
   Pid := GetCurrentProcessId;
-  s := IncludeTrailingPathDelimiter(_BaseDir) + _Prefix + '_' + IntToStr(Pid) + '_';
+  s := itpd(_BaseDir) + _Prefix + '_' + IntToStr(Pid) + '_';
   Counter := 0;
   Ok := false;
   while not OK do begin
@@ -556,6 +669,23 @@
   Result := PChar(Result); // remove trailing characters
 end;
 
+class function TFileSystem.GetFileInfo(const _Filename: string): TFileInfoRec;
+var
+  sr: TSearchRec;
+  Res: integer;
+begin
+  Res := FindFirst(_Filename, faAnyFile, sr);
+  if Res &lt;&gt; 0 then
+    raise EFileNotFound.CreateFmt('File not found: &quot;%s&quot;', [_Filename]);
+  try
+    Result.Filename := _Filename;
+    Result.Size := sr.Size;
+    Result.Timestamp := FileDateToDateTime(sr.Time);
+  finally
+    FindClose(sr);
+  end;
+end;
+
 class function TFileSystem.GetShortPathname(const _LongName: string): string;
 var
   Res: integer;
@@ -618,6 +748,21 @@
   end;
 end;
 
+class procedure TFileSystem.BackupFile(const _Filename: string; _BackupDir: string = '');
+var
+  Ext: string;
+  FilenameOnly: string;
+  Base: string;
+begin
+  if _BackupDir = '' then
+    _BackupDir := ExtractFilePath(_Filename);
+  _BackupDir := itpd(_BackupDir);
+  FilenameOnly := ExtractFileName(_Filename);
+  Ext := ExtractFileExt(FilenameOnly);
+  Base := ChangeFileExt(FilenameOnly, '');
+  CopyFile(_Filename, _BackupDir + Base + '_' + ReplaceChars(DateTime2Iso(now, true), ': ', '-_') + Ext, true);
+end;
+
 class function TFileSystem.CopyFile(const _Source, _Dest: string; _Flags: TCopyFileFlagSet): boolean;
 begin
   Result := CopyFile(_Source, _Dest,
@@ -659,8 +804,8 @@
   Status.FStreamBytesTransferred := _StreamBytesTransferred;
   Status.FStreamNumber := _StreamNumber;
   case _CallbackReason of
-  CALLBACK_CHUNK_FINISHED: Status.FCallbackReason := prChunkFinished;
-  CALLBACK_STREAM_SWITCH: Status.FCallbackReason := prStreamSwitch;
+    CALLBACK_CHUNK_FINISHED: Status.FCallbackReason := prChunkFinished;
+    CALLBACK_STREAM_SWITCH: Status.FCallbackReason := prStreamSwitch;
   else
     // Shouldn't happen, assume CALLBACK_CHUNK_FINISHED for now
     Status.FCallbackReason := prChunkFinished;
@@ -694,19 +839,19 @@
     Flags := 0;
     if cfwFailIfExists in _Flags then
       Flags := Flags or COPY_FILE_FAIL_IF_EXISTS;
-     if cfwRestartable in _Flags then
-       Flags := Flags or COPY_FILE_RESTARTABLE;
+    if cfwRestartable in _Flags then
+      Flags := Flags or COPY_FILE_RESTARTABLE;
     Res := Windows.CopyFileEx(PChar(_Source), PChar(_Dest), @ProgressCallback, Redir,
       @Redir.CancelFlag, Flags);
     if not Res then begin
       LastError := GetLastError;
-      if cfwRaiseException in _Flags then
-        RaiseLastOsErrorEx(LastError, Format(STR_COPYFILE_ERROR_SS, [_Source, _Dest]));
-
       if LastError = ERROR_REQUEST_ABORTED then
         Result := cfwAborted
-      else
+      else begin
+        if cfwRaiseException in _Flags then
+          RaiseLastOsErrorEx(LastError, Format(STR_COPYFILE_ERROR_SS, [_Source, _Dest]));
         Result := cfwError;
+      end;
     end else
       Result := cfwOK;
   finally
@@ -827,7 +972,7 @@
     end;
 end;
 
-class function TFileSystem.ForceDir(const _DirectoryPath: string; _RaiseException: boolean): boolean;
+class function TFileSystem.ForceDir(const _DirectoryPath: string; _RaiseException: boolean = true): boolean;
 var
   LastError: Cardinal;
 begin
@@ -951,5 +1096,260 @@
     FOnProgress(Self, Result);
 end;
 
+{ TFileGenerationHandler }
+
+constructor TFileGenerationHandler.Create(const _BaseName, _Suffix: string);
+begin
+  inherited Create;
+  FMaxGenerations := 5;
+  FOldestIsHighest := true;
+  FResultContainsNumber := false;
+  FPrependZeros := 0;
+  FBaseName := _BaseName;
+  FSuffix := _Suffix;
+end;
+
+function TFileGenerationHandler.Execute(_KeepOriginal: boolean): string;
+
+  function doNoNumberOldIsHighest(): string;
+  var
+    i: Integer;
+    dst: string;
+    src: string;
+    MaxGen: integer;
+  begin
+    MaxGen := FMaxGenerations - 1;
+    for i := MaxGen - 1 downto 1 do begin
+      dst := GenerateFilename(i + 1);
+      if FileExists(dst) then
+        TFileSystem.DeleteFile(dst);
+      src := GenerateFilename(i);
+      if FileExists(src) then
+        TFileSystem.MoveFile(src, dst);
+    end;
+    dst := GenerateFilename(1);
+    Result := GenerateFilename(0);
+    if FileExists(dst) then
+      TFileSystem.DeleteFile(dst);
+    if FileExists(Result) then begin
+      if _KeepOriginal then
+        TFileSystem.CopyFile(Result, dst, true)
+      else
+        TFileSystem.MoveFile(Result, dst);
+    end;
+  end;
+
+  function doNumberOldIsHighest(): string;
+  var
+    i: Integer;
+    dst: string;
+    src: string;
+    MaxGen: integer;
+  begin
+    MaxGen := FMaxGenerations;
+    for i := MaxGen - 1 downto 1 do begin
+      dst := GenerateFilename(i + 1);
+      if FileExists(dst) then
+        TFileSystem.DeleteFile(dst);
+      src := GenerateFilename(i);
+      if FileExists(src) then
+        TFileSystem.MoveFile(src, dst);
+    end;
+    Result := GenerateFilename(1);
+  end;
+
+  function doNoNumberOldIsLowest(): string;
+  var
+    i: Integer;
+    MaxGen: integer;
+    src: string;
+    dst: string;
+    SlotFound: Boolean;
+  begin
+    Result := GenerateFilename(0);
+    if not FileExists(Result) then
+      exit;
+
+    SlotFound := false;
+    MaxGen := FMaxGenerations - 1;
+    for i := 1 to MaxGen do begin
+      dst := GenerateFilename(i);
+      if not FileExists(dst) then begin
+        SlotFound := true;
+        break;
+      end;
+    end;
+
+    if not SlotFound then begin
+      dst := GenerateFilename(1);
+      if FileExists(dst) then
+        TFileSystem.DeleteFile(dst);
+      for i := 2 to MaxGen do begin
+        src := GenerateFilename(i);
+        if FileExists(src) then
+          TFileSystem.MoveFile(src, dst);
+        dst := src;
+      end;
+    end;
+
+    if _KeepOriginal then
+      TFileSystem.CopyFile(Result, dst, true)
+    else
+      TFileSystem.MoveFile(Result, dst);
+  end;
+
+  function doNumberOldIsLowest(): string;
+  var
+    i: Integer;
+    MaxGen: integer;
+  begin
+    MaxGen := FMaxGenerations;
+    for i := 1 to MaxGen do begin
+      Result := GenerateFilename(i);
+      if not FileExists(Result) then
+        exit;
+    end;
+
+    TFileSystem.DeleteFile(GenerateFilename(1));
+    for i := 2 to MaxGen do begin
+      TFileSystem.MoveFile(GenerateFilename(i), GenerateFilename(i - 1));
+    end;
+    Result := GenerateFilename(MaxGen);
+    if _KeepOriginal then
+      TFileSystem.CopyFile(GenerateFilename(MaxGen - 1), Result, true);
+  end;
+
+begin
+  if FResultContainsNumber then begin
+    if _KeepOriginal then
+      raise EInvalidPropertyCombination.Create('Combination of ResultContainsNumber and KeepOriginal is not allowed');
+    if FOldestIsHighest then begin
+      Result := doNumberOldIsHighest();
+    end else begin
+      Result := doNumberOldIsLowest();
+    end;
+  end else begin
+    if FOldestIsHighest then begin
+      Result := doNoNumberOldIsHighest();
+    end else begin
+      Result := doNoNumberOldIsLowest();
+    end;
+  end;
+end;
+
+function TFileGenerationHandler.GenerateFilename(_Generation: integer): string;
+begin
+  if _Generation = 0 then
+    Result := FBaseName + FSuffix
+  else begin
+    if FPrependZeros = 0 then
+      Result := FBaseName + '_' + IntToStr(_Generation) + FSuffix
+    else
+      Result := Format('%s_%.*u%s', [FBaseName, FPrependZeros, _Generation, FSuffix]);
+  end;
+  if Assigned(FOnGenerateFilename) then
+    FOnGenerateFilename(Self, _Generation, Result);
+end;
+
+{ TDirectorySync }
+
+//procedure TDirectorySync.doOnDifferentFileExists(const _Filename: string; var _Action: TFileExistsAction);
+//begin
+//  _Action := feaIgnore;
+//  if Assigned(FOnDifferentFileExists) then
+//    FOnDifferentFileExists(_Filename, _Action);
+//end;
+
+function TDirectorySync.doOnFileExists(const _SrcDir, _DstDir, _Filename: string): TFileExistsAction;
+var
+  Src: TFileInfoRec;
+  Dst: TFileInfoRec;
+begin
+  Result := feaIgnore;
+  if not Assigned(FOnFileExists) then
+    exit;
+
+  Src := TFileSystem.GetFileInfo(_SrcDir + _Filename);
+  Dst := TFileSystem.GetFileInfo(_DstDir + _Filename);
+  FOnFileExists(self, Src, Dst, Result);
+end;
+
+procedure TDirectorySync.doOnSyncingDir(const _SrcDir, _DstDir: string);
+begin
+  if Assigned(FOnSyncingDir) then
+    FOnSyncingDir(Self, _SrcDir, _DstDir);
+end;
+
+procedure TDirectorySync.doOnSyncingFile(const _SrcFile, _DstFile: string);
+begin
+  if Assigned(FOnSyncingFile) then
+    FOnSyncingFile(self, _SrcFile, _DstFile);
+end;
+
+procedure TDirectorySync.CheckOneWay(const _SrcDir, _DstDir: string);
+var
+  Filename: string;
+  EnumA: TSimpleDirEnumerator;
+  DstDirBS: string;
+  SrcDirBS: string;
+begin
+  doOnSyncingDir(_SrcDir, _DstDir);
+  SrcDirBS := itpd(_SrcDir);
+  DstDirBS := itpd(_DstDir);
+  EnumA := TSimpleDirEnumerator.Create(SrcDirBS + '*.*');
+  try
+    while EnumA.FindNext(Filename) do begin
+      if (EnumA.Sr.Attr and SysUtils.faDirectory) &lt;&gt; 0 then begin
+        if DirectoryExists(DstDirBS + Filename) then
+          CheckOneWay(SrcDirBS + Filename, DstDirBS + Filename);
+      end else if FileExists(DstDirBS + Filename) then begin
+        doOnFileExists(SrcDirBS, DstDirBS, Filename);
+      end else begin
+        doOnSyncingFile(SrcDirBS + Filename, DstDirBS + Filename);
+      end;
+    end;
+  finally
+    EnumA.Free;
+  end;
+end;
+
+procedure TDirectorySync.SyncOneWay(const _SrcDir, _DstDir: string);
+var
+  Filename: string;
+  EnumA: TSimpleDirEnumerator;
+  DstDirBS: string;
+  SrcDirBS: string;
+begin
+  doOnSyncingDir(_SrcDir, _DstDir);
+  SrcDirBS := itpd(_SrcDir);
+  DstDirBS := itpd(_DstDir);
+  EnumA := TSimpleDirEnumerator.Create(SrcDirBS + '*.*');
+  try
+    while EnumA.FindNext(Filename) do begin
+      if (EnumA.Sr.Attr and SysUtils.faDirectory) &lt;&gt; 0 then begin
+        if not DirectoryExists(DstDirBS + Filename) then
+          TFileSystem.CreateDir(DstDirBS + Filename);
+        SyncOneWay(SrcDirBS + Filename, DstDirBS + Filename);
+      end else if FileExists(DstDirBS + Filename) then begin
+        if doOnFileExists(SrcDirBS, DstDirBS, Filename) = feaOverwrite then begin
+          doOnSyncingFile(SrcDirBS + Filename, DstDirBS + Filename);
+          TFileSystem.CopyFile(SrcDirBS + Filename, DstDirBS + Filename, false, true);
+        end;
+      end else begin
+        doOnSyncingFile(SrcDirBS + Filename, DstDirBS + Filename);
+        TFileSystem.CopyFile(SrcDirBS + Filename, DstDirBS + Filename, true, true);
+      end;
+    end;
+  finally
+    EnumA.Free;
+  end;
+end;
+
+procedure TDirectorySync.SyncBothWays(const _DirA, _DirB: string);
+begin
+  SyncOneWay(_DirA, _DirB);
+  SyncOneWay(_DirB, _DirA);
+end;
+
 end.
 

Modified: utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr
===================================================================
--- utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr	2007-05-28 14:38:31 UTC (rev 151)
+++ utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr	2007-05-28 14:41:55 UTC (rev 152)
@@ -24,7 +24,8 @@
   u_dzMiscUtils in '..\..\src\u_dzMiscUtils.pas',
   u_dzStringUtils in '..\..\src\u_dzStringUtils.pas',
   u_dzConvertUtils in '..\..\src\u_dzConvertUtils.pas',
-  u_dzTranslator in '..\..\src\u_dzTranslator.pas';
+  u_dzTranslator in '..\..\src\u_dzTranslator.pas',
+  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas';
 
 {$R *.RES}
 

Modified: utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj
===================================================================
--- utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj	2007-05-28 14:38:31 UTC (rev 151)
+++ utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj	2007-05-28 14:41:55 UTC (rev 152)
@@ -1,5 +1,4 @@
-&#65279;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
-&lt;Project xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
+&#65279;&lt;Project xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
   &lt;PropertyGroup&gt;
     &lt;ProjectGuid&gt;{9732bdc0-39a6-4dbb-817c-3fb77772e288}&lt;/ProjectGuid&gt;
     &lt;MainSource&gt;DUnitTest_dzFileUtils.dpr&lt;/MainSource&gt;
@@ -18,10 +17,10 @@
   &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' &quot;&gt;
     &lt;Version&gt;7.0&lt;/Version&gt;
     &lt;DCC_Define&gt;DEBUG;_CONSOLE_TESTRUNNER;no_translation&lt;/DCC_Define&gt;
-    &lt;DCC_UnitSearchPath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;..\..\inc&lt;/DCC_UnitSearchPath&gt;
-    &lt;DCC_ResourcePath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;..\..\inc&lt;/DCC_ResourcePath&gt;
-    &lt;DCC_ObjPath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;..\..\inc&lt;/DCC_ObjPath&gt;
-    &lt;DCC_IncludePath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;..\..\inc&lt;/DCC_IncludePath&gt;
+    &lt;DCC_UnitSearchPath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;;$(BDS)\Source\DUnit\src;..\..\inc&lt;/DCC_UnitSearchPath&gt;
+    &lt;DCC_ResourcePath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;;$(BDS)\Source\DUnit\src;..\..\inc&lt;/DCC_ResourcePath&gt;
+    &lt;DCC_ObjPath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;;$(BDS)\Source\DUnit\src;..\..\inc&lt;/DCC_ObjPath&gt;
+    &lt;DCC_IncludePath&gt;$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;;$(BDS)\Source\DUnit\src;..\..\inc&lt;/DCC_IncludePath&gt;
     &lt;DCC_DcuOutput&gt;dcu&lt;/DCC_DcuOutput&gt;
     &lt;DCC_ObjOutput&gt;dcu&lt;/DCC_ObjOutput&gt;
     &lt;DCC_HppOutput&gt;dcu&lt;/DCC_HppOutput&gt;
@@ -35,7 +34,45 @@
     &lt;Borland.Personality&gt;Delphi.Personality&lt;/Borland.Personality&gt;
     &lt;Borland.ProjectType /&gt;
     &lt;BorlandProject&gt;
-&lt;BorlandProject&gt;&lt;Delphi.Personality&gt;&lt;Parameters&gt;&lt;Parameters Name=&quot;UseLauncher&quot;&gt;False&lt;/Parameters&gt;&lt;Parameters Name=&quot;LoadAllSymbols&quot;&gt;True&lt;/Parameters&gt;&lt;Parameters Name=&quot;LoadUnspecifiedSymbols&quot;&gt;False&lt;/Parameters&gt;&lt;/Parameters&gt;&lt;VersionInfo&gt;&lt;VersionInfo Name=&quot;IncludeVerInfo&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;AutoIncBuild&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;MajorVer&quot;&gt;1&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;MinorVer&quot;&gt;0&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Release&quot;&gt;0&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Build&quot;&gt;0&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Debug&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;PreRelease&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Special&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Private&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;DLL&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Locale&quot;&gt;1033&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;CodePage&quot;&gt;1252&lt;/VersionInfo&gt;&lt;/VersionInfo&gt;&lt;VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;CompanyName&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;FileDescription&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionI!
 nfoKeys Name=&quot;FileVersion&quot;&gt;1.0.0.0&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;InternalName&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;LegalCopyright&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;LegalTrademarks&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;OriginalFilename&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;ProductName&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;ProductVersion&quot;&gt;1.0.0.0&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;Comments&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;/VersionInfoKeys&gt;&lt;Source&gt;&lt;Source Name=&quot;MainSource&quot;&gt;DUnitTest_dzFileUtils.dpr&lt;/Source&gt;&lt;/Source&gt;&lt;/Delphi.Personality&gt;&lt;UnitTesting&gt;&lt;TestFramework&gt;DUnit / Delphi Win32&lt;/TestFramework&gt;&lt;TestRunner&gt;GUI&lt;/TestRunner&gt;&lt;/UnitTesting&gt;&lt;/BorlandProject&gt;&lt;/BorlandProject&gt;
+&lt;BorlandProject xmlns=&quot;&quot;&gt; &lt;Delphi.Personality&gt;   &lt;Parameters&gt;
+      &lt;Parameters Name=&quot;UseLauncher&quot;&gt;False&lt;/Parameters&gt;
+      &lt;Parameters Name=&quot;LoadAllSymbols&quot;&gt;True&lt;/Parameters&gt;
+      &lt;Parameters Name=&quot;LoadUnspecifiedSymbols&quot;&gt;False&lt;/Parameters&gt;
+    &lt;/Parameters&gt;
+    &lt;VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;IncludeVerInfo&quot;&gt;False&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;AutoIncBuild&quot;&gt;False&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;MajorVer&quot;&gt;1&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;MinorVer&quot;&gt;0&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;Release&quot;&gt;0&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;Build&quot;&gt;0&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;Debug&quot;&gt;False&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;PreRelease&quot;&gt;False&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;Special&quot;&gt;False&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;Private&quot;&gt;False&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;DLL&quot;&gt;False&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;Locale&quot;&gt;1033&lt;/VersionInfo&gt;
+      &lt;VersionInfo Name=&quot;CodePage&quot;&gt;1252&lt;/VersionInfo&gt;
+    &lt;/VersionInfo&gt;
+    &lt;VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;CompanyName&quot;&gt;&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;FileDescription&quot;&gt;&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;FileVersion&quot;&gt;1.0.0.0&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;InternalName&quot;&gt;&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;LegalCopyright&quot;&gt;&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;LegalTrademarks&quot;&gt;&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;OriginalFilename&quot;&gt;&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;ProductName&quot;&gt;&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;ProductVersion&quot;&gt;1.0.0.0&lt;/VersionInfoKeys&gt;
+      &lt;VersionInfoKeys Name=&quot;Comments&quot;&gt;&lt;/VersionInfoKeys&gt;
+    &lt;/VersionInfoKeys&gt;
+    &lt;Source&gt;
+      &lt;Source Name=&quot;MainSource&quot;&gt;DUnitTest_dzFileUtils.dpr&lt;/Source&gt;
+    &lt;/Source&gt;
+  &lt;/Delphi.Personality&gt;   &lt;UnitTesting&gt;   &lt;TestFramework&gt;DUnit / Delphi Win32&lt;/TestFramework&gt;
+    &lt;TestRunner&gt;GUI&lt;/TestRunner&gt;
+  &lt;/UnitTesting&gt;
+&lt;/BorlandProject&gt;&lt;/BorlandProject&gt;
   &lt;/ProjectExtensions&gt;
   &lt;Import Project=&quot;$(MSBuildBinPath)\Borland.Delphi.Targets&quot; /&gt;
   &lt;ItemGroup&gt;

Modified: utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas	2007-05-28 14:38:31 UTC (rev 151)
+++ utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas	2007-05-28 14:41:55 UTC (rev 152)
@@ -10,24 +10,174 @@
   u_dzFileUtils;
 
 type
-  TestTFileSystem = class(TTestCase)
+  TFileSystemTestCase = class(TTestCase)
+  protected
+    FTestDir: string;
+    procedure SetUp; override;
+    procedure TearDown; override;
+    function CreateTestFile(const _Filename, _Content: string): string;
+    procedure CheckTestfile(const _Filename, _Content: string);
+    procedure CheckSubdirExists(const _Dirname: string);
+  end;
+
+type
+  TestTFileSystem = class(TFileSystemTestCase)
   private
     FCallbackCount: integer;
+    FSourceFile: string;
+    FDestFile: string;
     procedure ProgressContinue(_Status: TCopyProgressStatus;
       var _Continue: TCopyProgressStatus.TProgressResult);
     procedure ProgressCancel(_Status: TCopyProgressStatus;
       var _Continue: TCopyProgressStatus.TProgressResult);
   protected
     procedure SetUp; override;
+    procedure TearDown; override;
   published
     procedure TestCopyFileWithProgressContinue;
     procedure TestCopyFileWithProgressCancel;
     procedure TestMoveFileWithProgressCancel;
   end;
 
+  TestTDirectorySync = class(TFileSystemTestCase)
+  private
+    FDirA: string;
+    FDirB: string;
+    FSync: TDirectorySync;
+    FFile1: string;
+    FFile2: string;
+    FFile3: string;
+    FFile4: string;
+    FFile5: string;
+    FFile6: string;
+    FFileA7: string;
+    FFileB7: string;
+    FCallbacks: TStringList;
+    FExistingFiles: TStringList;
+    procedure OnSyncDirAbort(_Sender: TObject; const _Src, _Dst: string);
+    procedure OnSyncCallback(_Sender: TObject; const _Src, _Dst: string);
+    procedure OnFileExistsCallback(_Sender: TObject; const _Src, _Dst: TFileInfoRec);
+    procedure CheckSameText(const _Expected, _Actual, _Msg: string);
+  protected
+    procedure SetUp; override;
+    procedure TearDown; override;
+  published
+    procedure TestSyncOneWay;
+    procedure TestSyncBoth;
+    procedure TestSyncAbortImmediately;
+    procedure TestSyncOneWayCallback;
+    procedure TestCheckOneWay;
+  end;
+
+  TestTFileGenerationHandler_Base = class(TFileSystemTestCase)
+  private
+    FHandler: TFileGenerationHandler;
+  protected
+    procedure SetUp; override;
+    procedure TearDown; override;
+  end;
+
+  TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
+  published
+    procedure TestNoneExisting;
+    procedure TestOneExisting;
+    procedure TestAllExisting;
+  end;
+
+  TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep = class(TestTFileGenerationHandler_Base)
+  published
+    procedure TestNoneExisting;
+    procedure TestOneExisting;
+    procedure TestAllExisting;
+  end;
+
+  TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
+  protected
+    procedure SetUp; override;
+  published
+    procedure TestNoneExisting;
+    procedure TestOneExisting;
+    procedure TestTwoExisting;
+    procedure TestAllExisting;
+  end;
+
+  TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep = class(TestTFileGenerationHandler_Base)
+  protected
+    procedure SetUp; override;
+  published
+    procedure TestNoneExisting;
+    procedure TestOneExisting;
+    procedure TestTwoExisting;
+    procedure TestAllExisting;
+  end;
+
+  TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
+  protected
+    procedure SetUp; override;
+  published
+    procedure TestNoneExisting;
+    procedure TestOneExisting;
+    procedure TestAllExisting;
+  end;
+
+  TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
+  protected
+    procedure SetUp; override;
+  published
+    procedure TestNoneExisting;
+    procedure TestOneExisting;
+    procedure TestAllExisting;
+  end;
+
 implementation
 
+{ TFileSystemTestCase }
 
+procedure TFileSystemTestCase.CheckTestfile(const _Filename, _Content: string);
+var
+  t: TextFile;
+  s: string;
+begin
+  Check(FileExists(FTestDir + _Filename), _Filename + ' does not exist');
+  AssignFile(t, FTestDir + _Filename);
+  Reset(t);
+  Read(t, s);
+  Close(t);
+  CheckEquals(_Content, s, 'content of file ' + _Filename);
+end;
+
+procedure TFileSystemTestCase.CheckSubdirExists(const _Dirname: string);
+begin
+  Check(DirectoryExists(FTestDir + _Dirname), 'directory ' + _Dirname + ' missing');
+end;
+
+function TFileSystemTestCase.CreateTestFile(const _Filename, _Content: string): string;
+var
+  t: TextFile;
+begin
+  Result := FTestDir + _Filename;
+  AssignFile(t, Result);
+  Rewrite(t);
+  WriteLn(t, _Content);
+  Close(t);
+end;
+
+procedure TFileSystemTestCase.SetUp;
+begin
+  inherited;
+  FTestDir := itpd(TFileSystem.CreateUniqueDirectory());
+end;
+
+procedure TFileSystemTestCase.TearDown;
+begin
+  TFileSystem.DelTree(FTestDir);
+  inherited;
+end;
+
+const
+  GENERATION_FILENAME = 'hallo';
+  GENERATION_SUFFIX = '.txt';
+
 { TestTFileSystem }
 
 procedure TestTFileSystem.ProgressCancel(_Status: TCopyProgressStatus;
@@ -45,48 +195,588 @@
 end;
 
 procedure TestTFileSystem.SetUp;
+const
+  SOURCEFILE = 'sourcefile.txt';
+  DESTFILE = 'destfile.txt';
 begin
   inherited;
   FCallbackCount := 0;
+  FSourceFile := CreateTestFile(SOURCEFILE, 'source');
+  FDestFile := FTestDir + DESTFILE;
+  if FileExists(FDestFile) then
+    TFileSystem.DeleteFile(FDestFile);
 end;
 
+procedure TestTFileSystem.TearDown;
+begin
+  inherited;
+  TFileSystem.DeleteFile(FSourceFile, false);
+  TFileSystem.DeleteFile(FDestFile, false);
+end;
+
 procedure TestTFileSystem.TestCopyFileWithProgressContinue;
-const
-  SOURCEFILE = 'testdata\sourcefile.txt';
-  DESTFILE = 'testdata\destfile.txt';
 var
   Res: TFileSystem.TCopyFileWithProgressResult;
 begin
-  Res := TFileSystem.CopyFileWithProgress(SOURCEFILE, DESTFILE, ProgressContinue);
+  Res := TFileSystem.CopyFileWithProgress(FSourceFile, FDestFile, ProgressContinue);
   Check(Res = cfwOK, 'aborted or error');
-  CheckTrue(FileExists(DESTFILE), 'destination file missing');
+  CheckTrue(FileExists(FDestFile), 'destination file missing');
   CheckEquals(2, FCallbackCount, 'Callback count wrong');
 end;
 
 procedure TestTFileSystem.TestMoveFileWithProgressCancel;
-const
-  SOURCEFILE = 'testdata\sourcefile.txt';
-  DESTFILE = 'testdata\destfile.txt';
 var
   Res: TFileSystem.TCopyFileWithProgressResult;
 begin
-  Res := TFileSystem.MoveFileWithProgress(SOURCEFILE, DESTFILE, ProgressCancel, []);
+  Res := TFileSystem.MoveFileWithProgress(FSourceFile, FDestFile, ProgressCancel, []);
   Check(Res = cfwOK, 'aborted expected');
+  CheckFalse(FileExists(FDestFile), 'destination file exists');
 end;
 
 procedure TestTFileSystem.TestCopyFileWithProgressCancel;
-const
-  SOURCEFILE = 'testdata\sourcefile.txt';
-  DESTFILE = 'testdata\destfile.txt';
 var
   Res: TFileSystem.TCopyFileWithProgressResult;
 begin
-  Res := TFileSystem.CopyFileWithProgress(SOURCEFILE, DESTFILE, ProgressCancel, []);
+  Res := TFileSystem.CopyFileWithProgress(FSourceFile, FDestFile, ProgressCancel, []);
   Check(Res = cfwAborted, 'aborted expected');
   CheckEquals(1, FCallbackCount, 'Callback count wrong');
 end;
 
+{ TestTFileGenerationHandler_Base }
+
+procedure TestTFileGenerationHandler_Base.SetUp;
+begin
+  inherited;
+  FHandler := TFileGenerationHandler.Create(FTestDir + GENERATION_FILENAME, GENERATION_SUFFIX);
+end;
+
+procedure TestTFileGenerationHandler_Base.TearDown;
+begin
+  FHandler.Free;
+  inherited;
+end;
+
+{ TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber }
+
+procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.TestAllExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
+  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
+  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
+  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.TestNoneExisting;
+var
+  s: string;
+begin
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+end;
+
+procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.TestOneExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+{ TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep }
+
+procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.TestAllExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
+  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
+  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
+  s := FHandler.Execute(True);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
+  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.TestNoneExisting;
+var
+  s: string;
+begin
+  s := FHandler.Execute(true);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+end;
+
+procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.TestOneExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(true);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+{ TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber }
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.SetUp;
+begin
+  inherited;
+  FHandler.OldestIsHighest := false;
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestAllExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '5');
+  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
+  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
+  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
+  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
+  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestNoneExisting;
+var
+  s: string;
+begin
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestOneExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestTwoExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_3' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+{ TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep }
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.SetUp;
+begin
+  inherited;
+  FHandler.OldestIsHighest := false;
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestAllExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '5');
+  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
+  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
+  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(true);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '5');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
+  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
+  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestNoneExisting;
+var
+  s: string;
+begin
+  s := FHandler.Execute(true);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestOneExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(true);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestTwoExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(true);
+  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
+  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '2');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_3' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+{ TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber }
+
+procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.SetUp;
+begin
+  inherited;
+  FHandler.ResultContainsNumber := true;
+end;
+
+procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.TestAllExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
+  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
+  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
+  CreateTestfile(GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, '6');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
+  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
+  CheckTestfile(GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, '5');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_6' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.TestNoneExisting;
+var
+  s: string;
+begin
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+end;
+
+procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.TestOneExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '1');
+end;
+
+{ TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber }
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.SetUp;
+begin
+  inherited;
+  FHandler.OldestIsHighest := false;
+  FHandler.ResultContainsNumber := true;
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.TestAllExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
+  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
+  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
+  CreateTestfile(GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, '5');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
+  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
+  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
+  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_6' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.TestNoneExisting;
+var
+  s: string;
+begin
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+end;
+
+procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.TestOneExisting;
+var
+  s: string;
+begin
+  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  s := FHandler.Execute(false);
+  CheckEquals(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, s, 'filename');
+  CheckFalse(FileExists(s), 'file exists');
+  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_3' + GENERATION_SUFFIX), 'additional backup file exists');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_4' + GENERATION_SUFFIX), 'additional backup file exists');
+  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
+end;
+
+{ TestTDirectorySync }
+
+procedure TestTDirectorySync.SetUp;
+begin
+  inherited;
+  FDirA := FTestDir + 'a\';
+  FDirB := FTestDir + 'b\';
+  TFileSystem.CreateDir(FDirA);
+  TFileSystem.CreateDir(FDirB);
+
+  FFile1 := CreateTestfile('a\file1.txt', 'File1');
+  FFile2 := CreateTestfile('a\.txt', 'File2');
+  FFile3 := CreateTestfile('a\file3', 'File3');
+  TFileSystem.CreateDir(FDirA + '\Sub1');
+  TFileSystem.CreateDir(FDirA + '\Sub2');
+  FFile4 := CreateTestfile('a\Sub2\file4.txt', 'File4');
+
+  FFile5 := CreateTestFile('b\file5.txt', 'File5');
+  TFileSystem.CreateDir(FDirB + '\Sub3');
+  FFile6 := CreateTestFile('b\sub3\file6.txt', 'File6');
+  TFileSystem.CreateDir(FDirB + '\Sub4');
+
+  TFileSystem.CreateDir(FDirA + '\Sub5');
+  TFileSystem.CreateDir(FDirB + '\Sub5');
+
+  TFileSystem.CreateDir(FDirA + '\Sub6');
+  TFileSystem.CreateDir(FDirB + '\Sub6');
+  FFileA7 := CreateTestFile('a\sub6\file7.txt', 'FileA7');
+  FFileB7 := CreateTestFile('b\sub6\file7.txt', 'FileB7');
+
+  FCallbacks := TStringList.Create;
+
+  FSync := TDirectorySync.Create;
+end;
+
+procedure TestTDirectorySync.TearDown;
+begin
+  FSync.Free;
+  FCallbacks.Free;
+  inherited;
+end;
+
+procedure TestTDirectorySync.TestSyncOneWay;
+var
+  Enum: TSimpleDirEnumerator;
+  Files: TStringList;
+  cnt: integer;
+begin
+  FSync.SyncOneWay(FDirA, FDirB);
+  Enum := TSimpleDirEnumerator.Create(FDirB + '*.*');
+  try
+    Files := TStringList.Create;
+    cnt := Enum.FindAll(Files);
+    Files.Free;
+  finally
+    Enum.Free;
+  end;
+  CheckEquals(10, cnt, 'number of files and subdirs');
+  CheckTestfile('b\' + ExtractFileName(FFile1), 'File1');
+  CheckTestfile('b\' + ExtractFileName(FFile2), 'File2');
+  CheckTestfile('b\' + ExtractFileName(FFile3), 'File3');
+  CheckSubdirExists('b\Sub1');
+  CheckSubdirExists('b\Sub2');
+  CheckTestfile('b\Sub2\' + ExtractFileName(FFile4), 'File4');
+  CheckTestfile('b\' + ExtractFileName(FFile5), 'File5');
+  CheckSubdirExists('b\Sub3');
+  CheckTestfile('b\Sub3\' + ExtractFileName(FFile6), 'File6');
+  CheckSubdirExists('b\Sub4');
+
+  CheckSubdirExists('b\Sub5');
+  CheckSubdirExists('b\Sub6');
+  CheckTestfile('b\Sub6\' + ExtractFileName(FFileB7), 'FileB7');
+end;
+
+procedure TestTDirectorySync.TestSyncOneWayCallback;
+begin
+  FSync.OnSyncingDir := OnSyncCallback;
+  FSync.OnSyncingFile := OnSyncCallback;
+  FSync.SyncOneWay(FDirA, FDirB);
+  CheckEquals(9, FCallbacks.Count, 'callback count');
+  CheckEquals(FDirA + ' -&gt; ' + FDirB, FCallbacks[0], 'callback 0');
+  CheckEquals(FDirA + '.txt -&gt; ' + FDirB + '.txt', FCallbacks[1], 'callback 1');
+  CheckEquals(FDirA + 'file1.txt -&gt; ' + FDirB + 'file1.txt', FCallbacks[2], 'callback 2');
+  CheckEquals(FDirA + 'file3 -&gt; ' + FDirB + 'file3', FCallbacks[3], 'callback 3');
+  CheckEquals(FDirA + 'Sub1 -&gt; ' + FDirB + 'Sub1', FCallbacks[4], 'callback 4');
+  CheckEquals(FDirA + 'Sub2 -&gt; ' + FDirB + 'Sub2', FCallbacks[5], 'callback 5');
+  CheckEquals(FDirA + 'Sub2\file4.txt -&gt; ' + FDirB + 'Sub2\file4.txt', FCallbacks[6], 'callback 6');
+  CheckEquals(FDirA + 'Sub5 -&gt; ' + FDirB + 'Sub5', FCallbacks[7], 'callback 7');
+  CheckEquals(FDirA + 'Sub6 -&gt; ' + FDirB + 'Sub6', FCallbacks[8], 'callback 8');
+end;
+
+procedure TestTDirectorySync.OnSyncCallback(_Sender: TObject; const _Src, _Dst: string);
+begin
+  FCallbacks.Add(_Src + ' -&gt; ' + _Dst);
+end;
+
+procedure TestTDirectorySync.OnSyncDirAbort(_Sender: TObject; const _Src, _Dst: string);
+begin
+  SysUtils.Abort;
+end;
+
+procedure TestTDirectorySync.CheckSameText(const _Expected, _Actual, _Msg: string);
+begin
+  if not SameText(_Expected, _Actual) then
+    FailNotEquals(_Expected, _Actual, _Msg);
+end;
+
+procedure TestTDirectorySync.OnFileExistsCallback(_Sender: TObject; const _Src, _Dst: TFileInfoRec);
+begin
+  FExistingFiles.Add(_Src.Filename + ' &lt;&gt; ' + _Dst.Filename);
+  CheckEquals(_Src.Size, _Dst.Size, 'Size');
+  CheckEquals(_Src.Timestamp, _Dst.Timestamp, 'Timestamp');
+end;
+
+procedure TestTDirectorySync.TestCheckOneWay;
+begin
+  FExistingFiles := TStringList.Create;
+  try
+    FSync.OnFileExists := OnFileExistsCallback;
+    FSync.CheckOneWay(FDirA, FDirB);
+    CheckEquals(1, FExistingFiles.Count, 'existing count');
+    CheckSameText(FFileA7 + ' &lt;&gt; ' + FFileB7, FExistingFiles[0], 'File7');
+  finally
+    FExistingFiles.Free;
+  end;
+end;
+
+procedure TestTDirectorySync.TestSyncAbortImmediately;
+var
+  Enum: TSimpleDirEnumerator;
+  Files: TStringList;
+  cnt: integer;
+begin
+  FSync.OnSyncingDir := OnSyncDirAbort;
+  try
+    FSync.SyncOneWay(FDirA, FDirB);
+  except on EAbort do
+      ;
+  end;
+  Enum := TSimpleDirEnumerator.Create(FDirB + '*.*');
+  try
+    Files := TStringList.Create;
+    cnt := Enum.FindAll(Files);
+    Files.Free;
+  finally
+    Enum.Free;
+  end;
+  CheckEquals(5, cnt, 'number of files and subdirs');
+end;
+
+procedure TestTDirectorySync.TestSyncBoth;
+var
+  Enum: TSimpleDirEnumerator;
+  Files: TStringList;
+  cnt: integer;
+begin
+  FSync.SyncBothWays(FDirA, FDirB);
+
+  Enum := TSimpleDirEnumerator.Create(FDirB + '*.*');
+  try
+    Files := TStringList.Create;
+    cnt := Enum.FindAll(Files);
+    Files.Free;
+  finally
+    Enum.Free;
+  end;
+  CheckEquals(10, cnt, 'number of files and subdirs');
+  CheckTestfile('b\' + ExtractFileName(FFile1), 'File1');
+  CheckTestfile('b\' + ExtractFileName(FFile2), 'File2');
+  CheckTestfile('b\' + ExtractFileName(FFile3), 'File3');
+  CheckSubdirExists('b\Sub1');
+  CheckSubdirExists('b\Sub2');
+  CheckTestfile('b\Sub2\' + ExtractFileName(FFile4), 'File4');
+  CheckTestfile('b\' + ExtractFileName(FFile5), 'File5');
+  CheckSubdirExists('b\Sub3');
+  CheckTestfile('b\Sub3\' + ExtractFileName(FFile6), 'File6');
+  CheckSubdirExists('b\Sub4');
+
+  CheckSubdirExists('b\Sub5');
+  CheckSubdirExists('b\Sub6');
+  CheckTestfile('b\Sub6\' + ExtractFileName(FFileB7), 'FileB7');
+
+  Enum := TSimpleDirEnumerator.Create(FDirA + '*.*');
+  try
+    Files := TStringList.Create;
+    cnt := Enum.FindAll(Files);
+    Files.Free;
+  finally
+    Enum.Free;
+  end;
+  CheckEquals(10, cnt, 'number of files and subdirs');
+  CheckTestfile('a\' + ExtractFileName(FFile1), 'File1');
+  CheckTestfile('a\' + ExtractFileName(FFile2), 'File2');
+  CheckTestfile('a\' + ExtractFileName(FFile3), 'File3');
+  CheckSubdirExists('a\Sub1');
+  CheckSubdirExists('a\Sub2');
+  CheckTestfile('a\Sub2\' + ExtractFileName(FFile4), 'File4');
+  CheckTestfile('a\' + ExtractFileName(FFile5), 'File5');
+  CheckSubdirExists('a\Sub3');
+  CheckTestfile('a\Sub3\' + ExtractFileName(FFile6), 'File6');
+  CheckSubdirExists('a\Sub4');
+
+  Check(DirectoryExists(FDirA + 'Sub5'), 'directory Sub5 missing');
+  Check(DirectoryExists(FDirA + 'Sub6'), 'directory Sub6 missing');
+  CheckTestfile('a\Sub6\' + ExtractFileName(FFileB7), 'FileA7');
+end;
+
 initialization
   RegisterTest(TestTFileSystem.Suite);
+  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
+  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.Suite);
+  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
+  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.Suite);
+  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.Suite);
+  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.Suite);
+  RegisterTest(TestTDirectorySync.Suite);
 end.
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000026.html">[Dzchart-svncheckins] r151 - utilities/dzLib/trunk/src
</A></li>
	<LI>Next message: <A HREF="000028.html">[Dzchart-svncheckins] r153 - utilities/dzLib/trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27">[ date ]</a>
              <a href="thread.html#27">[ thread ]</a>
              <a href="subject.html#27">[ subject ]</a>
              <a href="author.html#27">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dzchart-svncheckins">More information about the dzchart-svncheckins
mailing list</a><br>
</body></html>
