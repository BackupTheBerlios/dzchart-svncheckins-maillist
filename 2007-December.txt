From twm at mail.berlios.de  Sun Dec 16 12:13:40 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 12:13:40 +0100
Subject: [Dzchart-svncheckins] r250 - utilities/dzLib/trunk/src
Message-ID: <200712161113.lBGBDen4030615@sheep.berlios.de>

Author: twm
Date: 2007-12-16 12:13:39 +0100 (Sun, 16 Dec 2007)
New Revision: 250

Modified:
   utilities/dzLib/trunk/src/u_dzConvertUtils.pas
Log:
* added GetSystemDefaultLocaleSettings and GetUserDefaultLocaleSettings functions

Modified: utilities/dzLib/trunk/src/u_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-11-15 10:43:04 UTC (rev 249)
+++ utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-12-16 11:13:39 UTC (rev 250)
@@ -212,9 +212,14 @@
 {: returns a human readable string of the form '5d 23h' or '25h 15m' or '20m 21s' }
 function SecondsToHumanReadableString(_Seconds: Int64): string;
 
+{: returns the default locale settings as read from the system's regional settings }
+function GetUserDefaultLocaleSettings: TFormatSettings;
+function GetSystemDefaultLocaleSettings: TFormatSettings;
+
 implementation
 
 uses
+  Windows,
   DateUtils,
   StrUtils,
   u_dzTranslator,
@@ -590,6 +595,16 @@
     Result := Format('%ds', [_Seconds]);
 end;
 
+function GetSystemDefaultLocaleSettings: TFormatSettings;
+begin
+  GetLocaleFormatSettings(GetSystemDefaultLCID, Result);
+end;
+
+function GetUserDefaultLocaleSettings: TFormatSettings;
+begin
+  GetLocaleFormatSettings(GetUserDefaultLCID, Result);
+end;
+
 initialization
   DZ_FORMAT_DECIMAL_POINT := GetUserDefaultLocaleSettings;
   DZ_FORMAT_DECIMAL_POINT.DecimalSeparator := '.';



From twm at mail.berlios.de  Sun Dec 16 12:15:20 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 12:15:20 +0100
Subject: [Dzchart-svncheckins] r251 - utilities/dzLib/trunk/src
Message-ID: <200712161115.lBGBFKlU030687@sheep.berlios.de>

Author: twm
Date: 2007-12-16 12:15:18 +0100 (Sun, 16 Dec 2007)
New Revision: 251

Modified:
   utilities/dzLib/trunk/src/u_dzVclUtils.pas
Log:
* added helper functions for TCheckListBox
* added overloaded TForm_CenterOn functions that center a form on a given coordinate or control but still keeping it fully visible

Modified: utilities/dzLib/trunk/src/u_dzVclUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzVclUtils.pas	2007-12-16 11:13:39 UTC (rev 250)
+++ utilities/dzLib/trunk/src/u_dzVclUtils.pas	2007-12-16 11:15:18 UTC (rev 251)
@@ -1,6 +1,6 @@
 {GXFormatter.config=twm}
 {: Implements functions which work on components but are not methods.
-   @autor        twm }
+   @author        twm }
 unit u_dzVclUtils;
 
 interface
@@ -13,6 +13,7 @@
   Forms,
   Controls,
   ComCtrls,
+  CheckLst,
   StdCtrls,
   ExtCtrls,
   Grids,
@@ -271,6 +272,13 @@
 function TListBox_DeleteSelected(_lst: TCustomListbox): boolean; overload;
 function TListBox_DeleteSelected(_lst: TCustomListBox; out _s: string): boolean; overload;
 
+function TCheckListBox_GetCheckedCount(_clb: TCheckListBox): integer;
+procedure TCheckListBox_DeleteDisabled(_clb: TCheckListBox);
+procedure TCheckListBox_InvertCheckmarks(_clb: TCheckListBox; _IncludeDisabled: boolean = false);
+procedure TCheckListBox_UncheckAll(_clb: TCheckListBox);
+procedure TCheckListBox_CheckAll(_clb: TCheckListBox; _IncludeDisabled: boolean = false);
+function TCheckListBox_GetChecked(_clb: TCheckListBox; _Checked: TStrings; _IncludeDisabled: boolean = false): integer;
+
 {: Gets the caption of the given or selected item in the RadioGroup
    @param rg is the TCustomRadioGroup descendant to read
    @param Caption returns a string with the requested caption with
@@ -344,6 +352,11 @@
 {: sets the Checked property without firing an OnClick event }
 procedure TCheckBox_SetCheckedNoOnClick(_Chk: TCustomCheckBox; _Checked: boolean);
 
+{: centers a form on the given point, but makes sure the form is fully visible }
+procedure TForm_CenterOn(_frm: TForm; _Center: TPoint); overload;
+{: centers a form on the given component, but makes sure the form is fully visible }
+procedure TForm_CenterOn(_frm: TForm; _Center: TWinControl); overload;
+
 {: switches off "Windows Ghosting" in Win 2000 and XP
   This is a workaround for the bug that modal forms sometimes aren't modal in W2K and XP.
   Call in application startup. }
@@ -949,6 +962,59 @@
   Result := TListBox_DeleteSelected(_lst, Idx);
 end;
 
+function TCheckListBox_GetCheckedCount(_clb: TCheckListBox): integer;
+var
+  i: Integer;
+begin
+  Result := 0;
+  for i := 0 to _clb.Items.Count - 1 do
+    if _clb.Checked[i] then
+      Inc(Result);
+end;
+
+procedure TCheckListBox_CheckAll(_clb: TCheckListBox; _IncludeDisabled: boolean = false);
+var
+  i: Integer;
+begin
+  for i := 0 to _clb.Items.Count - 1 do
+    _clb.Checked[i] := _IncludeDisabled or _clb.ItemEnabled[i];
+end;
+
+procedure TCheckListBox_UncheckAll(_clb: TCheckListBox);
+var
+  i: Integer;
+begin
+  for i := 0 to _clb.Items.Count - 1 do
+    _clb.Checked[i] := False;
+end;
+
+procedure TCheckListBox_InvertCheckmarks(_clb: TCheckListBox; _IncludeDisabled: boolean = false);
+var
+  i: Integer;
+begin
+  for i := 0 to _clb.Items.Count - 1 do
+    _clb.Checked[i] := not _clb.Checked[i] and (_IncludeDisabled or _clb.ItemEnabled[i]);
+end;
+
+procedure TCheckListBox_DeleteDisabled(_clb: TCheckListBox);
+var
+  i: integer;
+begin
+  for i := _clb.Items.Count - 1 downto 0 do
+    if not _clb.ItemEnabled[i] then
+      _clb.Items.Delete(i);
+end;
+
+function TCheckListBox_GetChecked(_clb: TCheckListBox; _Checked: TStrings; _IncludeDisabled: boolean = false): integer;
+var
+  i: Integer;
+begin
+  for i := 0 to _clb.Items.Count - 1 do
+    if _clb.Checked[i] and (_IncludeDisabled or _clb.ItemEnabled[i]) then
+      _Checked.Add(_clb.Items[i]);
+  Result := _Checked.Count;
+end;
+
 function TComboBox_Select(_cmb: TCustomComboBox; const _Item: string; _DefaultIdx: integer = -1): integer;
 begin
   Result := _Cmb.Items.IndexOf(_Item);
@@ -1172,6 +1238,23 @@
   end;
 end;
 
+procedure TForm_CenterOn(_frm: TForm; _Center: TPoint);
+var
+  Monitor: TMonitor;
+begin
+  _frm.Position := poDesigned;
+  _frm.DefaultMonitor := dmDesktop;
+  _frm.Left := _Center.X - _frm.Width div 2;
+  _frm.Top := _Center.Y - _frm.Height div 2;
+  Monitor := Screen.MonitorFromPoint(_Center);
+  _frm.MakeFullyVisible(Monitor);
+end;
+
+procedure TForm_CenterOn(_frm: TForm; _Center: TWinControl); overload;
+begin
+  TForm_CenterOn(_frm, _Center.ClientToScreen(Point(_Center.Width div 2, _Center.Height div 2)));
+end;
+
 procedure DisableProcessWindowsGhosting;
 var
   DisableProcessWindowsGhostingProc: procedure;



From twm at mail.berlios.de  Sun Dec 16 14:19:21 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 14:19:21 +0100
Subject: [Dzchart-svncheckins] r252 - utilities/dzLib/trunk/src
Message-ID: <200712161319.lBGDJLfl023954@sheep.berlios.de>

Author: twm
Date: 2007-12-16 14:19:18 +0100 (Sun, 16 Dec 2007)
New Revision: 252

Modified:
   utilities/dzLib/trunk/src/u_dzFileUtils.pas
Log:
converted PasDoc comments to HelpInsight comments

Modified: utilities/dzLib/trunk/src/u_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-16 11:15:18 UTC (rev 251)
+++ utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-16 13:19:18 UTC (rev 252)
@@ -1,5 +1,7 @@
 {GXFormatter.config=twm}
-{! implements utility functions for file accesss }
+/// <summary>
+/// implements utility functions for file accesss
+/// </summary>
 unit u_dzFileUtils;
 
 {$I jedi.inc}
@@ -14,7 +16,9 @@
 type
   EFileUtils = class(Exception);
   ECreateUniqueDir = class(EFileUtils);
-  {! raised by DelTree if the DirName parameter is not a valid directory name }
+  /// <summary>
+  /// raised by DelTree if the DirName parameter is not a valid directory name
+  /// </summary>
   EDirNotFound = class(EFileUtils);
   EPathTooLong = class(EFileUtils);
   EInvalidPropertyCombination = class(EFileUtils);
@@ -40,86 +44,117 @@
   end;
 
 type
-  {! a simple wrapper around FindFirst/FindNext which allows to search for
-     specified attributes only (e.g. only directories), it automatically
-     ignores the special '.' and '..' directories. }
+  /// <summary>
+  /// a simple wrapper around FindFirst/FindNext which allows to search for
+  /// specified attributes only (e.g. only directories), it automatically
+  /// ignores the special '.' and '..' directories.
+  /// </summary>
   TSimpleDirEnumerator = class
   protected
-    {! stores the search mask ('c:\windows\*.exe') }
+    /// stores the search mask ('c:\windows\*.exe')
     FMask: string;
-    {! set of attributes a file must match }
+    /// set of attributes a file must match
     FMustHaveAttr: TFileAttributeSet;
-    {! set of attributes a file may have }
+    /// set of attributes a file may have
     FMayHaveAttr: TFileAttributeSet;
-    {! internally used TSearchRec structure }
+    /// internally used TSearchRec structure
     FSr: TSearchRec;
-    {! true if FindFirst was called and returned no error code }
+    /// true if FindFirst was called and returned no error code
     FActive: boolean;
-    {! number of matching files found }
+    /// number of matching files found
     FMatchCount: integer;
   public
-    {! creates a TSimpleDirEnumerator, sets the Mask, MustHaveAttr and MayHaveAttr
-       properties.
-       MustHaveAttr is set to [] and MayHaveAttr is set to include all possible
-       attributes, so calling FindNext will find any files or subdirectories,
-       but the special '.' and '..' directories
-       @param(Mask is the file search mask) }
+    /// <summary>
+    /// Creates a TSimpleDirEnumerator, sets the Mask, MustHaveAttr and MayHaveAttr
+    /// properties.
+    /// MustHaveAttr is set to [] and MayHaveAttr is set to include all possible
+    /// attributes, so calling FindNext will find any files or subdirectories,
+    /// but the special '.' and '..' directories
+    /// @param(Mask is the file search mask)
+    /// </summary>
     constructor Create(const _Mask: string);
-    {! Destructor, will call FindClose if necessary }
+    /// <summary>
+    /// Destructor, will call FindClose if necessary
+    /// </summary>
     destructor Destroy; override;
-    {! creates a TSimpleDirEnumerator, calls its FindAll method and frees it }
+    /// <summary>
+    /// creates a TSimpleDirEnumerator, calls its FindAll method and frees it
+    /// </summary>
     class function Execute(const _Mask: string; _List: TStrings): integer;
-    {! Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
-       calls.
-       @param Filename is the name of the file found, if result is true, if you need
-              more information about it, use the SR property
-       @Returns true, if a matching file was found, false otherwise }
+    /// <summary>
+    /// Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
+    /// calls.
+    /// @param Filename is the name of the file found, if result is true, if you need
+    ///       more information about it, use the SR property
+    /// @Returns true, if a matching file was found, false otherwise
+    /// </summary>
     function FindNext(out _Filename: string): boolean; overload;
-    {! Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
-       calls. If it returns true, use the SR property to get information about
-       the file. See the overloaded @link(FindNext) version if you need only
-       the filename.
-       @Returns(true, if a matching file was found, false otherwise) }
+    /// <summary>
+    /// Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
+    /// calls. If it returns true, use the SR property to get information about
+    /// the file. See the overloaded @link(FindNext) version if you need only
+    /// the filename.
+    /// @Returns(true, if a matching file was found, false otherwise)
+    /// </summary>
     function FindNext: boolean; overload;
-    {! Calls FindNext until it returns false, stores all filenames in List and
-       returns the number of files found.
-       @param List is a TStrings object which will be filled with the filenames
-              of matching files, may be nil.
-       @returns the number of mathing files }
+    /// <summary>
+    /// Calls FindNext until it returns false, stores all filenames in List and
+    /// returns the number of files found.
+    /// @param List is a TStrings object which will be filled with the filenames
+    ///        of matching files, may be nil.
+    /// @returns the number of matching files
+    /// </summary>
     function FindAll(_List: TStrings = nil): integer;
-    {! Calls FindClose so FindNext will start again. Reset does not change any
-       properties (e.g. Mask, MustHaveAttr, MayHaveAttr) }
+    /// <summary>
+    /// Calls FindClose so FindNext will start again. Reset does not change any
+    /// properties (e.g. Mask, MustHaveAttr, MayHaveAttr)
+    /// </summary>
     procedure Reset;
-    {! Returns the number of matches so far, that is the number of successful
-       calls to FindNext }
+    /// Returns the number of matches so far, that is the number of successful
+    /// calls to FindNext
+    /// </summary>
     property MatchCount: integer read FMatchCount;
-    {! Returns the search mask }
+    /// <summary>
+    /// Returns the search mask
+    /// </summary>
     property Mask: string read FMask; // write fMask;
-    {! the set of attributes a file must have to be found by FindNext }
+    /// <summary>
+    /// the set of attributes a file must have to be found by FindNext
+    /// </summary>
     property MustHaveAttr: TFileAttributeSet read FMustHaveAttr write FMustHaveAttr;
-    {! the set of allowed attributes for a file to be found by FindNext }
+    /// <summary>
+    /// the set of allowed attributes for a file to be found by FindNext
+    /// </summary>
     property MayHaveAttr: TFileAttributeSet read FMayHaveAttr write FMayHaveAttr;
-    {! the search rec containing additional information about the file }
+    /// <summary>
+    /// the search rec containing additional information about the file
+    /// </summary>
     property Sr: TSearchRec read FSr;
   end;
 
 type
-  {! represents the status of a CopyFile/MoveFileWithProgress operation, passed
-     as parameter to the callback function. }
+  /// <summary>
+  /// Represents the status of a CopyFile/MoveFileWithProgress operation, passed
+  /// as parameter to the callback function.
+  /// </summary>
   TCopyProgressStatus = class
   public
   {(*}
   type
-    {! possible return values for the callback function }
+    /// <summary>
+    /// possible return values for the callback function
+    /// </summary>
     TProgressResult = (
-      prContinue, {!< continue with the copy/move operation }
-      prCancel,   {!< cancel the operation, cannot be resumed }
-      prStop,     {!< stop the operation, can be resumed, if cfwRestartable was passed }
-      prQuiet);   {!< continue the operation, do not call the callback }
-    {! reason for calling the callback function }
+      prContinue, /// < continue with the copy/move operation
+      prCancel,   /// < cancel the operation, cannot be resumed
+      prStop,     /// < stop the operation, can be resumed, if cfwRestartable was passed
+      prQuiet);   /// < continue the operation, do not call the callback
+    /// <summary>
+    /// reason for calling the callback function
+    /// </summary>
     TProgressReason = (
-      prChunkFinished, {!< a chunk of the file has been copied }
-      prStreamSwitch); {!< started to copy a new stream (set in the first callback) }
+      prChunkFinished, /// < a chunk of the file has been copied
+      prStreamSwitch); /// < started to copy a new stream (set in the first callback)
   {*)}
   protected
     FTotalFileSize: LARGE_INTEGER;
@@ -131,34 +166,65 @@
     FSourceFile: THandle;
     FDestinationFile: THandle;
   public
-    {! total size of the file }
+    /// <summary>
+    /// total size of the file
+    /// </summary>
     property TotalFileSize: LARGE_INTEGER read FTotalFileSize;
-    {! total bytes that have been transferred so far }
+    /// <summary>
+    /// total bytes that have been transferred so far
+    /// </summary>
     property TotalBytesTransferred: LARGE_INTEGER read FTotalBytesTransferred;
-    {! size of the stream that is currently being transferred }
+    /// <summary>
+    /// size of the stream that is currently being transferred
+    /// </summary>
     property StreamSize: LARGE_INTEGER read FStreamSize;
-    {! bytes of the current stream taht have been transferred so far }
+    /// <summary>
+    /// bytes of the current stream taht have been transferred so far
+    /// </summary>
     property StreamBytesTransferred: LARGE_INTEGER read FStreamBytesTransferred;
-    {! Number of the current stream, starts with 1 (usually always 1) }
+    /// <summary>
+    /// Number of the current stream, starts with 1 (usually always 1)
+    /// </summary>
     property StreamNumber: LongWord read FStreamNumber;
-    {! reason for callback }
+    /// <summary>
+    /// reason for callback
+    /// </summary>
     property CallbackReason: TProgressReason read FCallbackReason;
-    {! Handle of source file }
+    /// <summary>
+    /// Handle of source file
+    /// </summary>
     property SourceFile: THandle read FSourceFile;
-    {! Handle of destination file }
+    /// <summary>
+    /// Handle of destination file
+    /// </summary>
     property DestinationFile: THandle read FDestinationFile;
   end;
+
+  ///<summary>
+  /// Type for OnCopyFileProgress event
+  ///  @param Status is the currenct status of the operation
+  ///  @param Continue determines whether to continue copying or aborting, defaults
+  ///         to prContinue
+  /// </summary>
   TCopyFileProgressEvt = procedure(_Status: TCopyProgressStatus;
     var _Continue: TCopyProgressStatus.TProgressResult) of object;
 
-  {! defines the action to take if a file already exists but has a different content }
+  /// <summary>
+  /// defines the action to take if a file already exists but has a different content
+  /// </summary>
   TFileExistsAction = (feaIgnore, feaOverwrite);
   TOnSyncing = procedure(_Sender: TObject; const _SrcDir, _DstDir: string) of object;
   TOnSyncingFile = procedure(_Sender: TObject; const _SrcDir, _DstDir: string; _Total, _Done: Int64) of object;
-  {! called if a destination file already exists
-     @param Action is the action to take, default is feaIgnore }
+
+  /// <summary>
+  /// called if a destination file already exists
+  /// @param Action is the action to take, default is feaIgnore
+  /// </summary>
   TOnFileExists = procedure(_Sender: TObject; const _SrcFile, _DstFile: TFileInfoRec; var _Action: TFileExistsAction) of object;
-  {! Synchronizes two directories }
+
+  /// <summary>
+  /// Synchronizes two directories
+  /// </summary>
   TDirectorySync = class
   private
     FCurrentSource: string;
@@ -174,36 +240,50 @@
     function doOnFileExists(const _SrcDir, _DstDir, _Filename: string): TFileExistsAction;
     procedure ProgressStatusCallback(_Status: TCopyProgressStatus; var _Continue: TCopyProgressStatus.TProgressResult);
   public
-    {! Checks if there are files in the source directory that are already in
-       the destination directory, for each file that exists, the OnFileExists
-       event is called. }
+    /// <summary>
+    /// Checks if there are files in the source directory that are already in
+    /// the destination directory, for each file that exists, the OnFileExists
+    /// event is called.
+    /// </summary>
     procedure CheckOneWay(const _SrcDir, _DstDir: string);
-    {! copies all files from DirA to DirB if they don't already exists
-       (not implemented: if CheckContent=true, the content existing files will be checked and if
-                         it doesn't match, OnDifferentFileExists is called )
-       @param FlattenDirHierarchy determines whether all files should be copied
-                                  directly DstDir or if subdirectories should
-                                  be created, default is false }
+    /// <summary>
+    /// copies all files from DirA to DirB if they don't already exists
+    /// (not implemented: if CheckContent=true, the content existing files will be checked and if
+    ///                   it doesn't match, OnDifferentFileExists is called)
+    /// @param FlattenDirHierarchy determines whether all files should be copied
+    ///                            directly DstDir or if subdirectories should
+    ///                            be created, default is false
+    /// </summary>
     procedure SyncOneWay(const _SrcDir, _DstDir: string; _FlattenDirHierarchy: boolean = false);
-    {! calls SyncOneWay(DirA, DirB) and SyncOneWay(DirB, DirA)
-       (not implemented: if CheckContent=true, the content existing files will be checked and if
-                         it doesn't match, OnDifferentFileExists is called ) }
+    /// <summary>
+    /// calls SyncOneWay(DirA, DirB) and SyncOneWay(DirB, DirA)
+    /// (not implemented: if CheckContent=true, the content existing files will be checked and if
+    ///                   it doesn't match, OnDifferentFileExists is called)
+    /// </summary>
     procedure SyncBothWays(const _DirA, _DirB: string);
 //    {! Not implemented: Called, if the content of an existing file is different }
 //    property OnDifferentFileExists: TOnDifferentFileExists read FOnDifferentFileExists write FOnDifferentFileExists;
 //    {! Not implemented: if true, OnDifferentFileExists will be called }
 //    property CheckContent: boolean read FCheckContent write FCheckContent default false;
-    {! called when a new directory is entered, to abort synchronization,
-       raise an exception (e.g. SysUtils.Abort), and catch it in the calling method }
+    /// <summary>
+    /// called when a new directory is entered, to abort synchronization,
+    /// raise an exception (e.g. SysUtils.Abort), and catch it in the calling method
+    /// </summary>
     property OnSyncingDir: TOnSyncing read FOnSyncingDir write FOnSyncingDir;
-    {! called when a file is being copied, to abort synchronization,
-      raise an exception (e.g. SysUtils.Abort), and catch it in the calling method }
+    /// <summary>
+    /// called when a file is being copied, to abort synchronization,
+    /// raise an exception (e.g. SysUtils.Abort), and catch it in the calling method
+    /// </summary>
     property OnSyncingFile: TOnSyncingFile read FOnSyncingFile write FOnSyncingFile;
-    {! called from CheckOneWay if a destination file already exists }
+    /// <summary>
+    /// called from CheckOneWay if a destination file already exists
+    /// </summary>
     property OnFileExists: TOnFileExists read FOnFileExists write FOnFileExists;
   end;
 
-  {! This class owns all utility functions as class methods so they don't pollute the name space }
+  /// <summary>
+  /// This class owns all utility functions as class methods so they don't pollute the name space
+  /// </summary>
   TFileSystem = class
   public
   {(*}
@@ -215,205 +295,254 @@
     TCopyFileWithProgressFlagSet = set of TCopyFileWithProgressFlags;
     TCopyFileWithProgressResult = (cfwOK, cfwAborted, cfwError);
     TMoveFileWithProgressFlags = (
-      mfwFailIfExists, {!< fail if the destination file already exists }
-      mfwAllowCopy,    {!< allow using copy and delete if necessary }
-      mfwDelayUntilReboot, {!< wait until next reboot for moving the file }
-      mfwWriteThrough, {!< Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. }
-      mfwFailIfNotTrackable, {!< The function fails if the source file is a link source, but the file cannot be tracked after the move. }
-      mfwRaiseException); {!< raise an exception if there is an error }
+      mfwFailIfExists, /// < fail if the destination file already exists
+      mfwAllowCopy,    /// < allow using copy and delete if necessary
+      mfwDelayUntilReboot, /// < wait until next reboot for moving the file
+      mfwWriteThrough, /// < Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns.
+      mfwFailIfNotTrackable, /// < The function fails if the source file is a link source, but the file cannot be tracked after the move.
+      mfwRaiseException); /// < raise an exception if there is an error
     TMoveFileWithProgressFlagSet = set of TMoveFileWithProgressFlags;
   const
-  {! set of char constant containing all characters that are invalid in a filename }
+    /// <summary>
+    /// set of char constant containing all characters that are invalid in a filename
+    /// </summary>
     INVALID_FILENAME_CHARS: set of Char = ['\', '/', ':', '*', '?', '"', '<', '>', '|'];
   {*)}
-    {! Returns a temporary filename.
-       @param Directory is a string with the directory to create the file in, defaults
-                        to the TEMP directory.
-       @param Prefix is a string with a prefix for the filename, defaults to 'dz'.)
-       @param Unique is an word that the function converts to a hexadecimal string
-       for use in creating the temporary filename.)
-       <ul>
-         <li>If Unique is nonzero, the function appends the hexadecimal string to
-             <b>Prefix</b>
-             to form the temporary filename. In this case, the function does not create
-             the specified file, and does not test whether the filename is unique.</li>
-         <li>If Unique is zero, the function uses a hexadecimal string derived
-             from the current system time. In this case, the function uses different
-             values until it finds a unique filename, and then it creates the file
-             in the <b>Directory</b>.</li>
-       </ul>
-       @returns a filename to use for a temporary file. }
+    /// <summary>
+    /// Returns a temporary filename.
+    /// @param Directory is a string with the directory to create the file in, defaults
+    ///                  to the TEMP directory.
+    /// @param Prefix is a string with a prefix for the filename, defaults to 'dz'.)
+    /// @param Unique is an word that the function converts to a hexadecimal string
+    /// for use in creating the temporary filename.)
+    /// <ul>
+    ///   <li>If Unique is nonzero, the function appends the hexadecimal string to
+    ///       <b>Prefix</b>
+    ///       to form the temporary filename. In this case, the function does not create
+    ///       the specified file, and does not test whether the filename is unique.</li>
+    ///   <li>If Unique is zero, the function uses a hexadecimal string derived
+    ///       from the current system time. In this case, the function uses different
+    ///       values until it finds a unique filename, and then it creates the file
+    ///       in the <b>Directory</b>.</li>
+    /// </ul>
+    /// @returns a filename to use for a temporary file.
+    /// </summary>
     class function GetTempFileName(_Directory: string = ''; const _Prefix: string = 'dz';
       _Unique: word = 0): string;
 
-    {! Calls the corresponding Windows function and returns the short path name
-       for an *existing* file or directory. }
+    /// <summary>
+    /// Calls the corresponding Windows function and returns the short path name
+    /// for an *existing* file or directory.
+    /// </summary>
     class function GetShortPathname(const _LongName: string): string;
 
-    {! Creates a unique subdirectory under BaseDir with the given Prefix
-       if Basedir is an empty string the system's %TEMP% directory is used.
-       @returns the name of the created directory }
+    /// <summary>
+    /// Creates a unique subdirectory under BaseDir with the given Prefix
+    /// if Basedir is an empty string the system's %TEMP% directory is used.
+    /// @returns the name of the created directory
+    /// </summary>
     class function CreateUniqueDirectory(_BaseDir: string = ''; const _Prefix: string = 'dz'): string;
 
-    {! Calls the Win32Api function GetTempPath but returns a string rather than
-       a PChar.
-       @returns(a string with the TEMP directory) }
+    /// <summary>
+    /// Calls the Win32Api function GetTempPath but returns a string rather than
+    /// a PChar.
+    /// @returns a string with the TEMP directory
+    /// </summary>
     class function GetTempPath: string;
-    {! Moves the file Source to Dest using the Windows MoveFile function.
-       @param Source is a string containing the name of the existing file
-       @param Dest is a string containing the destination file name
-       @param RaiseException is a boolean which controls whether the function
-              retrieves the Windows error and raises an exception
-              if it fails. If false, it will not raise an exception
-              but just return false if moving the file fails.
-       @returns true, if the file could be moved, false otherwise. }
+    /// <summary>
+    /// Moves the file Source to Dest using the Windows MoveFile function.
+    /// @param Source is a string containing the name of the existing file
+    /// @param Dest is a string containing the destination file name
+    /// @param RaiseException is a boolean which controls whether the function
+    ///        retrieves the Windows error and raises an exception
+    ///        if it fails. If false, it will not raise an exception
+    ///        but just return false if moving the file fails.
+    /// @returns true, if the file could be moved, false otherwise.
+    /// </summary>
     class function MoveFile(const _Source, _Dest: string; _RaiseException: boolean = true): boolean;
-    {! Copies the file Source to Dest using the Windows CopyFile function.
-       @param Source is a string containing the name of the existing file
-       @param Dest is a string containing the destination file name
-       @param FailIfExists is a boolean specifying whether the copy operation
-              should fail if the destination file already exists.
-       @param RaiseException is a boolean which controls whether the function
-              retrieves the Windows error and raises an exception
-              if it fails. If false, it will not raise an exception
-              but just return false if copying the file fails.
-       @param ForceOverwrite is a boolean which controls whether the function removes
-              a read-only flag from the destination file if necessary.
-       @returns true, if the file could be copied, false otherwise. }
+    /// <summary>
+    /// Copies the file Source to Dest using the Windows CopyFile function.
+    /// @param Source is a string containing the name of the existing file
+    /// @param Dest is a string containing the destination file name
+    /// @param FailIfExists is a boolean specifying whether the copy operation
+    ///        should fail if the destination file already exists.
+    /// @param RaiseException is a boolean which controls whether the function
+    ///        retrieves the Windows error and raises an exception
+    ///        if it fails. If false, it will not raise an exception
+    ///        but just return false if copying the file fails.
+    /// @param ForceOverwrite is a boolean which controls whether the function removes
+    ///        a read-only flag from the destination file if necessary.
+    /// @returns true, if the file could be copied, false otherwise.
+    /// </summary>
     class function CopyFile(const _Source, _Dest: string; _FailIfExists: boolean = true;
       _RaiseException: boolean = true; _ForceOverwrite: boolean = false): boolean; overload;
-    {! Copies the file Source to Dest using the Windows CopyFile function.
-       @param(Source is a string containing the name of the existing file)
-       @param(Dest is a string containing the destination file name)
-       @param(Flags is a set of TCopyFileFlags specifying whether the copy operation
-              cfFailIfExists: fail if the destination file already exists.
-              cfForceOverwrite: remove a read-only flag from the destination file if necessary.
-              cfRaiseException: retrieve the Windows error and raise an exception if it fails.
-                If not set, it will not raise an exception but just return false if
-                copying the file fails.)
-       @returns(true, if the file could be copied, false otherwise.) }
+    /// <summary>
+    /// Copies the file Source to Dest using the Windows CopyFile function.
+    /// @param(Source is a string containing the name of the existing file)
+    /// @param(Dest is a string containing the destination file name)
+    /// @param(Flags is a set of TCopyFileFlags specifying whether the copy operation
+    ///        cfFailIfExists: fail if the destination file already exists.
+    ///        cfForceOverwrite: remove a read-only flag from the destination file if necessary.
+    ///        cfRaiseException: retrieve the Windows error and raise an exception if it fails.
+    ///          If not set, it will not raise an exception but just return false if
+    ///          copying the file fails.)
+    /// @returns(true, if the file could be copied, false otherwise.)
+    /// </summary>
     class function CopyFile(const _Source, _Dest: string;
       _Flags: TCopyFileFlagSet = [cfRaiseException]): boolean; overload;
-    {! Copies the file Source to Dest using the Windows CopyFileEx function which
-       allows for a progress callback
-       @param(Source is a string containing the name of the existing file)
-       @param(Dest is a string containing the destination file name)
-       @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
-              cfwFailIfExists: fail if the destination file already exists.
-              cfwRestartable: stores information in the destination file that allows
-                to restart a stopped copy operation
-              cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
-                If not set, it will not raise an exception but just return cfwAborted
-                or cfwError if copying the file fails. (set by default))
-       @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
-                stopped in the callback function and cfeError on any other error.
-       @raises  EOSError if an error occurs and cfwRaiseException was passed }
+    /// <summary>
+    /// Copies the file Source to Dest using the Windows CopyFileEx function which
+    /// allows for a progress callback
+    /// @param(Source is a string containing the name of the existing file)
+    /// @param(Dest is a string containing the destination file name)
+    /// @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
+    ///        cfwFailIfExists: fail if the destination file already exists.
+    ///        cfwRestartable: stores information in the destination file that allows
+    ///          to restart a stopped copy operation
+    ///        cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
+    ///          If not set, it will not raise an exception but just return cfwAborted
+    ///          or cfwError if copying the file fails. (set by default))
+    /// @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
+    ///          stopped in the callback function and cfeError on any other error.
+    /// @raises  EOSError if an error occurs and cfwRaiseException was passed
+    /// </summary>
     class function CopyFileWithProgress(const _Source, _Dest: string; _Progress: TCopyFileProgressEvt;
       _Flags: TCopyFileWithProgressFlagSet = [cfwRaiseException]): TCopyFileWithProgressResult;
-    {! Copies the file Source to Dest using the Windows MoveFileWithProgress function which
-       allows for a progress callback
-       NOTE: If the file can be moved rather than copied, no call to the callback
-             function will occur!
-       @param(Source is a string containing the name of the existing file)
-       @param(Dest is a string containing the destination file name)
-       @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
-              cfwFailIfExists: fail if the destination file already exists.
-              cfwRestartable: stores information in the destination file that allows
-                to restart a stopped copy operation
-              cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
-                If not set, it will not raise an exception but just return cfwAborted
-                or cfwError if copying the file fails. (set by default))
-       @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
-                stopped in the callback function and cfeError on any other error.
-       @raises  EOSError if an error occurs and cfwRaiseException was passed }
+    /// <summary>
+    /// Copies the file Source to Dest using the Windows MoveFileWithProgress function which
+    /// allows for a progress callback
+    /// NOTE: If the file can be moved rather than copied, no call to the callback
+    ///       function will occur!
+    /// @param(Source is a string containing the name of the existing file)
+    /// @param(Dest is a string containing the destination file name)
+    /// @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
+    ///        cfwFailIfExists: fail if the destination file already exists.
+    ///        cfwRestartable: stores information in the destination file that allows
+    ///          to restart a stopped copy operation
+    ///        cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
+    ///          If not set, it will not raise an exception but just return cfwAborted
+    ///          or cfwError if copying the file fails. (set by default))
+    /// @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
+    ///          stopped in the callback function and cfeError on any other error.
+    /// @raises  EOSError if an error occurs and cfwRaiseException was passed
+    /// </summary>
     class function MoveFileWithProgress(const _Source, _Dest: string; _Progress: TCopyFileProgressEvt;
       _Flags: TMoveFileWithProgressFlagSet = [mfwRaiseException]): TCopyFileWithProgressResult;
-    {! Creates a directory (parent directories must already exist)
-       @param DirectoryName is the name for the new directory
-       @param RaiseException determines whether an exception is raised on error, default = true
-       @returns true, if the directory was created
-       @raises EOSError if there was an error and RaiseException was true }
+    /// <summary>
+    /// Creates a directory (parent directories must already exist)
+    /// @param DirectoryName is the name for the new directory
+    /// @param RaiseException determines whether an exception is raised on error, default = true
+    /// @returns true, if the directory was created
+    /// @raises EOSError if there was an error and RaiseException was true
+    /// </summary>
     class function CreateDir(const _DirectoryName: string; _RaiseException: boolean = true): boolean;
-    {! Creates a new directory, including the creation of parent directories as needed.
-       @param DirectoryPath is the name for the new directory
-       @param RaiseException determines whether an exception is raised on error, default = true
-       @returns true, if the directory was created
-       @raises EOSError if there was an error and RaiseException was true }
+    /// <summary>
+    /// Creates a new directory, including the creation of parent directories as needed.
+    /// @param DirectoryPath is the name for the new directory
+    /// @param RaiseException determines whether an exception is raised on error, default = true
+    /// @returns true, if the directory was created
+    /// @raises EOSError if there was an error and RaiseException was true
+    /// </summary>
     class function ForceDir(const _DirectoryPath: string; _RaiseException: boolean = true): boolean;
-    {! Sets a file's readonly flag
-       @param Filename is the file to change
-       @param Set determines whether to set or clear the flag }
+    /// <summary>
+    /// Sets a file's readonly flag
+    /// @param Filename is the file to change
+    /// @param Set determines whether to set or clear the flag
+    /// </summary>
     class function SetReadonly(const _Filename: string; _Set: boolean; _RaiseException: boolean = true): boolean;
-    {! Deletes the file using the SysUtils.DeleteFile function.
-       @param(Filename is a string containing the name of the file)
-       @param(RaiseException is a boolean which controls whether the function
-              retrieves the Windows error and raises an exception
-              if it fails. If false, it will not raise an exception
-              but just return false if moving the file fails. )
-       @param(Force is a boolean which controls whether this function will try to delete
-              readonly files, If true, it will use SetFileAttr to reset the
-              readonly attribut and try to delete the file again.)
-       @returns(true, if the file could be deleted, false otherwise.) }
+    /// <summary>
+    /// Deletes the file using the SysUtils.DeleteFile function.
+    /// @param Filename is a string containing the name of the file
+    /// @param RaiseException is a boolean which controls whether the function
+    ///        retrieves the Windows error and raises an exception
+    ///        if it fails. If false, it will not raise an exception
+    ///        but just return false if moving the file fails. 
+    /// @param Force is a boolean which controls whether this function will try to delete
+    ///        readonly files, If true, it will use SetFileAttr to reset the
+    ///        readonly attribut and try to delete the file again.
+    /// @returns true, if the file could be deleted, false otherwise.
+    /// </summary>
     class function DeleteFile(const _Filename: string; _RaiseException: boolean = true; _Force: boolean = false): boolean;
-    {! Deletes all files in a directory matching a given filemask (non-recursive)
-       @param Dir is a string containting the directory in which the files are to be
-                  deleted, must NOT be empty
-       @param Mask is a string containting the file search mask, all files matching
-                   this mask will be deleted
-       @param RaiseException is a boolean which controls whether the function
-                             retrieves the Windows error and raises an exception
-                             if it fails. If false, it will not raise an exception
-                             but just return false if moving the file fails.
-       @param Force is a boolean which controls whether this function will try to delete
-                    readonly files, If true, it will use SetFileAttr to reset the
-                    readonly attribut and try to delete the file again.
-       @returns the number of files that could not be deleted. }
+    /// <summary>
+    /// Deletes all files in a directory matching a given filemask (non-recursive)
+    /// @param Dir is a string containting the directory in which the files are to be
+    ///            deleted, must NOT be empty
+    /// @param Mask is a string containting the file search mask, all files matching
+    ///             this mask will be deleted
+    /// @param RaiseException is a boolean which controls whether the function
+    ///                       retrieves the Windows error and raises an exception
+    ///                       if it fails. If false, it will not raise an exception
+    ///                       but just return false if moving the file fails.
+    /// @param Force is a boolean which controls whether this function will try to delete
+    ///              readonly files, If true, it will use SetFileAttr to reset the
+    ///              readonly attribut and try to delete the file again.
+    /// @returns the number of files that could not be deleted.
+    /// </summary>
     class function DeleteMatchingFiles(const _Dir, _Mask: string;
       _RaiseException: boolean = true; _Force: boolean = false): integer;
-    {! tries to find a matching file
-       @param Mask is the filename mask to match
-       @param Filename is the name of the file which has been found, only valid if result <> mfNotFound
-       @returns mfNotFound, if no file was found, or mfDirectory, mfFile or mfSpecial
-                describing the type of the file which has been found }
+    /// <summary>
+    /// tries to find a matching file
+    /// @param Mask is the filename mask to match
+    /// @param Filename is the name of the file which has been found, only valid if result <> mfNotFound
+    /// @returns mfNotFound, if no file was found, or mfDirectory, mfFile or mfSpecial
+    ///          describing the type of the file which has been found
+    /// </summary>
     class function FindMatchingFile(const _Mask: string; out _Filename: string): TMatchingFileResult;
     class function RemoveDir(const _Dirname: string; _RaiseException: boolean = true;
       _Force: boolean = false): boolean;
-    {! Deletes a directory with all files and subdirectories.
-       @param(Dirname is the name of the directory to delete)
-       @param(Force specifies whether it should also delete readonly files) }
+    /// <summary>
+    /// Deletes a directory with all files and subdirectories.
+    /// @param(Dirname is the name of the directory to delete)
+    /// @param(Force specifies whether it should also delete readonly files)
+    /// </summary>
     class function DelTree(const _Dirname: string; _Force: boolean = false; _RaiseException: boolean = true): boolean;
-    {! reads a text file and returns its content as a string
-       @param Filename is the name of the file to read
-       @returns the file's content as a string }
+    /// <summary>
+    /// reads a text file and returns its content as a string
+    /// @param Filename is the name of the file to read
+    /// @returns the file's content as a string
+    /// </summary>
     class function ReadTextFile(const _Filename: string): string;
-
-    {! checks whether the given string is a valid filename (without path), that is
-       does not contain one of the characters defined in INVALID_FILENAME_CHARS
-       @param s is the string to check
-       @returns true, if the string is a valid filename, false otherwise }
+    /// <summary>
+    /// checks whether the given string is a valid filename (without path), that is
+    /// does not contain one of the characters defined in INVALID_FILENAME_CHARS
+    /// @param s is the string to check
+    /// @returns true, if the string is a valid filename, false otherwise
+    /// </summary>
     class function IsValidFilename(const _s: string): boolean; overload;
-    {! checks whether the given string is a valid filename (without path), that is
-       does not contain one of the characters defined in INVALID_FILENAME_CHARS and
-       returns the first error position.
-       @param s is the string to check
-       @param ErrPos is the first error position, only valid it result = false
-       @returns true, if the string is a valid filename, false otherwise }
+    /// <summary>
+    /// checks whether the given string is a valid filename (without path), that is
+    /// does not contain one of the characters defined in INVALID_FILENAME_CHARS and
+    /// returns the first error position.
+    /// @param s is the string to check
+    /// @param ErrPos is the first error position, only valid it result = false
+    /// @returns true, if the string is a valid filename, false otherwise
+    /// </summary>
     class function IsValidFilename(const _s: string; out _ErrPos: integer): boolean; overload;
-    {! creates a backup of the file appending the current date and time to the base
-       file name.
-       @param Filename is the name of the file to back up
-       @param BackupDir is a directory in which to create the backup file, if empty
-                        the same directory as the original file is used }
+    /// <summary>
+    /// creates a backup of the file appending the current date and time to the base
+    /// file name.
+    /// @param Filename is the name of the file to back up
+    /// @param BackupDir is a directory in which to create the backup file, if empty
+    ///                  the same directory as the original file is used
+    /// </summary>
     class procedure BackupFile(const _Filename: string; _BackupDir: string = '');
     class function GetFileInfo(const _Filename: string): TFileInfoRec;
-    {! Returns the free space (in bytes) on the disk with the given drive letter }
+    /// <summary>
+    /// Returns the free space (in bytes) on the disk with the given drive letter
+    /// </summary>
     class function DiskFree(_DriveLetter: char): Int64;
   end;
 
 type
-  {! callback event for generating a filename for the given generation }
+  /// <summary>
+  /// callback event for generating a filename for the given generation
+  ///  </summary>
   TOnGenerateFilename = procedure(_Sender: TObject; _Generation: integer; var _Filename: string) of object;
 type
+  /// <summary>
+  /// This class handles keeping gernations of files, e.g. log files. The default
+  /// is to keep 10 generations
+  /// </summary>
   TFileGenerationHandler = class
   private
     FBaseName: string;
@@ -425,28 +554,44 @@
     FPrependZeros: integer;
     function GenerateFilename(_Generation: integer): string;
   public
-    {! @param BaseName is the base filename to which by default _<n> followed by
-                       the Suffix will be appended
-       @param Suffix is the suffix for the filename, usually an extension which
-                     must include the dot (.) }
+    /// <summary>
+    /// @param BaseName is the base filename to which by default _<n> followed by
+    ///                 the Suffix will be appended
+    /// @param Suffix is the suffix for the filename, usually an extension which
+    ///               must include the dot (.)
+    /// </summary>
     constructor Create(const _BaseName, _Suffix: string);
-    {! generates the filename and returns it }
+    /// <summary>
+    /// generates the filename and returns it
+    /// </summary>
     function Execute(_KeepOriginal: boolean): string;
-    {! the maximum of file generations that should be kept }
+    /// <summary>
+    /// the maximum of file generations that should be kept
+    /// </summary>
     property MaxGenerations: integer read FMaxGenerations write FMaxGenerations default 5;
-    {! should the resulting filename contain a number? }
+    /// <summary>
+    /// should the resulting filename contain a number?
+    /// </summary>
     property ResultContainsNumber: boolean read FResultContainsNumber write FResultContainsNumber default false;
-    {! does the oldest file have the highest number? }
+    /// <summary>
+    /// does the oldest file have the highest number?
+    /// </summary>
     property OldestIsHighest: boolean read FOldestIsHighest write FOldestIsHighest default true;
     property PrependZeros: integer read FPrependZeros write FPrependZeros default 0;
-    {! allows read access to the file's base name as passed to the constructor }
+    /// <summary>
+    /// allows read access to the file's base name as passed to the constructor
+    /// </summary>
     property BaseName: string read FBaseName;
     property Suffix: string read FSuffix;
-    {! callback event for generating a filename for the given generation }
+    /// <summary>
+    /// callback event for generating a filename for the given generation
+    /// </summary>
     property OnGenerateFilename: TOnGenerateFilename read FOnGenerateFilename write FOnGenerateFilename;
   end;
 
-{! This is an abbreviation for IncludeTrailingPathDelimiter }
+/// <summary>
+/// This is an abbreviation for IncludeTrailingPathDelimiter
+/// </summary>
 function itpd(const _Dirname: string): string; inline;
 
 implementation
@@ -464,18 +609,18 @@
   STR_GETTEMPFILENAME_ERROR_DS = 'u_dzFileUtils.GetTempFilename: %1:s (Code: %0:d) calling Windows.GetTempFileName';
   STR_GETSHORTPATHNAME_ERROR_DS = 'u_dzFileUtils.GetShortPathname: %1:s (Code: %0:d) calling Windows.GetShortPathname';
   STR_GETSHORTPATHNAME_TOO_LONG_D = 'Short pathname is longer than MAX_PATH (%d) characters';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_MOVEFILE_ERROR_SS = 'Error %%1:s (%%0:d) while trying to move "%s" to "%s".';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_SETREADONLY_ERROR_S = 'Error %%1:s (%%0:d) while changing the readonly flag of "%s"';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_COPYFILE_ERROR_SS = 'Error %%1:s (%%0:d) while trying to copy "%s" to "%s".';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_DELETEFILE_ERROR_S = 'Error %%1:s (%%0:d) deleting file "%s"';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_REMOVEDIR_ERROR_S = 'Error %%1:s (%%0:d) deleting directory "%s"';
   STR_DELTREE_ERROR_S = '"%s" does not exist or is not a directory';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_CREATEDIR_ERROR_S = 'Error %%1:s (%%0:d) creating directory "%s"';
 
 function itpd(const _Dirname: string): string; inline;



From twm at mail.berlios.de  Sun Dec 16 14:57:20 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 14:57:20 +0100
Subject: [Dzchart-svncheckins] r253 - in utilities/dzLib/trunk/tests: .
	dzfileutils
Message-ID: <200712161357.lBGDvKNE026448@sheep.berlios.de>

Author: twm
Date: 2007-12-16 14:57:16 +0100 (Sun, 16 Dec 2007)
New Revision: 253

Added:
   utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr
   utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj
Removed:
   utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr
   utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj
Log:
only one DUnit test project for all tests

Copied: utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr (from rev 252, utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr)

Copied: utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj (from rev 252, utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj)

Deleted: utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr
===================================================================
--- utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr	2007-12-16 13:19:18 UTC (rev 252)
+++ utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dpr	2007-12-16 13:57:16 UTC (rev 253)
@@ -1,41 +0,0 @@
-program DUnitTest_dzFileUtils;
-{
-
-  Delphi DUnit Test Project
-  -------------------------
-  This project contains the DUnit test framework and the GUI/Console test runners.
-  Add "CONSOLE_TESTRUNNER" to the conditional defines entry in the project options 
-  to use the console test runner.  Otherwise the GUI test runner will be used by 
-  default.
-
-}
-
-{$IFDEF CONSOLE_TESTRUNNER}
-{$APPTYPE CONSOLE}
-{$ENDIF}
-
-uses
-  Forms,
-  TestFramework,
-  GUITestRunner,
-  TextTestRunner,
-  u_dzFileUtils in '..\..\src\u_dzFileUtils.pas',
-  Testu_dzFileUtils in 'Testu_dzFileUtils.pas',
-  u_dzMiscUtils in '..\..\src\u_dzMiscUtils.pas',
-  u_dzStringUtils in '..\..\src\u_dzStringUtils.pas',
-  u_dzConvertUtils in '..\..\src\u_dzConvertUtils.pas',
-  u_dzTranslator in '..\..\src\u_dzTranslator.pas',
-  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas',
-  u_dzUnitTestUtils in '..\..\src\u_dzUnitTestUtils.pas',
-  u_dzVariantUtils in '..\..\src\u_dzVariantUtils.pas';
-
-{$R *.RES}
-
-begin
-  Application.Initialize;
-  if IsConsole then
-    TextTestRunner.RunRegisteredTests
-  else
-    GUITestRunner.RunRegisteredTests;
-end.
-

Deleted: utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj
===================================================================
--- utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj	2007-12-16 13:19:18 UTC (rev 252)
+++ utilities/dzLib/trunk/tests/dzfileutils/DUnitTest_dzFileUtils.dproj	2007-12-16 13:57:16 UTC (rev 253)
@@ -1,54 +0,0 @@
-?<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <ProjectGuid>{9732bdc0-39a6-4dbb-817c-3fb77772e288}</ProjectGuid>
-    <MainSource>DUnitTest_dzFileUtils.dpr</MainSource>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <DCC_DCCCompiler>DCC32</DCC_DCCCompiler>
-    <DCC_DependencyCheckOutputName>DUnitTest_dzFileUtils.exe</DCC_DependencyCheckOutputName>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <Version>7.0</Version>
-    <DCC_DebugInformation>False</DCC_DebugInformation>
-    <DCC_LocalDebugSymbols>False</DCC_LocalDebugSymbols>
-    <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
-    <DCC_Define>RELEASE</DCC_Define>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <Version>7.0</Version>
-    <DCC_Define>DEBUG;_CONSOLE_TESTRUNNER;no_translation</DCC_Define>
-    <DCC_UnitSearchPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_UnitSearchPath>
-    <DCC_ResourcePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_ResourcePath>
-    <DCC_ObjPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_ObjPath>
-    <DCC_IncludePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_IncludePath>
-    <DCC_DcuOutput>dcu</DCC_DcuOutput>
-    <DCC_ObjOutput>dcu</DCC_ObjOutput>
-    <DCC_HppOutput>dcu</DCC_HppOutput>
-    <DCC_SYMBOL_PLATFORM>False</DCC_SYMBOL_PLATFORM>
-    <DCC_UNIT_PLATFORM>False</DCC_UNIT_PLATFORM>
-    <DCC_Optimize>False</DCC_Optimize>
-    <DCC_IntegerOverflowCheck>True</DCC_IntegerOverflowCheck>
-    <DCC_RangeChecking>True</DCC_RangeChecking>
-  </PropertyGroup>
-  <ProjectExtensions>
-    <Borland.Personality>Delphi.Personality</Borland.Personality>
-    <Borland.ProjectType />
-    <BorlandProject>
-<BorlandProject><Delphi.Personality><Parameters><Parameters Name="UseLauncher">False</Parameters><Parameters Name="LoadAllSymbols">True</Parameters><Parameters Name="LoadUnspecifiedSymbols">False</Parameters></Parameters><VersionInfo><VersionInfo Name="IncludeVerInfo">False</VersionInfo><VersionInfo Name="AutoIncBuild">False</VersionInfo><VersionInfo Name="MajorVer">1</VersionInfo><VersionInfo Name="MinorVer">0</VersionInfo><VersionInfo Name="Release">0</VersionInfo><VersionInfo Name="Build">0</VersionInfo><VersionInfo Name="Debug">False</VersionInfo><VersionInfo Name="PreRelease">False</VersionInfo><VersionInfo Name="Special">False</VersionInfo><VersionInfo Name="Private">False</VersionInfo><VersionInfo Name="DLL">False</VersionInfo><VersionInfo Name="Locale">1033</VersionInfo><VersionInfo Name="CodePage">1252</VersionInfo></VersionInfo><VersionInfoKeys><VersionInfoKeys Name="CompanyName"></VersionInfoKeys><VersionInfoKeys Name="FileDescription"></VersionInfoKeys><VersionI!
 nfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="InternalName"></VersionInfoKeys><VersionInfoKeys Name="LegalCopyright"></VersionInfoKeys><VersionInfoKeys Name="LegalTrademarks"></VersionInfoKeys><VersionInfoKeys Name="OriginalFilename"></VersionInfoKeys><VersionInfoKeys Name="ProductName"></VersionInfoKeys><VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="Comments"></VersionInfoKeys></VersionInfoKeys><Source><Source Name="MainSource">DUnitTest_dzFileUtils.dpr</Source></Source></Delphi.Personality><UnitTesting><TestFramework>DUnit / Delphi Win32</TestFramework><TestRunner>GUI</TestRunner></UnitTesting></BorlandProject></BorlandProject>
-  </ProjectExtensions>
-  <Import Project="$(MSBuildBinPath)\Borland.Delphi.Targets" />
-  <ItemGroup>
-    <DelphiCompile Include="DUnitTest_dzFileUtils.dpr">
-      <MainSource>MainSource</MainSource>
-    </DelphiCompile>
-    <DCCReference Include="..\..\src\u_dzConvertUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzDateUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzFileUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzMiscUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzStringUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzTranslator.pas" />
-    <DCCReference Include="..\..\src\u_dzUnitTestUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzVariantUtils.pas" />
-    <DCCReference Include="Testu_dzFileUtils.pas" />
-  </ItemGroup>
-</Project>
\ No newline at end of file



From twm at mail.berlios.de  Sun Dec 16 14:59:15 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 14:59:15 +0100
Subject: [Dzchart-svncheckins] r254 - in utilities/dzLib/trunk: src tests
	tests/dzconvertutils tests/dzfileutils
Message-ID: <200712161359.lBGDxFRO026489@sheep.berlios.de>

Author: twm
Date: 2007-12-16 14:59:07 +0100 (Sun, 16 Dec 2007)
New Revision: 254

Added:
   utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr
   utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj
   utilities/dzLib/trunk/tests/dcu/
   utilities/dzLib/trunk/tests/dzconvertutils/
   utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas
Removed:
   utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr
   utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj
   utilities/dzLib/trunk/tests/dzfileutils/dcu/
Modified:
   utilities/dzLib/trunk/src/u_dzConvertUtils.pas
   utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas
Log:
started a test unit for u_dzConvertUtils

Modified: utilities/dzLib/trunk/src/u_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-12-16 13:57:16 UTC (rev 253)
+++ utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-12-16 13:59:07 UTC (rev 254)
@@ -1,7 +1,9 @@
 {GXFormatter.config=twm}
-{: Integer to string and string to integer conversion functions for decimal
-   hexadecimal and custom number bases. This was taken from u_dzStringUtils
-   which originally was a Delphi conversion of TwmStringFunc. }
+/// <summary>
+/// Integer to string and string to integer conversion functions for decimal
+/// hexadecimal and custom number bases. This was taken from u_dzStringUtils
+/// which originally was a Delphi conversion of TwmStringFunc.
+/// </summary>
 unit u_dzConvertUtils;
 
 {$I jedi.inc}
@@ -12,15 +14,21 @@
   SysUtils;
 
 var
-  {: contains the User's format setting, but with decimal separator = '.' and no thousands separator }
+  /// <summary>
+  /// contains the User's format setting, but with decimal separator = '.' and no thousands separator
+  /// </summary>
   DZ_FORMAT_DECIMAL_POINT: TFormatSettings;
 
 type
-  {: Raised by the number conversion functions if a digit is invalid for the
-     given base. }
+  /// <summary>
+  /// Raised by the number conversion functions if a digit is invalid for the
+  /// given base.
+  /// </summary>
   EdzConvert = class(Exception);
   EDigitOutOfRange = class(EdzConvert);
-  {: raised if there is a conversion error in one of the Str2XxxEx functions }
+  /// <summary>
+  /// raised if there is a conversion error in one of the Str2XxxEx functions
+  /// </summary>
   EStringConvertError = class(EdzConvert);
 
 type
@@ -30,63 +38,105 @@
   TBaseN = 2..36;
 
 const
-  MinInt64 = $8000000000000000;
-  MaxInt64 = $7FFFFFFFFFFFFFFF;
+  MinInt64 = Int64($8000000000000000);
+  MaxInt64 = Int64($7FFFFFFFFFFFFFFF);
 
 const
-  {: String containing all characters that can be used as digits }
+  /// <summary>
+  /// String containing all characters that can be used as digits
+  /// </summary>
   DIGIT_CHARS: string[36] = '0123456789ABCDEFGHIJKlMNOPQRSTUVWXYZ';
 
 // Str <-> Decimal conversion
-{: Returns true if A is a valid decimal digit }
+/// <summary>
+/// Returns true if A is a valid decimal digit
+/// </summary>
 function isDecDigit(_a: char): boolean;
-{: Returns true if S is a valid decimal number }
+/// <summary>
+/// Returns true if S is a valid positive decimal number
+/// </summary>
 function isDec(const _s: string): boolean;
-{: Converts a decimal digit to its number equivalent
-   Raises EDigitOutOfRange if there is an invalid digit. }
+/// <summary>
+/// Converts a decimal digit to its number equivalent
+/// Raises EDigitOutOfRange if there is an invalid digit.
+/// </summary>
 function DecDigit2Long(_a: char): LongInt;
-{: Converts a string representing a decimal number to a number
-   Raises EDigitOutOfRange if there is an invalid digit. }
+/// <summary>
+/// Converts a string representing a positive decimal number to a number
+///   Raises EDigitOutOfRange if there is an invalid digit.
+/// </summary>
 function Dec2Long(const _s: string): ULong;
-{: Converts a number to its 2 digit decimal representation (left pads with '0') }
+/// <summary>
+/// Converts a positive number to its 2 digit decimal representation (left pads with '0')
+/// </summary>
 function Long2Dec2(_l: ULong): string;
-{: Converts a number to its 4 digit decimal representation (left pads with '0') }
+/// <summary>
+/// Converts a positive number to its 4 digit decimal representation (left pads with '0')
+/// </summary>
 function Long2Dec4(_l: ULong): string;
-{: Converts a number to its N digit decimal representation (left pads with '0') }
+/// <summary>
+/// Converts a positive number to its N digit decimal representation (left pads with '0')
+/// </summary>
 function Long2DecN(_l: ULong; _n: ULong): string;
-{: Converts a number to its decimal representation }
+/// <summary>
+/// Converts a positive number to its decimal representation
+/// </summary>
 function Long2Dec(_l: ULong): string;
 
 // Str <-> Hex conversion
-{: Returns true if A is a valid hexadecimal (base 16) digit }
+/// <summary>
+/// Returns true if A is a valid hexadecimal (base 16) digit 
+/// </summary>
 function isHexDigit(_a: char): boolean;
-{: Returns true if S is a valid hexadecimal (base 16) number }
+/// <summary>
+/// Returns true if S is a valid hexadecimal (base 16) number
+/// </summary>
 function isHex(const _s: string): boolean;
-{: Converts a hexadecimal digit to its number equivalent
-   Raises EDigitOutOfRange if there is an invalid digit. }
+/// <summary>
+/// Converts a hexadecimal digit to its number equivalent
+/// Raises EDigitOutOfRange if there is an invalid digit.
+/// </summary>
 function HexDigit2Long(_a: char): LongInt;
-{: Converts a string representing a hexadecimal number to a number
-   Raises EDigitOutOfRange if there is an invalid digit. }
+/// <summary>
+/// Converts a string representing a hexadecimal number to a number
+/// @Raises EDigitOutOfRange if there is an invalid digit. }
+/// </summary>
 function Hex2Long(const _s: string): ULong;
-{: Converts a number to its hexadecimal representation }
+/// <summary>
+/// Converts a number to its hexadecimal representation }
+/// </summary>
 function Long2Hex(_l: ULong): string;
-{: converts a number to its hexadecimal representation left padding with 0 to a length of 2 }
+/// <summary>
+/// converts a number to its hexadecimal representation left padding with 0 to a length of 2 }
+/// </summary>
 function Long2Hex2(_l: ULong): string;
 
 // Str <-> any numeric system conversion
-{: Returns true if A is a valid digit in the given Base. }
+/// <summary>
+/// Returns true if A is a valid digit in the given Base. }
+/// </summary>
 function isDigit(_a: char; _Base: TBaseN): boolean;
-{: Returns true if S is a valid number in the given Base. }
+/// <summary>
+/// Returns true if S is a valid number in the given Base. }
+/// </summary>
 function isNumber(const _s: string; _Base: TBaseN): boolean;
-{: Converts a Base digit to its number equivalent.
-   Raises EDigitOutOfRange if there is an invalid digit. }
+/// <summary>
+/// Converts a Base digit to its number equivalent.
+/// @Raises EDigitOutOfRange if there is an invalid digit. }
+/// </summary>
 function Digit2Long(_a: char; _Base: TBaseN): LongInt;
-{: Converts a string representing a number in Base to a number.
-   Raises EDigitOutOfRange if there is an invalid digit. }
+/// <summary>
+/// Converts a string representing a number in Base to a number.
+/// @Raises EDigitOutOfRange if there is an invalid digit. }
+/// </summary>
 function Num2Long(const _s: string; _Base: TBaseN): ULong;
-{: Converts a number to its Base representation. }
+/// <summary>
+/// Converts a number to its Base representation. }
+/// </summary>
 function Long2Num(_l: ULong; _Base: byte): string;
-{: Returns the number of characters in S that are valid digits in the given Base. }
+/// <summary>
+/// Returns the number of characters in S that are valid digits in the given Base. }
+/// </summary>
 function isNumberN(const _s: string; _Base: TBaseN): integer;
 
 function TimeStrToSeconds(const _Zeit: string): integer;
@@ -96,100 +146,119 @@
 function TimeToSeconds(_Zeit: TDateTime): integer; deprecated;
 {$ENDIF}
 
-{: Converts a string to an integer.
-   If s can not be converted, it returns the Default.
-   @param(s string to convert)
-   @param(Default value to return if s can not be converted)
-   @returns(the integer value of s or Default, if s can not be converted) }
-
+/// <summary>
+/// Converts a string to an integer.
+/// If s can not be converted, it returns the Default.
+/// @param(s string to convert)
+/// @param(Default value to return if s can not be converted)
+/// @returns(the integer value of s or Default, if s can not be converted) }
+/// </summary>
 function Str2Int(_s: string; _Default: integer): integer; overload;
 
-{: Converts a string to an integer.
-   If s can not be converted, it raises an exception EStringConvertError.
-   @param(s string to convert)
-   @param(Source string to include in the exception message)
-   @returns(the integer value of s)
-   @raises(EStringConvertError if s can not be converted) }
-
+/// <summary>
+/// Converts a string to an integer.
+/// If s can not be converted, it raises an exception EStringConvertError.
+/// @param(s string to convert)
+/// @param(Source string to include in the exception message)
+/// @returns(the integer value of s)
+/// @raises(EStringConvertError if s can not be converted) }
+/// </summary>
 function Str2Int(_s: string; const _Source: string): integer; overload;
 
-{: Converts a string to an int64.
-   If s can not be converted, it returns the Default.
-   @param(s string to convert)
-   @param(Default value to return if s can not be converted)
-   @returns(the int64 value of s or Default, if s can not be converted) }
-
+/// <summary>
+/// Converts a string to an int64.
+/// If s can not be converted, it returns the Default.
+/// @param(s string to convert)
+/// @param(Default value to return if s can not be converted)
+/// @returns(the int64 value of s or Default, if s can not be converted) }
+/// </summary>
 function Str2Int64(_s: string; _Default: Int64): Int64; overload;
 
-{: Converts a string to an int64.
-   If s can not be converted, it raises an exception EStringConvertError.
-   @param(s string to convert)
-   @param(Source string to include in the exception message)
-   @returns(the integer value of s)
-   @raises(EStringConvertError if s can not be converted) }
-
+/// <summary>
+/// Converts a string to an int64.
+/// If s can not be converted, it raises an exception EStringConvertError.
+/// @param(s string to convert)
+/// @param(Source string to include in the exception message)
+/// @returns(the integer value of s)
+/// @raises(EStringConvertError if s can not be converted) }
+/// </summary>
 function Str2Int64(_s: string; const _Source: string): Int64; overload;
 
-{: tries to guess the decimal separator }
+/// <summary>
+/// tries to guess the decimal separator }
+/// </summary>
 function GuessDecimalSeparator(const _s: string): char;
 
-{: Converts a string to a float.
-   If s can not be converted, it returns the Default.
-   @param s string to convert
-   @param Default value to return if s can not be converted
-   @param DecSeparator is the decimal separator, defaults to '.'
-          if passed as #0, GuessDecimalSeparator is called to guess it
-   @returns the float value of s or Default, if s can not be converted }
+/// <summary>
+/// Converts a string to a float.
+/// If s can not be converted, it returns the Default.
+/// @param s string to convert
+/// @param Default value to return if s can not be converted
+/// @param DecSeparator is the decimal separator, defaults to '.'
+///        if passed as #0, GuessDecimalSeparator is called to guess it
+/// @returns the float value of s or Default, if s can not be converted }
+/// </summary>
 function Str2Float(_s: string; _Default: extended; _DecSeparator: char = '.'): extended; overload;
 
-{: Converts a string to a float.
-   If s can not be converted, it raises an exception EStringConvertError.
-   @param(s string to convert)
-   @param(Source string to include in the exception message)
-   @param DecSeparator is the decimal separator, defaults to '.'
-          if passed as #0, GuessDecimalSeparator is called to guess it
-   @returns(the float value of s)
-   @raises(EStringConvertError if s can not be converted) }
-
+/// <summary>
+/// Converts a string to a float.
+/// If s can not be converted, it raises an exception EStringConvertError.
+/// @param(s string to convert)
+/// @param(Source string to include in the exception message)
+/// @param DecSeparator is the decimal separator, defaults to '.'
+///        if passed as #0, GuessDecimalSeparator is called to guess it
+/// @returns(the float value of s)
+/// @raises(EStringConvertError if s can not be converted) }
+/// </summary>
 function Str2Float(_s: string; const _Source: string; _DecSeparator: char = '.'): extended; overload;
 
-{: tries to convert a string to a float, returns false if it fails
-   @param s is the string to convert
-   @param flt is the float, only valid if the function returns true
-   @param DecSeparator is the decimal separator to use, defaults to '.',
-          if passed as #0, GuessDecimalSeparator is called to guess it
-   @returns true, if s could be converted, false otherwise }
+/// <summary>
+/// tries to convert a string to a float, returns false if it fails
+/// @param s is the string to convert
+/// @param flt is the float, only valid if the function returns true
+/// @param DecSeparator is the decimal separator to use, defaults to '.',
+///        if passed as #0, GuessDecimalSeparator is called to guess it
+/// @returns true, if s could be converted, false otherwise }
+/// </summary>
 function TryStr2Float(_s: string; out _flt: extended; _DecSeparator: char = '.'): boolean; overload;
 function TryStr2Float(_s: string; out _flt: double; _DecSeparator: char = '.'): boolean; overload;
 
-{: Converts a floating point number to a string using the given decimal separator
-   in "General number format" with 15 significant digits
-   @param(flt is an extended floating point value)
-   @param(DecSeparator is the decimal separator to use)
-   @returns(a string representation of the floating point value) }
+/// <summary>
+/// Converts a floating point number to a string using the given decimal separator
+/// in "General number format" with 15 significant digits
+/// @param(flt is an extended floating point value)
+/// @param(DecSeparator is the decimal separator to use)
+/// @returns(a string representation of the floating point value) }
+/// </summary>
 function Float2Str(_flt: extended; _DecSeparator: char = '.'): string; overload;
 
-{: Converts a floating point number to a string using the given with, number of decimals
-   and a '.' as decimal separator, if width is too small the smallest representation possible
-   will be used (eg. Float2Str(5.24, 3, 2, '.') = '5.24')
-   @param flt is an extended floating point value
-   @param Width is the total number of digits (including the decimal separator
-   @param Decimals is the number of decimals to use
-   @returns a string representation of the floating point value }
+/// <summary>
+/// Converts a floating point number to a string using the given with, number of decimals
+/// and a '.' as decimal separator, if width is too small the smallest representation possible
+/// will be used (eg. Float2Str(5.24, 3, 2, '.') = '5.24')
+/// @param flt is an extended floating point value
+/// @param Width is the total number of digits (including the decimal separator
+/// @param Decimals is the number of decimals to use
+/// @returns a string representation of the floating point value }
+/// </summary>
 function Float2Str(_flt: extended; _Width, _Decimals: integer): string; overload;
 
-{: Converts a floating point number to a string using the given number of decimals
-   and a '.' as decimal separator.
-   @param flt is an extended floating point value
-   @param Decimals is the number of decimals to use
-   @returns a string representation of the floating point value }
+/// <summary>
+/// Converts a floating point number to a string using the given number of decimals
+/// and a '.' as decimal separator.
+/// @param flt is an extended floating point value
+/// @param Decimals is the number of decimals to use
+/// @returns a string representation of the floating point value }
+/// </summary>
 function Float2Str(_flt: extended; _Decimals: integer): string; overload;
 
 function TryRound(_flt: extended; out _wrd: word): boolean;
 
-// these contants refer to the "Xx binary byte" units as defined by the
-// International Electronical Commission (IEC) and endorsed by the
-// IEE and CiPM
+/// <summary>
+/// these contants refer to the "Xx binary byte" units as defined by the
+/// International Electronical Commission (IEC) and endorsed by the
+/// IEE and CiPM
+/// </summary>
 const
   OneKibiByte = Int64(1024);
   OneMebiByte = Int64(1024) * OneKibiByte;
@@ -198,7 +267,9 @@
   OnePebiByte = Int64(1024) * OneTebiByte;
   OneExbiByte = Int64(1024) * OnePebiByte;
 
-{: Converts a file size to a human readable string, e.g. 536870912000 = 5.00 GiB (gibibyte) }
+/// <summary>
+/// Converts a file size to a human readable string, e.g. 536870912000 = 5.00 GiB (gibibyte) }
+/// </summary>
 function FileSizeToHumanReadableString(_FileSize: Int64): string;
 
 const
@@ -209,10 +280,14 @@
   MinutesPerDay = HoursPerDay * MinutesPerHour;
   SecondsPerDay = MinutesPerDay * SecondsPerMinute;
 
-{: returns a human readable string of the form '5d 23h' or '25h 15m' or '20m 21s' }
+/// <summary>
+/// returns a human readable string of the form '5d 23h' or '25h 15m' or '20m 21s' }
+/// </summary>
 function SecondsToHumanReadableString(_Seconds: Int64): string;
 
-{: returns the default locale settings as read from the system's regional settings }
+/// <summary>
+/// returns the default locale settings as read from the system's regional settings }
+/// </summary>
 function GetUserDefaultLocaleSettings: TFormatSettings;
 function GetSystemDefaultLocaleSettings: TFormatSettings;
 
@@ -586,13 +661,17 @@
 function SecondsToHumanReadableString(_Seconds: Int64): string;
 begin
   if _Seconds > SecondsPerDay then
-    Result := Format('%dd %dh', [_Seconds div SecondsPerDay, (_Seconds div SecondsPerHour) mod HoursPerDay])
+    // Days and hours, ignore minutes and seconds
+    Result := Format(_('%dd %dh'), [_Seconds div SecondsPerDay, (_Seconds div SecondsPerHour) mod HoursPerDay])
   else if _Seconds > Round(1.5 * SecondsPerHour) then
-    Result := Format('%dh %dm', [_Seconds div SecondsPerHour, (_Seconds div SecondsPerMinute) mod MinutesPerHour])
+    // Hours and minutes, ignore seconds
+    Result := Format(_('%dh %dm'), [_Seconds div SecondsPerHour, (_Seconds div SecondsPerMinute) mod MinutesPerHour])
   else if _Seconds > Round(1.5 * SecondsPerMinute) then
-    Result := Format('%dm %ds', [_Seconds div SecondsPerMinute, _Seconds mod SecondsPerMinute])
+    // Minutes and seconds
+    Result := Format(_('%dm %ds'), [_Seconds div SecondsPerMinute, _Seconds mod SecondsPerMinute])
   else
-    Result := Format('%ds', [_Seconds]);
+    // Seconds only
+    Result := Format(_('%ds'), [_Seconds]);
 end;
 
 function GetSystemDefaultLocaleSettings: TFormatSettings;

Modified: utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas	2007-12-16 13:57:16 UTC (rev 253)
+++ utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas	2007-12-16 13:59:07 UTC (rev 254)
@@ -1,3 +1,6 @@
+/// <summary>
+/// implements an extended TTextCase class
+/// </summary>
 unit u_dzUnitTestUtils;
 
 interface
@@ -9,39 +12,71 @@
 
 {$M+}
 type
-  {: implements some additional CheckXxx procedures, for now mainly for checking variants }
+  /// <summary>
+  /// implements some additional CheckXxx procedures
+  /// </summary>
   TdzTestCase = class(TTestcase)
   protected
   public
-    {: Checks whether the value is a variant of a floating point type (includes integer) }
+    /// <summary>
+    /// Checks whether the value is a variant of a floating point type (includes integer)
+    /// </summary>
     procedure CheckVariantIsFloat(_Value: variant; _Msg: string);
-    {: Checks whether the value is a variant of an (signed) integer type (excludes LongWord and Int64) }
+    /// <summary>
+    /// Checks whether the value is a variant of an (signed) integer type (excludes LongWord and Int64)
+    /// </summary>
     procedure CheckVariantIsInteger(_Value: variant; _Msg: string);
-    {: Checks whether the value is a variant of an (signed) int64 type (includes LongWord and Int64) }
+    /// <summary>
+    /// Checks whether the value is a variant of an (signed) int64 type (includes LongWord and Int64)
+    /// </summary>
     procedure CheckVariantIsInt64(_Value: variant; _Msg: string);
-    {: Checks whether the value is a variant of an (unsigned) integer type (excludes all signed integer types) }
+    /// <summary>
+    /// Checks whether the value is a variant of an (unsigned) integer type (excludes all signed integer types)
+    /// </summary>
     procedure CheckVariantIsLongWord(_Value: variant; _Msg: string);
-    {: Checks whether the value is a non Null variant }
+    /// <summary>
+    /// Checks whether the value is a non Null variant
+    /// </summary>
     procedure CheckVariantIsNotNull(_Value: variant; _Msg: string); overload;
-    {: Checks whether the value is a Null variant }
+    /// <summary>
+    /// Checks whether the value is a Null variant
+    /// </summary>
     procedure CheckVariantIsNull(_Value: variant; _Msg: string); overload;
-    {: Checks whether the value is a variant of a string type }
+    /// <summary>
+    /// Checks whether the value is a variant of a string type
+    /// </summary>
     procedure CheckVariantIsString(_Value: variant; _Msg: string); overload;
-    {: Called by the CheckVAriantIsXxxx functions to show errors }
+    /// <summary>
+    /// Called by the CheckVAriantIsXxxx functions to show errors
+    /// </summary>
     procedure FailNotVarType(const _Expected, _Actual, _Msg: string; _ErrorAddr: pointer);
-    {: Called by the FailNotVarType function to generate the error message }
+    /// <summary>
+    /// Called by the FailNotVarType function to generate the error message
+    /// </summary>
     function NotVarTypeErrorMessage(const _Expected: string; const _Actual: string; _Msg: string): string;
-    {: Checks whether the date part of two TDateTime values is equal }
+    /// <summary>
+    /// Checks whether the date part of two TDateTime values is equal
+    /// </summary>
     procedure CheckEqualsDate(_Expected, _Actual: TDateTime; const _Message: string);
-    {: Checks whether two TDateTime values are equal }
+    /// <summary>
+    /// Checks whether two TDateTime values are equal
+    /// </summary>
     procedure CheckEqualsDateTime(_Expected, _Actual: TDateTime; const _Message: string);
-    {: Checks whether the time part of two TDateTime values is equal }
+    /// <summary>
+    /// Checks whether the time part of two TDateTime values is equal
+    /// </summary>
     procedure CheckEqualsTime(_Expected, _Actual: TDateTime; const _Message: string);
-    {: Checks multiline strings for equality }
+    /// <summary>
+    /// Checks multiline strings for equality
+    /// </summary>
     procedure CheckEqualsMultiline(_Expected, _Actual: string; const _Message: string = '');
-    {: Checks a multiline string against the content of a file }
+    /// <summary>
+    /// Checks a multiline string against the content of a file
+    /// </summary>
     procedure CheckEqualsFile(const _Filename: string; _Actual: string; const _Message: string = '');
-    {: checks whether two files have got the same contents, content is treated as a multiline string }
+    /// <summary>
+    /// checks whether two files have got the same contents, content is treated as a multiline string
+    /// </summary>
     procedure CheckEqualsFiles(const _ExpectedFile, _ActualFile: string; const _Message: string = '');
   end;
 

Deleted: utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr	2007-12-16 13:57:16 UTC (rev 253)
+++ utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr	2007-12-16 13:59:07 UTC (rev 254)
@@ -1,41 +0,0 @@
-program DUnitTest_dzFileUtils;
-{
-
-  Delphi DUnit Test Project
-  -------------------------
-  This project contains the DUnit test framework and the GUI/Console test runners.
-  Add "CONSOLE_TESTRUNNER" to the conditional defines entry in the project options 
-  to use the console test runner.  Otherwise the GUI test runner will be used by 
-  default.
-
-}
-
-{$IFDEF CONSOLE_TESTRUNNER}
-{$APPTYPE CONSOLE}
-{$ENDIF}
-
-uses
-  Forms,
-  TestFramework,
-  GUITestRunner,
-  TextTestRunner,
-  u_dzFileUtils in '..\..\src\u_dzFileUtils.pas',
-  Testu_dzFileUtils in 'Testu_dzFileUtils.pas',
-  u_dzMiscUtils in '..\..\src\u_dzMiscUtils.pas',
-  u_dzStringUtils in '..\..\src\u_dzStringUtils.pas',
-  u_dzConvertUtils in '..\..\src\u_dzConvertUtils.pas',
-  u_dzTranslator in '..\..\src\u_dzTranslator.pas',
-  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas',
-  u_dzUnitTestUtils in '..\..\src\u_dzUnitTestUtils.pas',
-  u_dzVariantUtils in '..\..\src\u_dzVariantUtils.pas';
-
-{$R *.RES}
-
-begin
-  Application.Initialize;
-  if IsConsole then
-    TextTestRunner.RunRegisteredTests
-  else
-    GUITestRunner.RunRegisteredTests;
-end.
-

Deleted: utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj	2007-12-16 13:57:16 UTC (rev 253)
+++ utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj	2007-12-16 13:59:07 UTC (rev 254)
@@ -1,54 +0,0 @@
-?<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <ProjectGuid>{9732bdc0-39a6-4dbb-817c-3fb77772e288}</ProjectGuid>
-    <MainSource>DUnitTest_dzFileUtils.dpr</MainSource>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <DCC_DCCCompiler>DCC32</DCC_DCCCompiler>
-    <DCC_DependencyCheckOutputName>DUnitTest_dzFileUtils.exe</DCC_DependencyCheckOutputName>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <Version>7.0</Version>
-    <DCC_DebugInformation>False</DCC_DebugInformation>
-    <DCC_LocalDebugSymbols>False</DCC_LocalDebugSymbols>
-    <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
-    <DCC_Define>RELEASE</DCC_Define>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <Version>7.0</Version>
-    <DCC_Define>DEBUG;_CONSOLE_TESTRUNNER;no_translation</DCC_Define>
-    <DCC_UnitSearchPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_UnitSearchPath>
-    <DCC_ResourcePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_ResourcePath>
-    <DCC_ObjPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_ObjPath>
-    <DCC_IncludePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_IncludePath>
-    <DCC_DcuOutput>dcu</DCC_DcuOutput>
-    <DCC_ObjOutput>dcu</DCC_ObjOutput>
-    <DCC_HppOutput>dcu</DCC_HppOutput>
-    <DCC_SYMBOL_PLATFORM>False</DCC_SYMBOL_PLATFORM>
-    <DCC_UNIT_PLATFORM>False</DCC_UNIT_PLATFORM>
-    <DCC_Optimize>False</DCC_Optimize>
-    <DCC_IntegerOverflowCheck>True</DCC_IntegerOverflowCheck>
-    <DCC_RangeChecking>True</DCC_RangeChecking>
-  </PropertyGroup>
-  <ProjectExtensions>
-    <Borland.Personality>Delphi.Personality</Borland.Personality>
-    <Borland.ProjectType />
-    <BorlandProject>
-<BorlandProject><Delphi.Personality><Parameters><Parameters Name="UseLauncher">False</Parameters><Parameters Name="LoadAllSymbols">True</Parameters><Parameters Name="LoadUnspecifiedSymbols">False</Parameters></Parameters><VersionInfo><VersionInfo Name="IncludeVerInfo">False</VersionInfo><VersionInfo Name="AutoIncBuild">False</VersionInfo><VersionInfo Name="MajorVer">1</VersionInfo><VersionInfo Name="MinorVer">0</VersionInfo><VersionInfo Name="Release">0</VersionInfo><VersionInfo Name="Build">0</VersionInfo><VersionInfo Name="Debug">False</VersionInfo><VersionInfo Name="PreRelease">False</VersionInfo><VersionInfo Name="Special">False</VersionInfo><VersionInfo Name="Private">False</VersionInfo><VersionInfo Name="DLL">False</VersionInfo><VersionInfo Name="Locale">1033</VersionInfo><VersionInfo Name="CodePage">1252</VersionInfo></VersionInfo><VersionInfoKeys><VersionInfoKeys Name="CompanyName"></VersionInfoKeys><VersionInfoKeys Name="FileDescription"></VersionInfoKeys><VersionI!
 nfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="InternalName"></VersionInfoKeys><VersionInfoKeys Name="LegalCopyright"></VersionInfoKeys><VersionInfoKeys Name="LegalTrademarks"></VersionInfoKeys><VersionInfoKeys Name="OriginalFilename"></VersionInfoKeys><VersionInfoKeys Name="ProductName"></VersionInfoKeys><VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="Comments"></VersionInfoKeys></VersionInfoKeys><Source><Source Name="MainSource">DUnitTest_dzFileUtils.dpr</Source></Source></Delphi.Personality><UnitTesting><TestFramework>DUnit / Delphi Win32</TestFramework><TestRunner>GUI</TestRunner></UnitTesting></BorlandProject></BorlandProject>
-  </ProjectExtensions>
-  <Import Project="$(MSBuildBinPath)\Borland.Delphi.Targets" />
-  <ItemGroup>
-    <DelphiCompile Include="DUnitTest_dzFileUtils.dpr">
-      <MainSource>MainSource</MainSource>
-    </DelphiCompile>
-    <DCCReference Include="..\..\src\u_dzConvertUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzDateUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzFileUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzMiscUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzStringUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzTranslator.pas" />
-    <DCCReference Include="..\..\src\u_dzUnitTestUtils.pas" />
-    <DCCReference Include="..\..\src\u_dzVariantUtils.pas" />
-    <DCCReference Include="Testu_dzFileUtils.pas" />
-  </ItemGroup>
-</Project>
\ No newline at end of file

Copied: utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr (from rev 253, utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr)
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dpr	2007-12-16 13:57:16 UTC (rev 253)
+++ utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr	2007-12-16 13:59:07 UTC (rev 254)
@@ -0,0 +1,42 @@
+program DUnitTests_dzLib;
+{
+
+  Delphi DUnit Test Project
+  -------------------------
+  This project contains the DUnit test framework and the GUI/Console test runners.
+  Add "CONSOLE_TESTRUNNER" to the conditional defines entry in the project options 
+  to use the console test runner.  Otherwise the GUI test runner will be used by 
+  default.
+
+}
+
+{$IFDEF CONSOLE_TESTRUNNER}
+{$APPTYPE CONSOLE}
+{$ENDIF}
+
+uses
+  Forms,
+  TestFramework,
+  GUITestRunner,
+  TextTestRunner,
+  u_dzFileUtils in '..\src\u_dzFileUtils.pas',
+  Testu_dzFileUtils in 'dzfileutils\Testu_dzFileUtils.pas',
+  u_dzMiscUtils in '..\src\u_dzMiscUtils.pas',
+  u_dzStringUtils in '..\src\u_dzStringUtils.pas',
+  u_dzConvertUtils in '..\src\u_dzConvertUtils.pas',
+  u_dzTranslator in '..\src\u_dzTranslator.pas',
+  u_dzDateUtils in '..\src\u_dzDateUtils.pas',
+  u_dzUnitTestUtils in '..\src\u_dzUnitTestUtils.pas',
+  u_dzVariantUtils in '..\src\u_dzVariantUtils.pas',
+  Testu_dzConvertUtils in 'dzconvertutils\Testu_dzConvertUtils.pas';
+
+{$R *.RES}
+
+begin
+  Application.Initialize;
+  if IsConsole then
+    TextTestRunner.RunRegisteredTests
+  else
+    GUITestRunner.RunRegisteredTests;
+end.
+

Copied: utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj (from rev 253, utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj)
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTest_dzFileUtils.dproj	2007-12-16 13:57:16 UTC (rev 253)
+++ utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj	2007-12-16 13:59:07 UTC (rev 254)
@@ -0,0 +1,55 @@
+?<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <ProjectGuid>{9732bdc0-39a6-4dbb-817c-3fb77772e288}</ProjectGuid>
+    <MainSource>DUnitTests_dzLib.dpr</MainSource>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <DCC_DCCCompiler>DCC32</DCC_DCCCompiler>
+    <DCC_DependencyCheckOutputName>DUnitTests_dzLib.exe</DCC_DependencyCheckOutputName>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <Version>7.0</Version>
+    <DCC_DebugInformation>False</DCC_DebugInformation>
+    <DCC_LocalDebugSymbols>False</DCC_LocalDebugSymbols>
+    <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
+    <DCC_Define>RELEASE</DCC_Define>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <Version>7.0</Version>
+    <DCC_Define>DEBUG;_CONSOLE_TESTRUNNER;no_translation</DCC_Define>
+    <DCC_UnitSearchPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_UnitSearchPath>
+    <DCC_ResourcePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_ResourcePath>
+    <DCC_ObjPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_ObjPath>
+    <DCC_IncludePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_IncludePath>
+    <DCC_DcuOutput>dcu</DCC_DcuOutput>
+    <DCC_ObjOutput>dcu</DCC_ObjOutput>
+    <DCC_HppOutput>dcu</DCC_HppOutput>
+    <DCC_SYMBOL_PLATFORM>False</DCC_SYMBOL_PLATFORM>
+    <DCC_UNIT_PLATFORM>False</DCC_UNIT_PLATFORM>
+    <DCC_Optimize>False</DCC_Optimize>
+    <DCC_IntegerOverflowCheck>True</DCC_IntegerOverflowCheck>
+    <DCC_RangeChecking>True</DCC_RangeChecking>
+  </PropertyGroup>
+  <ProjectExtensions>
+    <Borland.Personality>Delphi.Personality</Borland.Personality>
+    <Borland.ProjectType />
+    <BorlandProject>
+<BorlandProject><Delphi.Personality><Parameters><Parameters Name="UseLauncher">False</Parameters><Parameters Name="LoadAllSymbols">True</Parameters><Parameters Name="LoadUnspecifiedSymbols">False</Parameters></Parameters><VersionInfo><VersionInfo Name="IncludeVerInfo">False</VersionInfo><VersionInfo Name="AutoIncBuild">False</VersionInfo><VersionInfo Name="MajorVer">1</VersionInfo><VersionInfo Name="MinorVer">0</VersionInfo><VersionInfo Name="Release">0</VersionInfo><VersionInfo Name="Build">0</VersionInfo><VersionInfo Name="Debug">False</VersionInfo><VersionInfo Name="PreRelease">False</VersionInfo><VersionInfo Name="Special">False</VersionInfo><VersionInfo Name="Private">False</VersionInfo><VersionInfo Name="DLL">False</VersionInfo><VersionInfo Name="Locale">1033</VersionInfo><VersionInfo Name="CodePage">1252</VersionInfo></VersionInfo><VersionInfoKeys><VersionInfoKeys Name="CompanyName"></VersionInfoKeys><VersionInfoKeys Name="FileDescription"></VersionInfoKeys><VersionI!
 nfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="InternalName"></VersionInfoKeys><VersionInfoKeys Name="LegalCopyright"></VersionInfoKeys><VersionInfoKeys Name="LegalTrademarks"></VersionInfoKeys><VersionInfoKeys Name="OriginalFilename"></VersionInfoKeys><VersionInfoKeys Name="ProductName"></VersionInfoKeys><VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="Comments"></VersionInfoKeys></VersionInfoKeys><Source><Source Name="MainSource">DUnitTests_dzLib.dpr</Source></Source></Delphi.Personality><UnitTesting><TestFramework>DUnit / Delphi Win32</TestFramework><TestRunner>GUI</TestRunner></UnitTesting></BorlandProject></BorlandProject>
+  </ProjectExtensions>
+  <Import Project="$(MSBuildBinPath)\Borland.Delphi.Targets" />
+  <ItemGroup>
+    <DelphiCompile Include="DUnitTests_dzLib.dpr">
+      <MainSource>MainSource</MainSource>
+    </DelphiCompile>
+    <DCCReference Include="..\src\u_dzConvertUtils.pas" />
+    <DCCReference Include="..\src\u_dzDateUtils.pas" />
+    <DCCReference Include="..\src\u_dzFileUtils.pas" />
+    <DCCReference Include="..\src\u_dzMiscUtils.pas" />
+    <DCCReference Include="..\src\u_dzStringUtils.pas" />
+    <DCCReference Include="..\src\u_dzTranslator.pas" />
+    <DCCReference Include="..\src\u_dzUnitTestUtils.pas" />
+    <DCCReference Include="..\src\u_dzVariantUtils.pas" />
+    <DCCReference Include="dzconvertutils\Testu_dzConvertUtils.pas" />
+    <DCCReference Include="dzfileutils\Testu_dzFileUtils.pas" />
+  </ItemGroup>
+</Project>
\ No newline at end of file

Added: utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas	2007-12-16 13:57:16 UTC (rev 253)
+++ utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas	2007-12-16 13:59:07 UTC (rev 254)
@@ -0,0 +1,105 @@
+unit Testu_dzConvertUtils;
+
+interface
+
+uses
+  Windows,
+  Classes,
+  SysUtils,
+  TestFramework,
+  u_dzConvertUtils,
+  u_dzUnitTestUtils;
+
+type
+  TestDecimalConversion = class(TdzTestCase)
+  protected
+    FDecDigit2LongOutOfRangeValue: char;
+    procedure DecDigit2LongOutOfRange;
+  published
+    procedure TestIsDecDigit;
+    procedure TestisDec(const _s: string);
+    procedure TestDecDigit2Long(_a: char);
+    procedure TestDec2Long(const _s: string);
+    procedure TestLong2Dec2(_l: ULong);
+    procedure TestLong2Dec4(_l: ULong);
+    procedure TestLong2DecN(_l: ULong; _n: ULong);
+    procedure TestLong2Dec(_l: ULong);
+  end;
+
+implementation
+
+{ TestDecimalConversion }
+
+procedure TestDecimalConversion.TestDec2Long(const _s: string);
+begin
+end;
+
+procedure TestDecimalConversion.DecDigit2LongOutOfRange;
+begin
+  CheckEquals(0, DecDigit2Long(FDecDigit2LongOutOfRangeValue));
+end;
+
+procedure TestDecimalConversion.TestDecDigit2Long(_a: char);
+var
+  c: char;
+begin
+  for c := chr(0) to chr(255) do begin
+    if c in ['0'..'9'] then
+      CheckEquals(Ord(c) - Ord('0'), DecDigit2Long(c))
+    else begin
+      FDecDigit2LongOutOfRangeValue := c;
+      CheckException(DecDigit2LongOutOfRange, EDigitOutOfRange);
+    end;
+  end;
+end;
+
+procedure TestDecimalConversion.TestisDec(const _s: string);
+begin
+  CheckTrue(isDec('0'));
+  CheckTrue(isDec('1'));
+  CheckTrue(isDec('12'));
+  CheckTrue(isDec('18945'));
+  CheckTrue(isDec('0845'));
+  CheckTrue(isDec('000000'));
+  CheckTrue(isDec('90894514908'));
+  CheckFalse(isDec('a'));
+  CheckFalse(isDec('1a425'));
+  CheckFalse(isDec('-2345'));
+  CheckFalse(isDec('0000001a'));
+end;
+
+procedure TestDecimalConversion.TestIsDecDigit;
+var
+  c: char;
+begin
+  for c := chr(0) to chr(255) do
+    if c in ['0'..'9'] then
+      CheckTrue(isDecDigit(c))
+    else
+      CheckFalse(isDecDigit(c));
+end;
+
+procedure TestDecimalConversion.TestLong2Dec(_l: ULong);
+begin
+
+end;
+
+procedure TestDecimalConversion.TestLong2Dec2(_l: ULong);
+begin
+
+end;
+
+procedure TestDecimalConversion.TestLong2Dec4(_l: ULong);
+begin
+
+end;
+
+procedure TestDecimalConversion.TestLong2DecN(_l, _n: ULong);
+begin
+
+end;
+
+initialization
+  RegisterTest(TestDecimalConversion.Suite);
+end.
+



From twm at mail.berlios.de  Sun Dec 16 15:02:58 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 15:02:58 +0100
Subject: [Dzchart-svncheckins] r255 - utilities/dzLib/trunk/tests/dzfileutils
Message-ID: <200712161402.lBGE2wNl026684@sheep.berlios.de>

Author: twm
Date: 2007-12-16 15:02:55 +0100 (Sun, 16 Dec 2007)
New Revision: 255

Removed:
   utilities/dzLib/trunk/tests/dzfileutils/testdata/
Log:
testdata directory no longer needed



From twm at mail.berlios.de  Sun Dec 16 16:06:23 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 16:06:23 +0100
Subject: [Dzchart-svncheckins] r256 - utilities/dzLib/trunk
Message-ID: <200712161506.lBGF6NfT031862@sheep.berlios.de>

Author: twm
Date: 2007-12-16 16:06:17 +0100 (Sun, 16 Dec 2007)
New Revision: 256

Modified:
   utilities/dzLib/trunk/default_de.po
Log:
added "translations" for time formatting

Modified: utilities/dzLib/trunk/default_de.po
===================================================================
--- utilities/dzLib/trunk/default_de.po	2007-12-16 14:02:55 UTC (rev 255)
+++ utilities/dzLib/trunk/default_de.po	2007-12-16 15:06:17 UTC (rev 256)
@@ -6,9 +6,9 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: dzLib 1.0\n"
-"POT-Creation-Date: 2007-07-18 15:13\n"
-"PO-Revision-Date: 2007-07-18 15:14+0100\n"
-"Last-Translator: Schniering Ingenieursgesellschaft <info at schniering.com>\n"
+"POT-Creation-Date: 2007-12-16 15:56\n"
+"PO-Revision-Date: 2007-12-16 16:04+0100\n"
+"Last-Translator: twm <nospam at dummzeuch.de>\n"
 "Language-Team: Thomas Mueller <dzlib at dummzeuch.de>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -19,136 +19,140 @@
 
 #. "%s" ist kein g?ltiger Flie?komma Wert: %s
 #. Programmer's name for it: STR_X_IS_NOT_A_VALID_FLOAT_VALUE_SS
-#: u_dzConvertUtils.pas:223
+#: u_dzConvertUtils.pas:305
 msgid "\"%s\" is not a valid floating point value: %s"
 msgstr "\"%s\" ist kein g?ltiger Flie?kommawert: %s"
 
 #. "%s" ist kein g?ltiger %s Wert: %s
 #. Programmer's name for it: STR_X_IS_NOT_A_VALID_Y_VALUE_SSS
-#: u_dzConvertUtils.pas:225
+#: u_dzConvertUtils.pas:307
 msgid "\"%s\" is not a valid %s value: %s"
 msgstr "\"%s\" ist kein g?ltiger %s Wert: %s"
 
-#: u_dzConvertUtils.pas:256
+#: u_dzConvertUtils.pas:338
 msgid "Digit out of range %s"
 msgstr "ung?ltige Ziffer %s"
 
-#: u_dzConvertUtils.pas:269
+#: u_dzConvertUtils.pas:351
 msgid "Digit #%d (%s) out of range"
 msgstr "Ung?ltige Ziffer #%d (%s)"
 
-#: u_dzConvertUtils.pas:553
+#: u_dzConvertUtils.pas:646
 msgid "%.2f EiB"
 msgstr "%.2f EiB"
 
-#: u_dzConvertUtils.pas:555
+#: u_dzConvertUtils.pas:648
 msgid "%.2f PiB"
 msgstr "%.2f PiB"
 
-#: u_dzConvertUtils.pas:557
+#: u_dzConvertUtils.pas:650
 msgid "%.2f TiB"
 msgstr "%.2f TiB"
 
-#: u_dzConvertUtils.pas:559
+#: u_dzConvertUtils.pas:652
 msgid "%.2f GiB"
 msgstr "%.2f GiB"
 
-#: u_dzConvertUtils.pas:561
+#: u_dzConvertUtils.pas:654
 msgid "%.2f MiB"
 msgstr "%.2f MiB"
 
-#: u_dzConvertUtils.pas:563
+#: u_dzConvertUtils.pas:656
 msgid "%.2f KiB"
 msgstr "%.2f KiB"
 
-#: u_dzConvertUtils.pas:565
+#: u_dzConvertUtils.pas:658
 msgid "%d Bytes"
 msgstr "%d Bytes"
 
-#: u_dzDefaultMain.pas:115
-msgid "Error: %s"
-msgstr "Fehler: %s"
+#. Days and hours, ignore minutes and seconds
+#: u_dzConvertUtils.pas:665
+msgid "%dd %dh"
+msgstr "%dd %dh"
 
-#: u_dzDefaultMain.pas:119
-msgid "Synopsis: %s %s"
-msgstr "Aufruf: %s %s"
+#. Hours and minutes, ignore seconds
+#: u_dzConvertUtils.pas:668
+msgid "%dh %dm"
+msgstr "%dh %dm"
 
-#: u_dzDefaultMain.pas:120
-msgid "Parameters:"
-msgstr "Parameter:"
+#. Minutes and seconds
+#: u_dzConvertUtils.pas:671
+msgid "%dm %ds"
+msgstr "%dm %ds"
 
-#: u_dzDefaultMain.pas:122
-msgid "Options:"
-msgstr "Optionen:"
+#. Seconds only
+#: u_dzConvertUtils.pas:674
+msgid "%ds"
+msgstr "%ds"
 
 #. Programmer's name for it: STR_GETTEMPPATH_ERROR_DS
-#: u_dzFileUtils.pas:458
+#: u_dzFileUtils.pas:606
 msgid "u_dzFileUtils.GetTempPath: %1:s (code: %0:d) calling Windows.GetTempPath"
 msgstr "u_dzFileUtils.GetTempPath: %1:s (code: %0:d) beim Aufruf von Windows.GetTempPath"
 
 #. Programmer's name for it: STR_GETTEMPPATH_ERROR2_DS
-#: u_dzFileUtils.pas:459
+#: u_dzFileUtils.pas:607
 msgid "u_dzFileUtils.GetTempPath: %1:s (code: %0:d) calling Windows.GetTempPath (2nd)"
 msgstr "u_dzFileUtils.GetTempPath: %1:s (code: %0:d) beim Aufruf von Windows.GetTempPath (zweiter)"
 
 #. Programmer's name for it: STR_CREATEUNIQUEDIR_ERROR_S
-#: u_dzFileUtils.pas:460
+#: u_dzFileUtils.pas:608
 msgid "could not find a unique directory name based on \"%s\""
 msgstr "Konnte keinen eindeutigen Verzeichnisnamen basierend auf \"%s\" finden."
 
 #. Programmer's name for it: STR_GETTEMPFILENAME_ERROR_DS
-#: u_dzFileUtils.pas:461
+#: u_dzFileUtils.pas:609
 msgid "u_dzFileUtils.GetTempFilename: %1:s (Code: %0:d) calling Windows.GetTempFileName"
 msgstr "u_dzFileUtils.GetTempFilename: %1:s (Code: %0:d) beim Aufruf von Windows.GetTempFileName"
 
 #. Programmer's name for it: STR_GETSHORTPATHNAME_ERROR_DS
-#: u_dzFileUtils.pas:462
+#: u_dzFileUtils.pas:610
 msgid "u_dzFileUtils.GetShortPathname: %1:s (Code: %0:d) calling Windows.GetShortPathname"
 msgstr "u_dzFileUtils.GetShortPathname: %1:s (Code: %0:d) beim Aufruf von Windows.GetShortPathname"
 
 #. Programmer's name for it: STR_GETSHORTPATHNAME_TOO_LONG_D
-#: u_dzFileUtils.pas:463
+#: u_dzFileUtils.pas:611
 msgid "Short pathname is longer than MAX_PATH (%d) characters"
 msgstr "Kurzer Pfad ist l?nger als MAX_PATH (%d) Zeichen"
 
-#. doppelte % zum Durchreichen in Prozedur
+#. duplicate % so they get passed through the format function
 #. Programmer's name for it: STR_MOVEFILE_ERROR_SS
-#: u_dzFileUtils.pas:465
+#: u_dzFileUtils.pas:613
 msgid "Error %%1:s (%%0:d) while trying to move \"%s\" to \"%s\"."
 msgstr "Fehler %%1:s (%%0:d) beim Verschieben von \"%s\" nach \"%s\"."
 
-#. doppelte % zum Durchreichen in Prozedur
+#. duplicate % so they get passed through the format function
 #. Programmer's name for it: STR_SETREADONLY_ERROR_S
-#: u_dzFileUtils.pas:467
+#: u_dzFileUtils.pas:615
 msgid "Error %%1:s (%%0:d) while changing the readonly flag of \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim ?ndern des Schreibschutz-Flags von \"%s\""
 
-#. doppelte % zum Durchreichen in Prozedur
+#. duplicate % so they get passed through the format function
 #. Programmer's name for it: STR_COPYFILE_ERROR_SS
-#: u_dzFileUtils.pas:469
+#: u_dzFileUtils.pas:617
 msgid "Error %%1:s (%%0:d) while trying to copy \"%s\" to \"%s\"."
 msgstr "Fehler %%1:s (%%0:d) beim Kopieren von \"%s\" nach \"%s\"."
 
-#. doppelte % zum Durchreichen in Prozedur
+#. duplicate % so they get passed through the format function
 #. Programmer's name for it: STR_DELETEFILE_ERROR_S
-#: u_dzFileUtils.pas:471
+#: u_dzFileUtils.pas:619
 msgid "Error %%1:s (%%0:d) deleting file \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim L?schen der Datei \"%s\""
 
-#. doppelte % zum Durchreichen in Prozedur
+#. duplicate % so they get passed through the format function
 #. Programmer's name for it: STR_REMOVEDIR_ERROR_S
-#: u_dzFileUtils.pas:473
+#: u_dzFileUtils.pas:621
 msgid "Error %%1:s (%%0:d) deleting directory \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim L?schen des Verzeichnisses \"%s\""
 
 #. Programmer's name for it: STR_DELTREE_ERROR_S
-#: u_dzFileUtils.pas:474
+#: u_dzFileUtils.pas:622
 msgid "\"%s\" does not exist or is not a directory"
 msgstr "\"%s\" existiert nicht oder ist kein Verzeichnis"
 
-#. doppelte % zum Durchreichen in Prozedur
+#. duplicate % so they get passed through the format function
 #. Programmer's name for it: STR_CREATEDIR_ERROR_S
-#: u_dzFileUtils.pas:476
+#: u_dzFileUtils.pas:624
 msgid "Error %%1:s (%%0:d) creating directory \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim Erstellen des Verzeichnisses \"%s\""
 
@@ -156,7 +160,7 @@
 #. Programmer's name for it: STR_VARIANT_IS_NULL_SHOULD_BE_SS
 #. Variant ist Null, sollte %s sein: %s
 #. Programmer's name for it: STR_VARIANT_IS_NULL_SHOULD_BE_SS
-#: u_dzMiscUtils.pas:350
+#: u_dzMiscUtils.pas:338
 msgid "Variant is Null, should be %s: %s"
 msgstr "Variant ist Null, sollte %s sein: %s"
 
@@ -164,44 +168,44 @@
 #. Programmer's name for it: STR_VARIANT_IS_EMPTY_SHOULD_BE_SS
 #. Variant ist Empty, sollte %s sein: %s
 #. Programmer's name for it: STR_VARIANT_IS_EMPTY_SHOULD_BE_SS
-#: u_dzMiscUtils.pas:352
+#: u_dzMiscUtils.pas:340
 msgid "Variant is Empty, should be %s: %s"
 msgstr "Variant ist leer, sollte %s sein: %s"
 
 #. Variant kann nicht nach %s konvertiert werden: %s
 #. Programmer's name for it: STR_VARAINT_CAN_NOT_BE_CONVERTED_TO_SS
 #. Programmer's name for it: STR_VARIANT_CAN_NOT_BE_CONVERTED_TO_SS
-#: u_dzMiscUtils.pas:354
+#: u_dzMiscUtils.pas:342
 msgid "Variant can not be converted to %s: %s"
 msgstr "Variant kann nicht nach %s konvertiert werden: %s"
 
 #. Unbekannter Betriebssystem Fehler
 #. Programmer's name for it: STR_UNKNOWN_WIN32_ERROR
-#: u_dzMiscUtils.pas:357
+#: u_dzMiscUtils.pas:345
 msgid "unknown OS error"
 msgstr "Unbekannter Betriebssystemfehler"
 
 #. Unbekannter Win32 Fehler
 #. Programmer's name for it: STR_UNKNOWN_WIN32_ERROR
-#: u_dzMiscUtils.pas:360
+#: u_dzMiscUtils.pas:348
 msgid "unknown Win32 error"
 msgstr "Unbekannter Windows Fehler"
 
 #. nthWord: Nulltes Wort nicht verf?gbar
 #. Programmer's name for it: STR_NO_0TH_WORD
-#: u_dzStringUtils.pas:265
+#: u_dzStringUtils.pas:299
 msgid "nthWord: 0th word not available"
 msgstr "nthWord: 0tes Wort ist nicht verf?gbar"
 
 #. Zu zentrierender String ist l?nger als die Maximall?nge und kann nicht zentriert werden.
 #. Programmer's name for it: STR_STRING_TOO_LONG_TO_CENTER
-#: u_dzStringUtils.pas:268
+#: u_dzStringUtils.pas:302
 msgid "Cannot center string that is larger than the maximum length."
 msgstr "Kann keinen String zentrieren, der l?nger als die maximale L?nge ist."
 
 #. Strings haben kein nulltes Zeichen.
 #. Programmer's name for it: STR_CHAR_INDEX_OUT_OF_RANGE
-#: u_dzStringUtils.pas:271
+#: u_dzStringUtils.pas:305
 msgid "Strings do not have a 0th character."
 msgstr "Strings haben kein 0tes Zeichen."
 
@@ -211,33 +215,33 @@
 msgid "Variant can not be converted to %s"
 msgstr "Variant kann nicht nach %s konvertiert werden"
 
-#: u_dzVclUtils.pas:465
+#: u_dzVclUtils.pas:553
 msgid "\"%s\" is not a valid floating point value."
 msgstr "\"%s\" ist kein g?ltiger Flie?kommawert."
 
-#: u_dzVclUtils.pas:480
+#: u_dzVclUtils.pas:568
 msgid "\"%s\" is not a valid integer value."
 msgstr "\"%s\" ist kein g?ltiger Integerwert."
 
 #. Programmer's name for it: STR_SHOW_DETAILS
-#: w_dzDialog.pas:298
+#: w_dzDialog.pas:301
 msgid "&Details >>"
 msgstr "&Details >>"
 
 #. Programmer's name for it: STR_HIDE_DETAILS
-#: w_dzDialog.pas:299
+#: w_dzDialog.pas:302
 msgid "&Details <<"
 msgstr "&Details <<"
 
-#: w_dzDialog.pas:310
+#: w_dzDialog.pas:313
 msgid "Invalid modal result %d."
 msgstr "Ung?ltiger modaler R?ckgabewert %d."
 
-#: w_dzDialog.pas:453
+#: w_dzDialog.pas:474
 msgid "Do not show again."
 msgstr "Nicht nochmal anzeigen."
 
-#: w_dzDialog.pas:534
+#: w_dzDialog.pas:555
 msgid ""
 "An error occurred:\n"
 "%s"
@@ -246,7 +250,16 @@
 "%s"
 
 #. 400;
-#: w_dzDialog.pas:558
+#: w_dzDialog.pas:579
 msgid "Additional information:"
 msgstr "Erweiterte Informationen:"
 
+#~ msgid "Error: %s"
+#~ msgstr "Fehler: %s"
+#~ msgid "Synopsis: %s %s"
+#~ msgstr "Aufruf: %s %s"
+#~ msgid "Parameters:"
+#~ msgstr "Parameter:"
+#~ msgid "Options:"
+#~ msgstr "Optionen:"
+



From twm at mail.berlios.de  Sun Dec 16 16:35:57 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 16:35:57 +0100
Subject: [Dzchart-svncheckins] r257 - utilities/dzLib/trunk/src
Message-ID: <200712161535.lBGFZv0O000417@sheep.berlios.de>

Author: twm
Date: 2007-12-16 16:35:48 +0100 (Sun, 16 Dec 2007)
New Revision: 257

Modified:
   utilities/dzLib/trunk/src/u_dzClassUtils.pas
Log:
converted PasDoc comments to HelpInsight comments

Modified: utilities/dzLib/trunk/src/u_dzClassUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzClassUtils.pas	2007-12-16 15:06:17 UTC (rev 256)
+++ utilities/dzLib/trunk/src/u_dzClassUtils.pas	2007-12-16 15:35:48 UTC (rev 257)
@@ -1,6 +1,8 @@
 {GXFormatter.config=twm}
-{: Implements functions which work on classes but are not methods.
-   @autor(twm) }
+/// <summary>
+/// Implements functions which work on classes but are not methods.
+/// @autor(twm)
+/// </summary>
 unit u_dzClassUtils;
 
 interface
@@ -12,74 +14,98 @@
 // NOTE: The naming convention is <extended-class>_<Methodname>
 
 type
-  {: raised by StringByObj if no matching entry was found }
+  /// <summary>
+  /// raised by StringByObj if no matching entry was found
+  /// </summary>
   EObjectNotFound = class(Exception);
 
-  {: Removes trailing spaces from all lines in Strings as well as empty lines
-     from the end of Strings, returns true if at least one string was shortened
-     or an empty string was removed.
-     @param Strings is the TStrings class to work on.
-     @returns true, if something was changed, false otherwise }
+/// <summary>
+/// Removes trailing spaces from all lines in Strings as well as empty lines
+/// from the end of Strings, returns true if at least one string was shortened
+/// or an empty string was removed.
+/// @param Strings is the TStrings class to work on.
+/// @returns true, if something was changed, false otherwise
+/// </summary>
 function TStrings_RemoveTrailingSpaces(_Strings: TStrings): boolean;
 
-{: Free a TStrings object including all it's Object[n]s }
+/// <summary>
+/// Free a TStrings object including all it's Object[n]s
+/// </summary>
 procedure TStrings_FreeWithObjects(_Strings: TStrings);
 
-{: Frees all objects stored in the TStrings intance and returns the instance,
-   meant to be called like
-   @code( TStrings_FreeAllObjects(sl).Free; ) or
-   @code( TStrings_FreeAllObjects(sl).Clear; ) }
+/// <summary>
+/// Frees all objects stored in the TStrings intance and returns the instance,
+/// meant to be called like
+/// @code( TStrings_FreeAllObjects(sl).Free; ) or
+/// @code( TStrings_FreeAllObjects(sl).Clear; ) 
+/// </summary>
 function TStrings_FreeAllObjects(_Strings: TStrings): TStrings;
 
-{: frees the object and delets the entry from the list }
+/// <summary>
+/// frees the object and delets the entry from the list
+/// </summary>
 procedure TStrings_DeleteAndFreeObject(_Strings: TStrings; _Idx: integer);
 
-{: Free a TList object an all TObjects it contains
-   NOTE: this function is obsolete, use contnrs.TObjectList instead! }
+/// <summary>
+/// Free a TList object an all TObjects it contains
+/// NOTE: this function is obsolete, use contnrs.TObjectList instead!
+/// </summary>
 procedure TList_FreeWithItems(var _List: TList); deprecated; // use contnrs.TObjectList
 
-{: Write a string to the stream
-   @param Stream is the TStream to write to.
-   @param s is the string to write
-   @returns the number of bytes written. }
+/// <summary>
+// Write a string to the stream
+/// @param Stream is the TStream to write to.
+/// @param s is the string to write
+/// @returns the number of bytes written.
+/// </summary>
 function TStream_WriteString(_Stream: TStream; const _s: string): integer;
 
-{: Write a string to the stream appending CRLF
-   @param Stream is the TStream to write to.
-   @param s is the string to write
-   @returns the number of bytes written. }
+/// <summary>
+/// Write a string to the stream appending CRLF
+/// @param Stream is the TStream to write to.
+/// @param s is the string to write
+/// @returns the number of bytes written. 
+/// </summary>
 function TStream_WriteStringLn(_Stream: TStream; const _s: string): integer;
 
-{: Read a line from a stream, that is, a string ending in CRLF
-   @param Stream is the TStream to read from.
-   @param s returns the read string.
-   @returns the number of bytes read. }
+/// <summary>
+/// Read a line from a stream, that is, a string ending in CRLF
+/// @param Stream is the TStream to read from.
+/// @param s returns the read string, without the CRLF
+/// @returns the number of bytes read, excluding the CRLF
+/// </summary>
 function TStream_ReadStringLn(_Stream: TStream; out _s: string): integer;
 
-{: Write formatted data to the stream appending CRLF
-   @param Stream is the TStream to write to.
-   @param Format is a format string as used in sysutils.format
-   @param Args is an array of const as used in sysutils.format
-   @returns the number of bytes written. }
+/// <summary>
+/// Write formatted data to the stream appending CRLF
+/// @param Stream is the TStream to write to.
+/// @param Format is a format string as used in sysutils.format
+/// @param Args is an array of const as used in sysutils.format
+/// @returns the number of bytes written.
+/// </summary>
 function TStream_WriteFmtLn(_Stream: TStream; const _Format: string; _Args: array of const): integer;
 
-{: returns the string which has the given value as Object
-   @param Strings is the TStrings to search
-   @param Obj is a pointer to match
-   @param RaiseException is a boolean that controls whether an exception should
-          be raised (if true) if the Obj cannot be found or an empty strin should
-          be returned (if false), Default = true
-   @returns the string whose object matches Obj or an empty string, if none
-            was found and RaiseExeption was false
-   @raises EObjectNotFound if a matching object was not found and RaiseException
-                           is true. }
+/// <summary>
+/// returns the string which has the given value as Object
+/// @param Strings is the TStrings to search
+/// @param Obj is a pointer to match
+/// @param RaiseException is a boolean that controls whether an exception should
+///           be raised (if true) if the Obj cannot be found or an empty strin should
+///           be returned (if false), Default = true
+/// @returns the string whose object matches Obj or an empty string, if none
+///          was found and RaiseExeption was false
+/// @raises EObjectNotFound if a matching object was not found and RaiseException
+///         is true.
+/// </summary>
 function TStrings_StringByObj(_Strings: TStrings; _Obj: pointer; _RaiseException: boolean = true): string;
 
-{: determines the string which has the given value as Object
-   @param Strings is the TStrings to search
-   @param Obj is a pointer to match
-   @param Value is the string whose object matches Obj, only valid if result is true
-   @returns true, if a matching object was found, false otherwise }
+/// <summary>
+/// determines the string which has the given value as Object
+/// @param Strings is the TStrings to search
+/// @param Obj is a pointer to match
+/// @param Value is the string whose object matches Obj, only valid if result is true
+/// @returns true, if a matching object was found, false otherwise
+/// </summary>
 function TStrings_TryStringByObj(_Strings: TStrings; _Obj: pointer; out _Value: string): boolean;
 
 implementation



From twm at mail.berlios.de  Sun Dec 16 16:43:04 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 16 Dec 2007 16:43:04 +0100
Subject: [Dzchart-svncheckins] r258 - in utilities/dzLib/trunk: . tests
	tests/dzconvertutils tests/dzfileutils tests/src
Message-ID: <200712161543.lBGFh4nD000807@sheep.berlios.de>

Author: twm
Date: 2007-12-16 16:42:58 +0100 (Sun, 16 Dec 2007)
New Revision: 258

Added:
   utilities/dzLib/trunk/tests/src/
   utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr
   utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj
   utilities/dzLib/trunk/tests/src/Testu_dzClassUtils.pas
   utilities/dzLib/trunk/tests/src/Testu_dzConvertUtils.pas
   utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas
Removed:
   utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr
   utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj
   utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas
   utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas
Modified:
   utilities/dzLib/trunk/
   utilities/dzLib/trunk/tests/
Log:
* added tests for u_dzClassUtils
* moved unit test source to subdir src and corrected paths


Property changes on: utilities/dzLib/trunk
___________________________________________________________________
Name: svn:ignore
   + default.po
default_de.mo
filtered.po



Property changes on: utilities/dzLib/trunk/tests
___________________________________________________________________
Name: svn:ignore
   + DUnitTests_dzLib.exe
dunit.ini


Deleted: utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr	2007-12-16 15:35:48 UTC (rev 257)
+++ utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr	2007-12-16 15:42:58 UTC (rev 258)
@@ -1,42 +0,0 @@
-program DUnitTests_dzLib;
-{
-
-  Delphi DUnit Test Project
-  -------------------------
-  This project contains the DUnit test framework and the GUI/Console test runners.
-  Add "CONSOLE_TESTRUNNER" to the conditional defines entry in the project options 
-  to use the console test runner.  Otherwise the GUI test runner will be used by 
-  default.
-
-}
-
-{$IFDEF CONSOLE_TESTRUNNER}
-{$APPTYPE CONSOLE}
-{$ENDIF}
-
-uses
-  Forms,
-  TestFramework,
-  GUITestRunner,
-  TextTestRunner,
-  u_dzFileUtils in '..\src\u_dzFileUtils.pas',
-  Testu_dzFileUtils in 'dzfileutils\Testu_dzFileUtils.pas',
-  u_dzMiscUtils in '..\src\u_dzMiscUtils.pas',
-  u_dzStringUtils in '..\src\u_dzStringUtils.pas',
-  u_dzConvertUtils in '..\src\u_dzConvertUtils.pas',
-  u_dzTranslator in '..\src\u_dzTranslator.pas',
-  u_dzDateUtils in '..\src\u_dzDateUtils.pas',
-  u_dzUnitTestUtils in '..\src\u_dzUnitTestUtils.pas',
-  u_dzVariantUtils in '..\src\u_dzVariantUtils.pas',
-  Testu_dzConvertUtils in 'dzconvertutils\Testu_dzConvertUtils.pas';
-
-{$R *.RES}
-
-begin
-  Application.Initialize;
-  if IsConsole then
-    TextTestRunner.RunRegisteredTests
-  else
-    GUITestRunner.RunRegisteredTests;
-end.
-

Deleted: utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj	2007-12-16 15:35:48 UTC (rev 257)
+++ utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj	2007-12-16 15:42:58 UTC (rev 258)
@@ -1,55 +0,0 @@
-?<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <ProjectGuid>{9732bdc0-39a6-4dbb-817c-3fb77772e288}</ProjectGuid>
-    <MainSource>DUnitTests_dzLib.dpr</MainSource>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <DCC_DCCCompiler>DCC32</DCC_DCCCompiler>
-    <DCC_DependencyCheckOutputName>DUnitTests_dzLib.exe</DCC_DependencyCheckOutputName>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <Version>7.0</Version>
-    <DCC_DebugInformation>False</DCC_DebugInformation>
-    <DCC_LocalDebugSymbols>False</DCC_LocalDebugSymbols>
-    <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
-    <DCC_Define>RELEASE</DCC_Define>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <Version>7.0</Version>
-    <DCC_Define>DEBUG;_CONSOLE_TESTRUNNER;no_translation</DCC_Define>
-    <DCC_UnitSearchPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_UnitSearchPath>
-    <DCC_ResourcePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_ResourcePath>
-    <DCC_ObjPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_ObjPath>
-    <DCC_IncludePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\jedi_inc</DCC_IncludePath>
-    <DCC_DcuOutput>dcu</DCC_DcuOutput>
-    <DCC_ObjOutput>dcu</DCC_ObjOutput>
-    <DCC_HppOutput>dcu</DCC_HppOutput>
-    <DCC_SYMBOL_PLATFORM>False</DCC_SYMBOL_PLATFORM>
-    <DCC_UNIT_PLATFORM>False</DCC_UNIT_PLATFORM>
-    <DCC_Optimize>False</DCC_Optimize>
-    <DCC_IntegerOverflowCheck>True</DCC_IntegerOverflowCheck>
-    <DCC_RangeChecking>True</DCC_RangeChecking>
-  </PropertyGroup>
-  <ProjectExtensions>
-    <Borland.Personality>Delphi.Personality</Borland.Personality>
-    <Borland.ProjectType />
-    <BorlandProject>
-<BorlandProject><Delphi.Personality><Parameters><Parameters Name="UseLauncher">False</Parameters><Parameters Name="LoadAllSymbols">True</Parameters><Parameters Name="LoadUnspecifiedSymbols">False</Parameters></Parameters><VersionInfo><VersionInfo Name="IncludeVerInfo">False</VersionInfo><VersionInfo Name="AutoIncBuild">False</VersionInfo><VersionInfo Name="MajorVer">1</VersionInfo><VersionInfo Name="MinorVer">0</VersionInfo><VersionInfo Name="Release">0</VersionInfo><VersionInfo Name="Build">0</VersionInfo><VersionInfo Name="Debug">False</VersionInfo><VersionInfo Name="PreRelease">False</VersionInfo><VersionInfo Name="Special">False</VersionInfo><VersionInfo Name="Private">False</VersionInfo><VersionInfo Name="DLL">False</VersionInfo><VersionInfo Name="Locale">1033</VersionInfo><VersionInfo Name="CodePage">1252</VersionInfo></VersionInfo><VersionInfoKeys><VersionInfoKeys Name="CompanyName"></VersionInfoKeys><VersionInfoKeys Name="FileDescription"></VersionInfoKeys><VersionI!
 nfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="InternalName"></VersionInfoKeys><VersionInfoKeys Name="LegalCopyright"></VersionInfoKeys><VersionInfoKeys Name="LegalTrademarks"></VersionInfoKeys><VersionInfoKeys Name="OriginalFilename"></VersionInfoKeys><VersionInfoKeys Name="ProductName"></VersionInfoKeys><VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="Comments"></VersionInfoKeys></VersionInfoKeys><Source><Source Name="MainSource">DUnitTests_dzLib.dpr</Source></Source></Delphi.Personality><UnitTesting><TestFramework>DUnit / Delphi Win32</TestFramework><TestRunner>GUI</TestRunner></UnitTesting></BorlandProject></BorlandProject>
-  </ProjectExtensions>
-  <Import Project="$(MSBuildBinPath)\Borland.Delphi.Targets" />
-  <ItemGroup>
-    <DelphiCompile Include="DUnitTests_dzLib.dpr">
-      <MainSource>MainSource</MainSource>
-    </DelphiCompile>
-    <DCCReference Include="..\src\u_dzConvertUtils.pas" />
-    <DCCReference Include="..\src\u_dzDateUtils.pas" />
-    <DCCReference Include="..\src\u_dzFileUtils.pas" />
-    <DCCReference Include="..\src\u_dzMiscUtils.pas" />
-    <DCCReference Include="..\src\u_dzStringUtils.pas" />
-    <DCCReference Include="..\src\u_dzTranslator.pas" />
-    <DCCReference Include="..\src\u_dzUnitTestUtils.pas" />
-    <DCCReference Include="..\src\u_dzVariantUtils.pas" />
-    <DCCReference Include="dzconvertutils\Testu_dzConvertUtils.pas" />
-    <DCCReference Include="dzfileutils\Testu_dzFileUtils.pas" />
-  </ItemGroup>
-</Project>
\ No newline at end of file

Deleted: utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas	2007-12-16 15:35:48 UTC (rev 257)
+++ utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas	2007-12-16 15:42:58 UTC (rev 258)
@@ -1,105 +0,0 @@
-unit Testu_dzConvertUtils;
-
-interface
-
-uses
-  Windows,
-  Classes,
-  SysUtils,
-  TestFramework,
-  u_dzConvertUtils,
-  u_dzUnitTestUtils;
-
-type
-  TestDecimalConversion = class(TdzTestCase)
-  protected
-    FDecDigit2LongOutOfRangeValue: char;
-    procedure DecDigit2LongOutOfRange;
-  published
-    procedure TestIsDecDigit;
-    procedure TestisDec(const _s: string);
-    procedure TestDecDigit2Long(_a: char);
-    procedure TestDec2Long(const _s: string);
-    procedure TestLong2Dec2(_l: ULong);
-    procedure TestLong2Dec4(_l: ULong);
-    procedure TestLong2DecN(_l: ULong; _n: ULong);
-    procedure TestLong2Dec(_l: ULong);
-  end;
-
-implementation
-
-{ TestDecimalConversion }
-
-procedure TestDecimalConversion.TestDec2Long(const _s: string);
-begin
-end;
-
-procedure TestDecimalConversion.DecDigit2LongOutOfRange;
-begin
-  CheckEquals(0, DecDigit2Long(FDecDigit2LongOutOfRangeValue));
-end;
-
-procedure TestDecimalConversion.TestDecDigit2Long(_a: char);
-var
-  c: char;
-begin
-  for c := chr(0) to chr(255) do begin
-    if c in ['0'..'9'] then
-      CheckEquals(Ord(c) - Ord('0'), DecDigit2Long(c))
-    else begin
-      FDecDigit2LongOutOfRangeValue := c;
-      CheckException(DecDigit2LongOutOfRange, EDigitOutOfRange);
-    end;
-  end;
-end;
-
-procedure TestDecimalConversion.TestisDec(const _s: string);
-begin
-  CheckTrue(isDec('0'));
-  CheckTrue(isDec('1'));
-  CheckTrue(isDec('12'));
-  CheckTrue(isDec('18945'));
-  CheckTrue(isDec('0845'));
-  CheckTrue(isDec('000000'));
-  CheckTrue(isDec('90894514908'));
-  CheckFalse(isDec('a'));
-  CheckFalse(isDec('1a425'));
-  CheckFalse(isDec('-2345'));
-  CheckFalse(isDec('0000001a'));
-end;
-
-procedure TestDecimalConversion.TestIsDecDigit;
-var
-  c: char;
-begin
-  for c := chr(0) to chr(255) do
-    if c in ['0'..'9'] then
-      CheckTrue(isDecDigit(c))
-    else
-      CheckFalse(isDecDigit(c));
-end;
-
-procedure TestDecimalConversion.TestLong2Dec(_l: ULong);
-begin
-
-end;
-
-procedure TestDecimalConversion.TestLong2Dec2(_l: ULong);
-begin
-
-end;
-
-procedure TestDecimalConversion.TestLong2Dec4(_l: ULong);
-begin
-
-end;
-
-procedure TestDecimalConversion.TestLong2DecN(_l, _n: ULong);
-begin
-
-end;
-
-initialization
-  RegisterTest(TestDecimalConversion.Suite);
-end.
-

Deleted: utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas	2007-12-16 15:35:48 UTC (rev 257)
+++ utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas	2007-12-16 15:42:58 UTC (rev 258)
@@ -1,806 +0,0 @@
-unit Testu_dzFileUtils;
-
-interface
-
-uses
-  Windows,
-  Classes,
-  SysUtils,
-  TestFramework,
-  u_dzFileUtils,
-  u_dzUnitTestUtils;
-
-type
-  TFileSystemTestCase = class(TdzTestCase)
-  protected
-    FTestDir: string;
-    procedure SetUp; override;
-    procedure TearDown; override;
-    function CreateTestFile(const _Filename, _Content: string): string;
-    procedure CheckTestfile(const _Filename, _Content: string);
-    procedure CheckSubdirExists(const _Dirname: string);
-  end;
-
-type
-  TestTFileSystem = class(TFileSystemTestCase)
-  private
-    FCallbackCount: integer;
-    FSourceFile: string;
-    FDestFile: string;
-    procedure ProgressContinue(_Status: TCopyProgressStatus;
-      var _Continue: TCopyProgressStatus.TProgressResult);
-    procedure ProgressCancel(_Status: TCopyProgressStatus;
-      var _Continue: TCopyProgressStatus.TProgressResult);
-  protected
-    procedure SetUp; override;
-    procedure TearDown; override;
-  published
-    procedure TestCopyFileWithProgressContinue;
-    procedure TestCopyFileWithProgressCancel;
-    procedure TestMoveFileWithProgressCancel;
-  end;
-
-  TestTDirectorySync = class(TFileSystemTestCase)
-  private
-    FLargeContent: string;
-    FDirA: string;
-    FDirB: string;
-    FSync: TDirectorySync;
-    FFile1: string;
-    FFile2: string;
-    FFile3: string;
-    FFile4: string;
-    FFile5: string;
-    FFile6: string;
-    FFileA7: string;
-    FFileB7: string;
-    FCallbacks: TStringList;
-    FExistingFiles: TStringList;
-    procedure OnSyncDirAbort(_Sender: TObject; const _Src, _Dst: string);
-    procedure OnDirSyncCallback(_Sender: TObject; const _Src, _Dst: string);
-    procedure OnFileSyncCallback(_Sender: TObject; const _Src, _Dst: string; _Total, _Done: Int64);
-    procedure OnFileExistsCallback(_Sender: TObject; const _SrcFile, _DstFile: TFileInfoRec; var _Action: TFileExistsAction);
-    procedure CheckSameText(const _Expected, _Actual, _Msg: string);
-  protected
-    procedure SetUp; override;
-    procedure TearDown; override;
-  published
-    procedure TestSyncOneWay;
-    procedure TestSyncBoth;
-    procedure TestSyncAbortImmediately;
-    procedure TestSyncOneWayCallback;
-    procedure TestCheckOneWay;
-  end;
-
-  TestTFileGenerationHandler_Base = class(TFileSystemTestCase)
-  private
-    FHandler: TFileGenerationHandler;
-  protected
-    procedure SetUp; override;
-    procedure TearDown; override;
-  end;
-
-  TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
-  published
-    procedure TestNoneExisting;
-    procedure TestOneExisting;
-    procedure TestAllExisting;
-  end;
-
-  TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep = class(TestTFileGenerationHandler_Base)
-  published
-    procedure TestNoneExisting;
-    procedure TestOneExisting;
-    procedure TestAllExisting;
-  end;
-
-  TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
-  protected
-    procedure SetUp; override;
-  published
-    procedure TestNoneExisting;
-    procedure TestOneExisting;
-    procedure TestTwoExisting;
-    procedure TestAllExisting;
-  end;
-
-  TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep = class(TestTFileGenerationHandler_Base)
-  protected
-    procedure SetUp; override;
-  published
-    procedure TestNoneExisting;
-    procedure TestOneExisting;
-    procedure TestTwoExisting;
-    procedure TestAllExisting;
-  end;
-
-  TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
-  protected
-    procedure SetUp; override;
-  published
-    procedure TestNoneExisting;
-    procedure TestOneExisting;
-    procedure TestAllExisting;
-  end;
-
-  TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep = class(TestTFileGenerationHandler_Base)
-  protected
-    procedure SetUp; override;
-  published
-    procedure TestNoneExisting;
-    procedure TestOneExisting;
-    procedure TestAllExisting;
-  end;
-
-implementation
-
-{ TFileSystemTestCase }
-
-procedure TFileSystemTestCase.CheckTestfile(const _Filename, _Content: string);
-var
-  t: TextFile;
-  s: string;
-begin
-  Check(FileExists(FTestDir + _Filename), _Filename + ' does not exist');
-  AssignFile(t, FTestDir + _Filename);
-  Reset(t);
-  Read(t, s);
-  Close(t);
-  CheckEquals(_Content, s, 'content of file ' + _Filename);
-end;
-
-procedure TFileSystemTestCase.CheckSubdirExists(const _Dirname: string);
-begin
-  Check(DirectoryExists(FTestDir + _Dirname), 'directory ' + _Dirname + ' missing');
-end;
-
-function TFileSystemTestCase.CreateTestFile(const _Filename, _Content: string): string;
-var
-  t: TextFile;
-begin
-  Result := FTestDir + _Filename;
-  AssignFile(t, Result);
-  Rewrite(t);
-  WriteLn(t, _Content);
-  Close(t);
-end;
-
-procedure TFileSystemTestCase.SetUp;
-begin
-  inherited;
-  FTestDir := itpd(TFileSystem.CreateUniqueDirectory());
-end;
-
-procedure TFileSystemTestCase.TearDown;
-begin
-  TFileSystem.DelTree(FTestDir);
-  inherited;
-end;
-
-const
-  GENERATION_FILENAME = 'hallo';
-  GENERATION_SUFFIX = '.txt';
-
-{ TestTFileSystem }
-
-procedure TestTFileSystem.ProgressCancel(_Status: TCopyProgressStatus;
-  var _Continue: TCopyProgressStatus.TProgressResult);
-begin
-  _Continue := prCancel;
-  Inc(FCallbackCount);
-end;
-
-procedure TestTFileSystem.ProgressContinue(_Status: TCopyProgressStatus;
-  var _Continue: TCopyProgressStatus.TProgressResult);
-begin
-  _Continue := prContinue;
-  Inc(FCallbackCount);
-end;
-
-procedure TestTFileSystem.SetUp;
-const
-  SOURCEFILE = 'sourcefile.txt';
-  DESTFILE = 'destfile.txt';
-begin
-  inherited;
-  FCallbackCount := 0;
-  FSourceFile := CreateTestFile(SOURCEFILE, 'source');
-  FDestFile := FTestDir + DESTFILE;
-  if FileExists(FDestFile) then
-    TFileSystem.DeleteFile(FDestFile);
-end;
-
-procedure TestTFileSystem.TearDown;
-begin
-  inherited;
-  TFileSystem.DeleteFile(FSourceFile, false);
-  TFileSystem.DeleteFile(FDestFile, false);
-end;
-
-procedure TestTFileSystem.TestCopyFileWithProgressContinue;
-var
-  Res: TFileSystem.TCopyFileWithProgressResult;
-begin
-  Res := TFileSystem.CopyFileWithProgress(FSourceFile, FDestFile, ProgressContinue);
-  Check(Res = cfwOK, 'aborted or error');
-  CheckTrue(FileExists(FDestFile), 'destination file missing');
-  CheckEquals(2, FCallbackCount, 'Callback count wrong');
-end;
-
-procedure TestTFileSystem.TestMoveFileWithProgressCancel;
-var
-  Res: TFileSystem.TCopyFileWithProgressResult;
-begin
-  Res := TFileSystem.MoveFileWithProgress(FSourceFile, FDestFile, ProgressCancel, []);
-  Check(Res = cfwOK, 'aborted expected');
-  CheckFalse(FileExists(FDestFile), 'destination file exists');
-end;
-
-procedure TestTFileSystem.TestCopyFileWithProgressCancel;
-var
-  Res: TFileSystem.TCopyFileWithProgressResult;
-begin
-  Res := TFileSystem.CopyFileWithProgress(FSourceFile, FDestFile, ProgressCancel, []);
-  Check(Res = cfwAborted, 'aborted expected');
-  CheckEquals(1, FCallbackCount, 'Callback count wrong');
-end;
-
-{ TestTFileGenerationHandler_Base }
-
-procedure TestTFileGenerationHandler_Base.SetUp;
-begin
-  inherited;
-  FHandler := TFileGenerationHandler.Create(FTestDir + GENERATION_FILENAME, GENERATION_SUFFIX);
-end;
-
-procedure TestTFileGenerationHandler_Base.TearDown;
-begin
-  FHandler.Free;
-  inherited;
-end;
-
-{ TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber }
-
-procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.TestAllExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
-  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
-  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
-  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.TestNoneExisting;
-var
-  s: string;
-begin
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-end;
-
-procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.TestOneExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-{ TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep }
-
-procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.TestAllExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
-  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
-  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
-  s := FHandler.Execute(True);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
-  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.TestNoneExisting;
-var
-  s: string;
-begin
-  s := FHandler.Execute(true);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-end;
-
-procedure TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.TestOneExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(true);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-{ TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber }
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.SetUp;
-begin
-  inherited;
-  FHandler.OldestIsHighest := false;
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestAllExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '5');
-  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
-  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
-  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
-  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
-  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestNoneExisting;
-var
-  s: string;
-begin
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestOneExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.TestTwoExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_3' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-{ TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep }
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.SetUp;
-begin
-  inherited;
-  FHandler.OldestIsHighest := false;
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestAllExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '5');
-  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
-  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
-  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(true);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '5');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
-  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
-  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestNoneExisting;
-var
-  s: string;
-begin
-  s := FHandler.Execute(true);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestOneExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(true);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '1');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.TestTwoExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(true);
-  CheckEquals(FTestDir + GENERATION_FILENAME + GENERATION_SUFFIX, s, 'filename');
-  CheckTestfile(GENERATION_FILENAME + GENERATION_SUFFIX, '2');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_3' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-{ TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber }
-
-procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.SetUp;
-begin
-  inherited;
-  FHandler.ResultContainsNumber := true;
-end;
-
-procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.TestAllExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
-  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
-  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
-  CreateTestfile(GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, '6');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
-  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
-  CheckTestfile(GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, '5');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_6' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.TestNoneExisting;
-var
-  s: string;
-begin
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-end;
-
-procedure TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.TestOneExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '1');
-end;
-
-{ TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber }
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.SetUp;
-begin
-  inherited;
-  FHandler.OldestIsHighest := false;
-  FHandler.ResultContainsNumber := true;
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.TestAllExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CreateTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '2');
-  CreateTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '3');
-  CreateTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '4');
-  CreateTestfile(GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, '5');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '2');
-  CheckTestfile(GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, '3');
-  CheckTestfile(GENERATION_FILENAME + '_3' + GENERATION_SUFFIX, '4');
-  CheckTestfile(GENERATION_FILENAME + '_4' + GENERATION_SUFFIX, '5');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_6' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.TestNoneExisting;
-var
-  s: string;
-begin
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-end;
-
-procedure TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.TestOneExisting;
-var
-  s: string;
-begin
-  CreateTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  s := FHandler.Execute(false);
-  CheckEquals(FTestDir + GENERATION_FILENAME + '_2' + GENERATION_SUFFIX, s, 'filename');
-  CheckFalse(FileExists(s), 'file exists');
-  CheckTestfile(GENERATION_FILENAME + '_1' + GENERATION_SUFFIX, '1');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_3' + GENERATION_SUFFIX), 'additional backup file exists');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_4' + GENERATION_SUFFIX), 'additional backup file exists');
-  CheckFalse(FileExists(FTestDir + GENERATION_FILENAME + '_5' + GENERATION_SUFFIX), 'additional backup file exists');
-end;
-
-{ TestTDirectorySync }
-
-procedure TestTDirectorySync.SetUp;
-begin
-  inherited;
-  FDirA := FTestDir + 'a\';
-  FDirB := FTestDir + 'b\';
-  TFileSystem.CreateDir(FDirA);
-  TFileSystem.CreateDir(FDirB);
-
-  FLargeContent := StringOfChar('a', 5 * 1024 * 1024);
-
-  FFile1 := CreateTestfile('a\file1.txt', 'File1');
-  FFile2 := CreateTestfile('a\.txt', 'File2');
-  FFile3 := CreateTestfile('a\file3', FLargeContent);
-  TFileSystem.CreateDir(FDirA + '\Sub1');
-  TFileSystem.CreateDir(FDirA + '\Sub2');
-  FFile4 := CreateTestfile('a\Sub2\file4.txt', 'File4');
-
-  FFile5 := CreateTestFile('b\file5.txt', 'File5');
-  TFileSystem.CreateDir(FDirB + '\Sub3');
-  FFile6 := CreateTestFile('b\sub3\file6.txt', 'File6');
-  TFileSystem.CreateDir(FDirB + '\Sub4');
-
-  TFileSystem.CreateDir(FDirA + '\Sub5');
-  TFileSystem.CreateDir(FDirB + '\Sub5');
-
-  TFileSystem.CreateDir(FDirA + '\Sub6');
-  TFileSystem.CreateDir(FDirB + '\Sub6');
-  FFileA7 := CreateTestFile('a\sub6\file7.txt', 'FileA7');
-  FFileB7 := CreateTestFile('b\sub6\file7.txt', 'FileB7');
-
-  FCallbacks := TStringList.Create;
-
-  FSync := TDirectorySync.Create;
-end;
-
-procedure TestTDirectorySync.TearDown;
-begin
-  FSync.Free;
-  FCallbacks.Free;
-  inherited;
-end;
-
-procedure TestTDirectorySync.TestSyncOneWay;
-var
-  Enum: TSimpleDirEnumerator;
-  Files: TStringList;
-  cnt: integer;
-begin
-  FSync.SyncOneWay(FDirA, FDirB);
-  Enum := TSimpleDirEnumerator.Create(FDirB + '*.*');
-  try
-    Files := TStringList.Create;
-    cnt := Enum.FindAll(Files);
-    Files.Free;
-  finally
-    Enum.Free;
-  end;
-  CheckEquals(10, cnt, 'number of files and subdirs');
-  CheckTestfile('b\' + ExtractFileName(FFile1), 'File1');
-  CheckTestfile('b\' + ExtractFileName(FFile2), 'File2');
-  CheckTestfile('b\' + ExtractFileName(FFile3), FLargeContent);
-  CheckSubdirExists('b\Sub1');
-  CheckSubdirExists('b\Sub2');
-  CheckTestfile('b\Sub2\' + ExtractFileName(FFile4), 'File4');
-  CheckTestfile('b\' + ExtractFileName(FFile5), 'File5');
-  CheckSubdirExists('b\Sub3');
-  CheckTestfile('b\Sub3\' + ExtractFileName(FFile6), 'File6');
-  CheckSubdirExists('b\Sub4');
-
-  CheckSubdirExists('b\Sub5');
-  CheckSubdirExists('b\Sub6');
-  CheckTestfile('b\Sub6\' + ExtractFileName(FFileB7), 'FileB7');
-end;
-
-procedure TestTDirectorySync.TestSyncOneWayCallback;
-var
-  Expected: TStringList;
-  i: Integer;
-begin
-  FSync.OnSyncingDir := OnDirSyncCallback;
-  FSync.OnSyncingFile := OnFileSyncCallback;
-  FSync.SyncOneWay(FDirA, FDirB);
-
-  Expected := TStringList.Create;
-  try
-    Expected.Add(FDirA + ' -> ' + FDirB);
-    Expected.Add(FDirA + '.txt -> ' + FDirB + '.txt (0 of 7)');
-    Expected.Add(FDirA + '.txt -> ' + FDirB + '.txt (7 of 7)');
-    Expected.Add(FDirA + 'file1.txt -> ' + FDirB + 'file1.txt (0 of 7)');
-    Expected.Add(FDirA + 'file1.txt -> ' + FDirB + 'file1.txt (7 of 7)');
-    for i := 0 to 80 do
-      Expected.Add(FDirA + 'file3 -> ' + FDirB + Format('file3 (%d of 5242882)', [i * 65536]));
-    Expected.Add(FDirA + 'file3 -> ' + FDirB + 'file3 (5242882 of 5242882)');
-    Expected.Add(FDirA + 'Sub1 -> ' + FDirB + 'Sub1');
-    Expected.Add(FDirA + 'Sub2 -> ' + FDirB + 'Sub2');
-    Expected.Add(FDirA + 'Sub2\file4.txt -> ' + FDirB + 'Sub2\file4.txt (0 of 7)');
-    Expected.Add(FDirA + 'Sub2\file4.txt -> ' + FDirB + 'Sub2\file4.txt (7 of 7)');
-    Expected.Add(FDirA + 'Sub5 -> ' + FDirB + 'Sub5');
-    Expected.Add(FDirA + 'Sub6 -> ' + FDirB + 'Sub6');
-    CheckEqualsMultiline(Expected.Text, FCallbacks.Text);
-  finally
-    Expected.Free;
-  end;
-end;
-
-procedure TestTDirectorySync.OnDirSyncCallback(_Sender: TObject; const _Src, _Dst: string);
-begin
-  FCallbacks.Add(_Src + ' -> ' + _Dst);
-end;
-
-procedure TestTDirectorySync.OnFileSyncCallback(_Sender: TObject; const _Src, _Dst: string; _Total, _Done: Int64);
-begin
-  FCallbacks.Add(_Src + ' -> ' + _Dst + ' (' + IntToStr(_Done) + ' of ' + IntToStr(_Total) + ')');
-end;
-
-procedure TestTDirectorySync.OnSyncDirAbort(_Sender: TObject; const _Src, _Dst: string);
-begin
-  SysUtils.Abort;
-end;
-
-procedure TestTDirectorySync.CheckSameText(const _Expected, _Actual, _Msg: string);
-begin
-  if not SameText(_Expected, _Actual) then
-    FailNotEquals(_Expected, _Actual, _Msg);
-end;
-
-procedure TestTDirectorySync.OnFileExistsCallback(_Sender: TObject; const _SrcFile, _DstFile: TFileInfoRec; var _Action: TFileExistsAction);
-begin
-  FExistingFiles.Add(_SrcFile.Filename + ' <> ' + _DstFile.Filename);
-  CheckEquals(_SrcFile.Size, _DstFile.Size, 'Size');
-  CheckEquals(_SrcFile.Timestamp, _DstFile.Timestamp, 'Timestamp');
-end;
-
-procedure TestTDirectorySync.TestCheckOneWay;
-begin
-  FExistingFiles := TStringList.Create;
-  try
-    FSync.OnFileExists := OnFileExistsCallback;
-    FSync.CheckOneWay(FDirA, FDirB);
-    CheckEquals(1, FExistingFiles.Count, 'existing count');
-    CheckSameText(FFileA7 + ' <> ' + FFileB7, FExistingFiles[0], 'File7');
-  finally
-    FExistingFiles.Free;
-  end;
-end;
-
-procedure TestTDirectorySync.TestSyncAbortImmediately;
-var
-  Enum: TSimpleDirEnumerator;
-  Files: TStringList;
-  cnt: integer;
-begin
-  FSync.OnSyncingDir := OnSyncDirAbort;
-  try
-    FSync.SyncOneWay(FDirA, FDirB);
-  except on EAbort do
-      ;
-  end;
-  Enum := TSimpleDirEnumerator.Create(FDirB + '*.*');
-  try
-    Files := TStringList.Create;
-    cnt := Enum.FindAll(Files);
-    Files.Free;
-  finally
-    Enum.Free;
-  end;
-  CheckEquals(5, cnt, 'number of files and subdirs');
-end;
-
-procedure TestTDirectorySync.TestSyncBoth;
-var
-  Enum: TSimpleDirEnumerator;
-  Files: TStringList;
-  cnt: integer;
-begin
-  FSync.SyncBothWays(FDirA, FDirB);
-
-  Enum := TSimpleDirEnumerator.Create(FDirB + '*.*');
-  try
-    Files := TStringList.Create;
-    cnt := Enum.FindAll(Files);
-    Files.Free;
-  finally
-    Enum.Free;
-  end;
-  CheckEquals(10, cnt, 'number of files and subdirs');
-  CheckTestfile('b\' + ExtractFileName(FFile1), 'File1');
-  CheckTestfile('b\' + ExtractFileName(FFile2), 'File2');
-  CheckTestfile('b\' + ExtractFileName(FFile3), FLargeContent);
-  CheckSubdirExists('b\Sub1');
-  CheckSubdirExists('b\Sub2');
-  CheckTestfile('b\Sub2\' + ExtractFileName(FFile4), 'File4');
-  CheckTestfile('b\' + ExtractFileName(FFile5), 'File5');
-  CheckSubdirExists('b\Sub3');
-  CheckTestfile('b\Sub3\' + ExtractFileName(FFile6), 'File6');
-  CheckSubdirExists('b\Sub4');
-
-  CheckSubdirExists('b\Sub5');
-  CheckSubdirExists('b\Sub6');
-  CheckTestfile('b\Sub6\' + ExtractFileName(FFileB7), 'FileB7');
-
-  Enum := TSimpleDirEnumerator.Create(FDirA + '*.*');
-  try
-    Files := TStringList.Create;
-    cnt := Enum.FindAll(Files);
-    Files.Free;
-  finally
-    Enum.Free;
-  end;
-  CheckEquals(10, cnt, 'number of files and subdirs');
-  CheckTestfile('a\' + ExtractFileName(FFile1), 'File1');
-  CheckTestfile('a\' + ExtractFileName(FFile2), 'File2');
-  CheckTestfile('a\' + ExtractFileName(FFile3), FLargeContent);
-  CheckSubdirExists('a\Sub1');
-  CheckSubdirExists('a\Sub2');
-  CheckTestfile('a\Sub2\' + ExtractFileName(FFile4), 'File4');
-  CheckTestfile('a\' + ExtractFileName(FFile5), 'File5');
-  CheckSubdirExists('a\Sub3');
-  CheckTestfile('a\Sub3\' + ExtractFileName(FFile6), 'File6');
-  CheckSubdirExists('a\Sub4');
-
-  Check(DirectoryExists(FDirA + 'Sub5'), 'directory Sub5 missing');
-  Check(DirectoryExists(FDirA + 'Sub6'), 'directory Sub6 missing');
-  CheckTestfile('a\Sub6\' + ExtractFileName(FFileB7), 'FileA7');
-end;
-
-initialization
-  RegisterTest(TestTFileSystem.Suite);
-  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.Suite);
-  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.Suite);
-  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTDirectorySync.Suite);
-end.
-

Copied: utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr (from rev 257, utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr)
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTests_dzLib.dpr	2007-12-16 15:35:48 UTC (rev 257)
+++ utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr	2007-12-16 15:42:58 UTC (rev 258)
@@ -0,0 +1,44 @@
+program DUnitTests_dzLib;
+{
+
+  Delphi DUnit Test Project
+  -------------------------
+  This project contains the DUnit test framework and the GUI/Console test runners.
+  Add "CONSOLE_TESTRUNNER" to the conditional defines entry in the project options 
+  to use the console test runner.  Otherwise the GUI test runner will be used by 
+  default.
+
+}
+
+{$IFDEF CONSOLE_TESTRUNNER}
+{$APPTYPE CONSOLE}
+{$ENDIF}
+
+uses
+  Forms,
+  TestFramework,
+  GUITestRunner,
+  TextTestRunner,
+  u_dzFileUtils in '..\..\src\u_dzFileUtils.pas',
+  Testu_dzFileUtils in 'Testu_dzFileUtils.pas',
+  u_dzMiscUtils in '..\..\src\u_dzMiscUtils.pas',
+  u_dzStringUtils in '..\..\src\u_dzStringUtils.pas',
+  u_dzConvertUtils in '..\..\src\u_dzConvertUtils.pas',
+  u_dzTranslator in '..\..\src\u_dzTranslator.pas',
+  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas',
+  u_dzUnitTestUtils in '..\..\src\u_dzUnitTestUtils.pas',
+  u_dzVariantUtils in '..\..\src\u_dzVariantUtils.pas',
+  Testu_dzConvertUtils in 'Testu_dzConvertUtils.pas',
+  Testu_dzClassUtils in 'Testu_dzClassUtils.pas',
+  u_dzClassUtils in '..\..\src\u_dzClassUtils.pas';
+
+{$R *.RES}
+
+begin
+  Application.Initialize;
+  if IsConsole then
+    TextTestRunner.RunRegisteredTests
+  else
+    GUITestRunner.RunRegisteredTests;
+end.
+

Copied: utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj (from rev 257, utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj)
===================================================================
--- utilities/dzLib/trunk/tests/DUnitTests_dzLib.dproj	2007-12-16 15:35:48 UTC (rev 257)
+++ utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj	2007-12-16 15:42:58 UTC (rev 258)
@@ -0,0 +1,59 @@
+?<?xml version="1.0" encoding="utf-8"?>
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <ProjectGuid>{9732bdc0-39a6-4dbb-817c-3fb77772e288}</ProjectGuid>
+    <MainSource>DUnitTests_dzLib.dpr</MainSource>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <DCC_DCCCompiler>DCC32</DCC_DCCCompiler>
+    <DCC_DependencyCheckOutputName>..\DUnitTests_dzLib.exe</DCC_DependencyCheckOutputName>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <Version>7.0</Version>
+    <DCC_DebugInformation>False</DCC_DebugInformation>
+    <DCC_LocalDebugSymbols>False</DCC_LocalDebugSymbols>
+    <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
+    <DCC_Define>RELEASE</DCC_Define>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <Version>7.0</Version>
+    <DCC_Define>DEBUG;_CONSOLE_TESTRUNNER;no_translation</DCC_Define>
+    <DCC_UnitSearchPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_UnitSearchPath>
+    <DCC_ResourcePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_ResourcePath>
+    <DCC_ObjPath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_ObjPath>
+    <DCC_IncludePath>$(BDS)\lib\Debug;$(BDS)\Lib\Debug\Indy10;$(BDS)\Source\DUnit\src;..\..\jedi_inc</DCC_IncludePath>
+    <DCC_DcuOutput>..\dcu</DCC_DcuOutput>
+    <DCC_ObjOutput>..\dcu</DCC_ObjOutput>
+    <DCC_HppOutput>..\dcu</DCC_HppOutput>
+    <DCC_SYMBOL_PLATFORM>False</DCC_SYMBOL_PLATFORM>
+    <DCC_UNIT_PLATFORM>False</DCC_UNIT_PLATFORM>
+    <DCC_Optimize>False</DCC_Optimize>
+    <DCC_IntegerOverflowCheck>True</DCC_IntegerOverflowCheck>
+    <DCC_RangeChecking>True</DCC_RangeChecking>
+    <DCC_ExeOutput>..</DCC_ExeOutput>
+  </PropertyGroup>
+  <ProjectExtensions>
+    <Borland.Personality>Delphi.Personality</Borland.Personality>
+    <Borland.ProjectType />
+    <BorlandProject>
+<BorlandProject><Delphi.Personality><Parameters><Parameters Name="UseLauncher">False</Parameters><Parameters Name="LoadAllSymbols">True</Parameters><Parameters Name="LoadUnspecifiedSymbols">False</Parameters></Parameters><VersionInfo><VersionInfo Name="IncludeVerInfo">False</VersionInfo><VersionInfo Name="AutoIncBuild">False</VersionInfo><VersionInfo Name="MajorVer">1</VersionInfo><VersionInfo Name="MinorVer">0</VersionInfo><VersionInfo Name="Release">0</VersionInfo><VersionInfo Name="Build">0</VersionInfo><VersionInfo Name="Debug">False</VersionInfo><VersionInfo Name="PreRelease">False</VersionInfo><VersionInfo Name="Special">False</VersionInfo><VersionInfo Name="Private">False</VersionInfo><VersionInfo Name="DLL">False</VersionInfo><VersionInfo Name="Locale">1033</VersionInfo><VersionInfo Name="CodePage">1252</VersionInfo></VersionInfo><VersionInfoKeys><VersionInfoKeys Name="CompanyName"></VersionInfoKeys><VersionInfoKeys Name="FileDescription"></VersionInfoKeys><VersionI!
 nfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="InternalName"></VersionInfoKeys><VersionInfoKeys Name="LegalCopyright"></VersionInfoKeys><VersionInfoKeys Name="LegalTrademarks"></VersionInfoKeys><VersionInfoKeys Name="OriginalFilename"></VersionInfoKeys><VersionInfoKeys Name="ProductName"></VersionInfoKeys><VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys><VersionInfoKeys Name="Comments"></VersionInfoKeys></VersionInfoKeys><Source><Source Name="MainSource">DUnitTests_dzLib.dpr</Source></Source></Delphi.Personality><UnitTesting><TestFramework>DUnit / Delphi Win32</TestFramework><TestRunner>GUI</TestRunner></UnitTesting></BorlandProject></BorlandProject>
+  </ProjectExtensions>
+  <Import Project="$(MSBuildBinPath)\Borland.Delphi.Targets" />
+  <ItemGroup>
+    <DelphiCompile Include="DUnitTests_dzLib.dpr">
+      <MainSource>MainSource</MainSource>
+    </DelphiCompile>
+    <DCCReference Include="..\..\src\u_dzClassUtils.pas" />
+    <DCCReference Include="..\..\src\u_dzConvertUtils.pas" />
+    <DCCReference Include="..\..\src\u_dzDateUtils.pas" />
+    <DCCReference Include="..\..\src\u_dzFileUtils.pas" />
+    <DCCReference Include="..\..\src\u_dzMiscUtils.pas" />
+    <DCCReference Include="..\..\src\u_dzStringUtils.pas" />
+    <DCCReference Include="..\..\src\u_dzTranslator.pas" />
+    <DCCReference Include="..\..\src\u_dzUnitTestUtils.pas" />
+    <DCCReference Include="..\..\src\u_dzVariantUtils.pas" />
+    <DCCReference Include="Testu_dzClassUtils.pas" />
+    <DCCReference Include="Testu_dzConvertUtils.pas" />
+    <DCCReference Include="Testu_dzFileUtils.pas" />
+  </ItemGroup>
+</Project>
\ No newline at end of file

Added: utilities/dzLib/trunk/tests/src/Testu_dzClassUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/src/Testu_dzClassUtils.pas	2007-12-16 15:35:48 UTC (rev 257)
+++ utilities/dzLib/trunk/tests/src/Testu_dzClassUtils.pas	2007-12-16 15:42:58 UTC (rev 258)
@@ -0,0 +1,196 @@
+unit Testu_dzClassUtils;
+
+interface
+uses
+  Windows,
+  Classes,
+  SysUtils,
+  TestFramework,
+  u_dzClassUtils,
+  u_dzUnitTestUtils;
+
+type
+  TestTStringsUtils = class(TdzTestCase)
+  private
+    FCounter: Integer;
+  protected
+    FList: TStringList;
+  public
+    procedure SetUp; override;
+    procedure TearDown; override;
+  published
+    procedure TestTStrings_RemoveTrailingSpaces;
+    procedure TestTStrings_FreeWithObjects;
+    procedure TestTStrings_FreeAllObjects;
+    procedure TestTStrings_DeleteAndFreeObject;
+    procedure TestTStrings_StringByObj;
+    procedure TestTStrings_TryStringByObj;
+  end;
+
+type
+  TestTStreamUtils = class(TdzTestCase)
+  protected
+    FStream: TStringStream;
+  public
+    procedure SetUp; override;
+    procedure TearDown; override;
+  published
+    procedure TestTestTStream_WriteString;
+    procedure TestTStream_WriteStringLn;
+    procedure TestTStream_ReadStringLn;
+    procedure TestTStream_WriteFmtLn;
+  end;
+
+implementation
+
+{ TestTStringsUtils }
+
+procedure TestTStringsUtils.SetUp;
+begin
+  inherited;
+  FList := TStringList.Create;
+  FList.Add('a');
+  FList.Add('b ');
+  FList.Add('c');
+  FList.Add('d');
+  FList.Add('e ');
+  FList.Add('f');
+end;
+
+procedure TestTStringsUtils.TearDown;
+begin
+  FList.Free;
+  inherited;
+end;
+
+type
+  TMyObj = class
+  private
+    FCounter: PInteger;
+  public
+    constructor Create(_Counter: PInteger);
+    destructor Destroy; override;
+  end;
+
+{ TMyObj }
+
+constructor TMyObj.Create(_Counter: PInteger);
+begin
+  inherited Create;
+  FCounter := _Counter;
+end;
+
+destructor TMyObj.Destroy;
+begin
+  Inc(FCounter^);
+  inherited;
+end;
+
+procedure TestTStringsUtils.TestTStrings_DeleteAndFreeObject;
+begin
+  FCounter := 0;
+  FList.Objects[0] := TMyObj.Create(@FCounter);
+  TStrings_DeleteAndFreeObject(FList, 0);
+  CheckEquals(1, FCounter, 'Destructor has not been called');
+end;
+
+procedure TestTStringsUtils.TestTStrings_FreeAllObjects;
+begin
+  FCounter := 0;
+  FList.Objects[0] := TMyObj.Create(@FCounter);
+  FList.Objects[2] := TMyObj.Create(@FCounter);
+  FList.Objects[3] := TMyObj.Create(@FCounter);
+  FList.Objects[4] := TMyObj.Create(@FCounter);
+  TStrings_FreeAllObjects(FList);
+  CheckEquals(4, FCounter, 'Destructor has not been called 4 times');
+end;
+
+procedure TestTStringsUtils.TestTStrings_FreeWithObjects;
+var
+  List: TStringList;
+begin
+  FCounter := 0;
+  List := FList;
+  FList := nil;
+  List.Objects[0] := TMyObj.Create(@FCounter);
+  List.Objects[2] := TMyObj.Create(@FCounter);
+  List.Objects[3] := TMyObj.Create(@FCounter);
+  List.Objects[4] := TMyObj.Create(@FCounter);
+  TStrings_FreeWithObjects(List);
+  CheckEquals(4, FCounter, 'Destructor has not been called 4 times');
+end;
+
+procedure TestTStringsUtils.TestTStrings_RemoveTrailingSpaces;
+begin
+  TStrings_RemoveTrailingSpaces(FList);
+  CheckEqualsMultiline('a'#13#10'b'#13#10'c'#13#10'd'#13#10'e'#13#10'f'#13#10,
+    FList.Text);
+end;
+
+procedure TestTStringsUtils.TestTStrings_StringByObj;
+var
+  MyObj: TMyObj;
+begin
+  MyObj := TMyObj.Create(@FCounter);
+  FList.Objects[3] := MyObj;
+  CheckEquals('d', TStrings_StringByObj(FList, MyObj));
+end;
+
+procedure TestTStringsUtils.TestTStrings_TryStringByObj;
+var
+  MyObj: TMyObj;
+  s: string;
+begin
+  MyObj := TMyObj.Create(@FCounter);
+  FList.Objects[3] := MyObj;
+  CheckTrue(TStrings_TryStringByObj(FList, MyObj, s));
+  CheckEquals('d', s);
+end;
+
+{ TestTStreamUtils }
+
+procedure TestTStreamUtils.SetUp;
+begin
+  inherited;
+  FStream := TStringStream.Create('hello world'#13#10);
+  FStream.Seek(0, soEnd);
+end;
+
+procedure TestTStreamUtils.TearDown;
+begin
+  FStream.Free;
+  inherited;
+end;
+
+procedure TestTStreamUtils.TestTestTStream_WriteString;
+begin
+  TStream_WriteString(FStream, 'hello again');
+  CheckEquals('hello world'#13#10'hello again', FStream.DataString);
+end;
+
+procedure TestTStreamUtils.TestTStream_ReadStringLn;
+var
+  s: string;
+begin
+  FStream.Seek(0, soBeginning);
+  CheckEquals(11, TStream_ReadStringLn(FStream, s));
+  CheckEquals('hello world', s);
+end;
+
+procedure TestTStreamUtils.TestTStream_WriteFmtLn;
+begin
+  TStream_WriteFmtLn(FStream, 'hello %s', ['again']);
+  CheckEquals('hello world'#13#10'hello again'#13#10, FStream.DataString);
+end;
+
+procedure TestTStreamUtils.TestTStream_WriteStringLn;
+begin
+  TStream_WriteStringLn(FStream, 'hello again');
+  CheckEquals('hello world'#13#10'hello again'#13#10, FStream.DataString);
+end;
+
+initialization
+  RegisterTest('ClassUtils', TestTStringsUtils.Suite);
+  RegisterTest('ClassUtils', TestTStreamUtils.Suite);
+end.
+

Copied: utilities/dzLib/trunk/tests/src/Testu_dzConvertUtils.pas (from rev 257, utilities/dzLib/trunk/tests/dzconvertutils/Testu_dzConvertUtils.pas)

Copied: utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas (from rev 257, utilities/dzLib/trunk/tests/dzfileutils/Testu_dzFileUtils.pas)



From twm at mail.berlios.de  Fri Dec 21 22:36:29 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 21 Dec 2007 22:36:29 +0100
Subject: [Dzchart-svncheckins] r259 - in utilities/dzLib/trunk: src tests
	tests/dcu tests/src
Message-ID: <200712212136.lBLLaT8H027554@sheep.berlios.de>

Author: twm
Date: 2007-12-21 22:36:26 +0100 (Fri, 21 Dec 2007)
New Revision: 259

Removed:
   utilities/dzLib/trunk/tests/dzconvertutils/
   utilities/dzLib/trunk/tests/dzfileutils/
Modified:
   utilities/dzLib/trunk/src/u_dzConvertUtils.pas
   utilities/dzLib/trunk/src/u_dzFileUtils.pas
   utilities/dzLib/trunk/tests/dcu/
   utilities/dzLib/trunk/tests/src/
   utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas
Log:
* added more /// comments
* deprecated TFileSystem.DelTree because it had an order of arguments that is inconsistent with the other methods. Replaced by DelDirTree which is consistent
* TFileSystem.BackupFile is now a function that returns the name of the created backup file
* corrected unit test for TFileSystem.MoveFileWithProgress. Since the test was using a file that could be moved by renaming it rather than copying/deleting the callback function is never called and therefore cannot cancel the operation. So the test actually succeeded all the time while I thought it failed.
* deleted unused subdirs dzconvertutils and dzfileutils

Modified: utilities/dzLib/trunk/src/u_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-12-16 15:42:58 UTC (rev 258)
+++ utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
@@ -139,8 +139,20 @@
 /// </summary>
 function isNumberN(const _s: string; _Base: TBaseN): integer;
 
+/// <summary>
+/// Converts a string of the form '-hh:mm:ss', 'hh:mm:ss',
+/// '+hh:mm:ss', 'mm:ss' or 'ss' to a number of seconds.
+/// </summary>
 function TimeStrToSeconds(const _Zeit: string): integer;
+/// <summary>
+/// deprecated, use SecondsToTimeStr instead
+/// </summary>
 function SecondsToStr(_Seconds: integer): string; deprecated;
+/// <summary>
+/// Converts a number of seconds to a string of the form
+/// 'hh:mm:ss'. The string will always contain hours and minutes
+/// even if Seconds < 60.
+/// </summary>
 function SecondsToTimeStr(_Seconds: integer): string;
 {$IFDEF Delphi7up}
 function TimeToSeconds(_Zeit: TDateTime): integer; deprecated;
@@ -221,6 +233,14 @@
 /// @returns true, if s could be converted, false otherwise }
 /// </summary>
 function TryStr2Float(_s: string; out _flt: extended; _DecSeparator: char = '.'): boolean; overload;
+/// <summary>
+/// tries to convert a string to a float, returns false if it fails
+/// @param s is the string to convert
+/// @param flt is the float, only valid if the function returns true
+/// @param DecSeparator is the decimal separator to use, defaults to '.',
+///        if passed as #0, GuessDecimalSeparator is called to guess it
+/// @returns true, if s could be converted, false otherwise }
+/// </summary>
 function TryStr2Float(_s: string; out _flt: double; _DecSeparator: char = '.'): boolean; overload;
 
 /// <summary>
@@ -252,6 +272,12 @@
 /// </summary>
 function Float2Str(_flt: extended; _Decimals: integer): string; overload;
 
+/// <summary>
+/// Tries to round a floating point value to a word value
+/// @param flt is the value to convert
+/// @param wrd returns the word value, only valid if result = true
+/// @returns true, if the result can be stored i a word, false otherwise.
+/// </summary>
 function TryRound(_flt: extended; out _wrd: word): boolean;
 
 /// <summary>
@@ -286,9 +312,12 @@
 function SecondsToHumanReadableString(_Seconds: Int64): string;
 
 /// <summary>
+/// returns the default locale settings as read from the user's regional settings }
+/// </summary>
+function GetUserDefaultLocaleSettings: TFormatSettings;
+/// <summary>
 /// returns the default locale settings as read from the system's regional settings }
 /// </summary>
-function GetUserDefaultLocaleSettings: TFormatSettings;
 function GetSystemDefaultLocaleSettings: TFormatSettings;
 
 implementation

Modified: utilities/dzLib/trunk/src/u_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-16 15:42:58 UTC (rev 258)
+++ utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
@@ -70,7 +70,7 @@
     /// MustHaveAttr is set to [] and MayHaveAttr is set to include all possible
     /// attributes, so calling FindNext will find any files or subdirectories,
     /// but the special '.' and '..' directories
-    /// @param(Mask is the file search mask)
+    /// @param Mask is the file search mask
     /// </summary>
     constructor Create(const _Mask: string);
     /// <summary>
@@ -94,7 +94,7 @@
     /// calls. If it returns true, use the SR property to get information about
     /// the file. See the overloaded @link(FindNext) version if you need only
     /// the filename.
-    /// @Returns(true, if a matching file was found, false otherwise)
+    /// @Returns true, if a matching file was found, false otherwise
     /// </summary>
     function FindNext: boolean; overload;
     /// <summary>
@@ -110,6 +110,7 @@
     /// properties (e.g. Mask, MustHaveAttr, MayHaveAttr)
     /// </summary>
     procedure Reset;
+    /// <summary>
     /// Returns the number of matches so far, that is the number of successful
     /// calls to FindNext
     /// </summary>
@@ -145,16 +146,16 @@
     /// possible return values for the callback function
     /// </summary>
     TProgressResult = (
-      prContinue, /// < continue with the copy/move operation
-      prCancel,   /// < cancel the operation, cannot be resumed
-      prStop,     /// < stop the operation, can be resumed, if cfwRestartable was passed
-      prQuiet);   /// < continue the operation, do not call the callback
+      prContinue, // continue with the copy/move operation
+      prCancel,   // cancel the operation, cannot be resumed
+      prStop,     // stop the operation, can be resumed, if cfwRestartable was passed
+      prQuiet);   // continue the operation, do not call the callback
     /// <summary>
     /// reason for calling the callback function
     /// </summary>
     TProgressReason = (
-      prChunkFinished, /// < a chunk of the file has been copied
-      prStreamSwitch); /// < started to copy a new stream (set in the first callback)
+      prChunkFinished, // a chunk of the file has been copied
+      prStreamSwitch); // started to copy a new stream (set in the first callback)
   {*)}
   protected
     FTotalFileSize: LARGE_INTEGER;
@@ -349,6 +350,7 @@
     /// @returns a string with the TEMP directory
     /// </summary>
     class function GetTempPath: string;
+
     /// <summary>
     /// Moves the file Source to Dest using the Windows MoveFile function.
     /// @param Source is a string containing the name of the existing file
@@ -360,6 +362,7 @@
     /// @returns true, if the file could be moved, false otherwise.
     /// </summary>
     class function MoveFile(const _Source, _Dest: string; _RaiseException: boolean = true): boolean;
+
     /// <summary>
     /// Copies the file Source to Dest using the Windows CopyFile function.
     /// @param Source is a string containing the name of the existing file
@@ -373,61 +376,67 @@
     /// @param ForceOverwrite is a boolean which controls whether the function removes
     ///        a read-only flag from the destination file if necessary.
     /// @returns true, if the file could be copied, false otherwise.
+    /// @raises  EOSError if an error occurs and cfwRaiseException was passed
     /// </summary>
     class function CopyFile(const _Source, _Dest: string; _FailIfExists: boolean = true;
       _RaiseException: boolean = true; _ForceOverwrite: boolean = false): boolean; overload;
+
     /// <summary>
     /// Copies the file Source to Dest using the Windows CopyFile function.
-    /// @param(Source is a string containing the name of the existing file)
-    /// @param(Dest is a string containing the destination file name)
-    /// @param(Flags is a set of TCopyFileFlags specifying whether the copy operation
+    /// @param Source is a string containing the name of the existing file
+    /// @param Dest is a string containing the destination file name
+    /// @param Flags is a set of TCopyFileFlags specifying whether the copy operation
     ///        cfFailIfExists: fail if the destination file already exists.
     ///        cfForceOverwrite: remove a read-only flag from the destination file if necessary.
     ///        cfRaiseException: retrieve the Windows error and raise an exception if it fails.
     ///          If not set, it will not raise an exception but just return false if
-    ///          copying the file fails.)
-    /// @returns(true, if the file could be copied, false otherwise.)
+    ///          copying the file fails.
+    /// @returns true, if the file could be copied, false otherwise.
+    /// @raises  EOSError if an error occurs and cfwRaiseException was passed
     /// </summary>
     class function CopyFile(const _Source, _Dest: string;
       _Flags: TCopyFileFlagSet = [cfRaiseException]): boolean; overload;
+
     /// <summary>
     /// Copies the file Source to Dest using the Windows CopyFileEx function which
     /// allows for a progress callback
-    /// @param(Source is a string containing the name of the existing file)
-    /// @param(Dest is a string containing the destination file name)
-    /// @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
+    /// @param Source is a string containing the name of the existing file
+    /// @param Dest is a string containing the destination file name
+    /// @param Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
     ///        cfwFailIfExists: fail if the destination file already exists.
     ///        cfwRestartable: stores information in the destination file that allows
     ///          to restart a stopped copy operation
     ///        cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
     ///          If not set, it will not raise an exception but just return cfwAborted
-    ///          or cfwError if copying the file fails. (set by default))
+    ///          or cfwError if copying the file fails. (set by default)
     /// @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
     ///          stopped in the callback function and cfeError on any other error.
     /// @raises  EOSError if an error occurs and cfwRaiseException was passed
     /// </summary>
     class function CopyFileWithProgress(const _Source, _Dest: string; _Progress: TCopyFileProgressEvt;
       _Flags: TCopyFileWithProgressFlagSet = [cfwRaiseException]): TCopyFileWithProgressResult;
+
     /// <summary>
     /// Copies the file Source to Dest using the Windows MoveFileWithProgress function which
     /// allows for a progress callback
     /// NOTE: If the file can be moved rather than copied, no call to the callback
     ///       function will occur!
-    /// @param(Source is a string containing the name of the existing file)
-    /// @param(Dest is a string containing the destination file name)
-    /// @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
+    /// @param Source is a string containing the name of the existing file
+    /// @param Dest is a string containing the destination file name
+    /// @param Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
     ///        cfwFailIfExists: fail if the destination file already exists.
     ///        cfwRestartable: stores information in the destination file that allows
     ///          to restart a stopped copy operation
     ///        cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
     ///          If not set, it will not raise an exception but just return cfwAborted
-    ///          or cfwError if copying the file fails. (set by default))
+    ///          or cfwError if copying the file fails. (set by default)
     /// @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
     ///          stopped in the callback function and cfeError on any other error.
     /// @raises  EOSError if an error occurs and cfwRaiseException was passed
     /// </summary>
     class function MoveFileWithProgress(const _Source, _Dest: string; _Progress: TCopyFileProgressEvt;
       _Flags: TMoveFileWithProgressFlagSet = [mfwRaiseException]): TCopyFileWithProgressResult;
+
     /// <summary>
     /// Creates a directory (parent directories must already exist)
     /// @param DirectoryName is the name for the new directory
@@ -436,6 +445,7 @@
     /// @raises EOSError if there was an error and RaiseException was true
     /// </summary>
     class function CreateDir(const _DirectoryName: string; _RaiseException: boolean = true): boolean;
+
     /// <summary>
     /// Creates a new directory, including the creation of parent directories as needed.
     /// @param DirectoryPath is the name for the new directory
@@ -444,25 +454,32 @@
     /// @raises EOSError if there was an error and RaiseException was true
     /// </summary>
     class function ForceDir(const _DirectoryPath: string; _RaiseException: boolean = true): boolean;
+
     /// <summary>
     /// Sets a file's readonly flag
     /// @param Filename is the file to change
     /// @param Set determines whether to set or clear the flag
+    /// @returns true, if the readonly flag has been changed
+    /// @raises EOSError if there was an error and RaiseException was true
     /// </summary>
     class function SetReadonly(const _Filename: string; _Set: boolean; _RaiseException: boolean = true): boolean;
+
     /// <summary>
     /// Deletes the file using the SysUtils.DeleteFile function.
     /// @param Filename is a string containing the name of the file
     /// @param RaiseException is a boolean which controls whether the function
     ///        retrieves the Windows error and raises an exception
     ///        if it fails. If false, it will not raise an exception
-    ///        but just return false if moving the file fails. 
+    ///        but just return false if moving the file fails.
     /// @param Force is a boolean which controls whether this function will try to delete
     ///        readonly files, If true, it will use SetFileAttr to reset the
     ///        readonly attribut and try to delete the file again.
     /// @returns true, if the file could be deleted, false otherwise.
+    /// @raises EOSError if there was an error and RaiseException was true
     /// </summary>
-    class function DeleteFile(const _Filename: string; _RaiseException: boolean = true; _Force: boolean = false): boolean;
+    class function DeleteFile(const _Filename: string; _RaiseException: boolean = true;
+      _Force: boolean = false): boolean;
+
     /// <summary>
     /// Deletes all files in a directory matching a given filemask (non-recursive)
     /// @param Dir is a string containting the directory in which the files are to be
@@ -477,9 +494,11 @@
     ///              readonly files, If true, it will use SetFileAttr to reset the
     ///              readonly attribut and try to delete the file again.
     /// @returns the number of files that could not be deleted.
+    /// @raises EOSError if there was an error and RaiseException was true
     /// </summary>
     class function DeleteMatchingFiles(const _Dir, _Mask: string;
       _RaiseException: boolean = true; _Force: boolean = false): integer;
+
     /// <summary>
     /// tries to find a matching file
     /// @param Mask is the filename mask to match
@@ -488,20 +507,53 @@
     ///          describing the type of the file which has been found
     /// </summary>
     class function FindMatchingFile(const _Mask: string; out _Filename: string): TMatchingFileResult;
+
+    /// <summary>
+    /// deletes an empty directory using the SysUtils function RemoveDir
+    /// The function will fail if the directory is not empty.
+    /// @param DirName is the name of the directory to delete
+    /// @param RaiseExceptin is a boolean which controls whether the function
+    ///                      retrieves the Windows error and raises an exception
+    ///                      if it fails. If false, it will not raise an exception
+    ///                      but just return false if deleting the directory fails.
+    /// @param Force is a boolean which controls whether this function will try to delete
+    ///              readonly directories, If true, it will use SetFileAttr to reset the
+    ///              readonly attribut and try to delete the directory again.
+    /// @returns true, if the directory could be deleted, false otherwise.
+    /// @raises EOSError if there was an error and RaiseException was true
+    /// </summary>
     class function RemoveDir(const _Dirname: string; _RaiseException: boolean = true;
       _Force: boolean = false): boolean;
+
     /// <summary>
+    /// function is deprecated, use DelDirTree instead!
+    /// Note the different order of parameters of the new function!
+    /// </summary>
+    class function DelTree(const _Dirname: string; _Force: boolean = false;
+      _RaiseException: boolean = true): boolean; deprecated;
+    /// <summary>
     /// Deletes a directory with all files and subdirectories.
-    /// @param(Dirname is the name of the directory to delete)
-    /// @param(Force specifies whether it should also delete readonly files)
+    /// Note: This new function has a different order of parameters than
+    ///       the old DelTree function.
+    /// @param Dirname is the name of the directory to delete
+    /// @param RaiseExceptin is a boolean which controls whether the function
+    ///                      retrieves the Windows error and raises an exception
+    ///                      if it fails. If false, it will not raise an exception
+    ///                      but just return false if deleting the directory fails.
+    /// @param Force specifies whether it should also delete readonly files
+    /// @returns true, if the directory could be deleted, false otherwise.
+    /// @raises EOSError if there was an error and RaiseException was true
     /// </summary>
-    class function DelTree(const _Dirname: string; _Force: boolean = false; _RaiseException: boolean = true): boolean;
+    class function DelDirTree(const _Dirname: string; _RaiseException: boolean = true;
+      _Force: boolean = false): boolean;
+
     /// <summary>
     /// reads a text file and returns its content as a string
     /// @param Filename is the name of the file to read
     /// @returns the file's content as a string
     /// </summary>
     class function ReadTextFile(const _Filename: string): string;
+
     /// <summary>
     /// checks whether the given string is a valid filename (without path), that is
     /// does not contain one of the characters defined in INVALID_FILENAME_CHARS
@@ -518,15 +570,23 @@
     /// @returns true, if the string is a valid filename, false otherwise
     /// </summary>
     class function IsValidFilename(const _s: string; out _ErrPos: integer): boolean; overload;
+
     /// <summary>
     /// creates a backup of the file appending the current date and time to the base
-    /// file name.
+    /// file name. See also TFileGenerationHandler.
     /// @param Filename is the name of the file to back up
     /// @param BackupDir is a directory in which to create the backup file, if empty
     ///                  the same directory as the original file is used
+    /// @returns the full filename of the created backup file
     /// </summary>
-    class procedure BackupFile(const _Filename: string; _BackupDir: string = '');
+    class function BackupFile(const _Filename: string; _BackupDir: string = ''): string;
+
+    /// <summary>
+    /// @returns a TFileInfoRec containing the filename, filesize and last access
+    ///          timestamp of the file
+    /// </summary>
     class function GetFileInfo(const _Filename: string): TFileInfoRec;
+
     /// <summary>
     /// Returns the free space (in bytes) on the disk with the given drive letter
     /// </summary>
@@ -540,7 +600,7 @@
   TOnGenerateFilename = procedure(_Sender: TObject; _Generation: integer; var _Filename: string) of object;
 type
   /// <summary>
-  /// This class handles keeping gernations of files, e.g. log files. The default
+  /// This class handles keeping generations of files, e.g. log files. The default
   /// is to keep 10 generations
   /// </summary>
   TFileGenerationHandler = class
@@ -558,7 +618,8 @@
     /// @param BaseName is the base filename to which by default _<n> followed by
     ///                 the Suffix will be appended
     /// @param Suffix is the suffix for the filename, usually an extension which
-    ///               must include the dot (.)
+    ///               must include the dot (.), but it is also possible to pass
+    ///               an arbitrary string like '_backup'.
     /// </summary>
     constructor Create(const _BaseName, _Suffix: string);
     /// <summary>
@@ -925,7 +986,7 @@
   end;
 end;
 
-class procedure TFileSystem.BackupFile(const _Filename: string; _BackupDir: string = '');
+class function TFileSystem.BackupFile(const _Filename: string; _BackupDir: string = ''): string;
 var
   Ext: string;
   FilenameOnly: string;
@@ -937,7 +998,8 @@
   FilenameOnly := ExtractFileName(_Filename);
   Ext := ExtractFileExt(FilenameOnly);
   Base := ChangeFileExt(FilenameOnly, '');
-  CopyFile(_Filename, _BackupDir + Base + '_' + ReplaceChars(DateTime2Iso(now, true), ': ', '-_') + Ext, true);
+  Result := _BackupDir + Base + '_' + ReplaceChars(DateTime2Iso(now, true), ': ', '-_') + Ext;
+  CopyFile(_Filename, Result, true);
 end;
 
 class function TFileSystem.CopyFile(const _Source, _Dest: string; _Flags: TCopyFileFlagSet): boolean;
@@ -1179,6 +1241,12 @@
 end;
 
 class function TFileSystem.DelTree(const _Dirname: string; _Force: boolean = false; _RaiseException: boolean = true): boolean;
+begin
+  Result := DelDirTree(_Dirname, _RaiseException, _Force);
+end;
+
+class function TFileSystem.DelDirTree(const _Dirname: string; _RaiseException,
+  _Force: boolean): boolean;
 var
   sr: TSearchRec;
   Filename: string;


Property changes on: utilities/dzLib/trunk/tests/dcu
___________________________________________________________________
Name: svn:ignore
   + *.dcu



Property changes on: utilities/dzLib/trunk/tests/src
___________________________________________________________________
Name: svn:ignore
   + DUnitTests_dzLib.res


Modified: utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas	2007-12-16 15:42:58 UTC (rev 258)
+++ utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
@@ -173,7 +173,7 @@
 
 procedure TFileSystemTestCase.TearDown;
 begin
-  TFileSystem.DelTree(FTestDir);
+  TFileSystem.DelDirTree(FTestDir);
   inherited;
 end;
 
@@ -232,8 +232,11 @@
   Res: TFileSystem.TCopyFileWithProgressResult;
 begin
   Res := TFileSystem.MoveFileWithProgress(FSourceFile, FDestFile, ProgressCancel, []);
-  Check(Res = cfwOK, 'aborted expected');
-  CheckFalse(FileExists(FDestFile), 'destination file exists');
+  // Note: This move operation does not get cancelled because the file can be
+  // renamed rather than copied and deleted. In that case the callback function
+  // is never being called.
+  Check(Res = cfwOK, 'OK expected');
+  CheckTrue(FileExists(FDestFile), 'destination file exists');
 end;
 
 procedure TestTFileSystem.TestCopyFileWithProgressCancel;



From twm at mail.berlios.de  Sat Dec 22 15:08:14 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sat, 22 Dec 2007 15:08:14 +0100
Subject: [Dzchart-svncheckins] r260 - in utilities/dzLib/trunk: src tests/src
Message-ID: <200712221408.lBME8E8n003751@sheep.berlios.de>

Author: twm
Date: 2007-12-22 15:08:00 +0100 (Sat, 22 Dec 2007)
New Revision: 260

Added:
   utilities/dzLib/trunk/tests/src/Testu_dzDateUtils.pas
Modified:
   utilities/dzLib/trunk/src/u_dzDateUtils.pas
   utilities/dzLib/trunk/src/u_dzFileUtils.pas
   utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas
   utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr
   utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj
   utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas
Log:
* added more comments
* Bugfix: forgot to replace a call to DelTree with DelDirTree
* removed Overload declarations from TdzTestCase methods
* added a SuitePath to the dzFileUtils tests
* added unit tests for dzDateUtils

Modified: utilities/dzLib/trunk/src/u_dzDateUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzDateUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
+++ utilities/dzLib/trunk/src/u_dzDateUtils.pas	2007-12-22 14:08:00 UTC (rev 260)
@@ -1,12 +1,36 @@
 {GXFormatter.config=twm}
+/// implements some utility functions for converting TDateTime to and from strings
+/// in ISO 6801 format (note that these function do not implement the complete
+/// standard but only the extended form without omitting date parts.
 unit u_dzDateUtils;
 
 {$i jedi.inc}
 
 interface
 
-function DateTime2Iso(_dt: TDateTime; _IncludeTime: boolean = false): string;
+/// <summary>
+/// Converts a TDateTime value to a string in ISO 8601 format
+/// @param dt is the TDateTime value to convert
+/// @param IncludeTime is a boolean that determines whether the time should be
+///                    included, defaults to false
+/// @returns a string with the date (and optionally the time) in the format
+///          'yyyy-mm-dd hh:mm:ss'
+/// </summary>
+function DateTime2Iso(_dt: TDateTime; _IncludeTime: boolean = false): string; inline;
+
+/// <summary>
+/// converts a string that contains a time in ISO 8601 format to a TDateTime value
+/// @param s is the string to convert, it must be in the form 'hh:mm:ss' or 'hh:mm'
+/// @returns a TDateTime value with the time
+/// </summary>
 function Iso2Time(_s: string): TDateTime;
+
+/// <summary>
+/// converts a string that contains a date in ISO 8601 format to a TDateTime value
+/// @param s is the string to convert, it must be in the form 'yyyy-mm-dd', it must
+///          not contain a time
+/// @returns a TDateTime value with the date
+/// </summary>
 function Iso2Date(_s: string): TDateTime;
 
 implementation

Modified: utilities/dzLib/trunk/src/u_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
+++ utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-22 14:08:00 UTC (rev 260)
@@ -1265,7 +1265,7 @@
         end else begin
           Filename := IncludeTrailingPathDelimiter(_Dirname) + sr.Name;
           if (sr.Attr and SysUtils.faDirectory) <> 0 then begin
-            Result := DelTree(Filename, _Force, _RaiseException);
+            Result := DelDirTree(Filename, _RaiseException, _Force);
             if not Result then
               exit;
           end else begin

Modified: utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
+++ utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas	2007-12-22 14:08:00 UTC (rev 260)
@@ -21,31 +21,31 @@
     /// <summary>
     /// Checks whether the value is a variant of a floating point type (includes integer)
     /// </summary>
-    procedure CheckVariantIsFloat(_Value: variant; _Msg: string);
+    procedure CheckVariantIsFloat(_Value: variant; _Msg: string = '');
     /// <summary>
     /// Checks whether the value is a variant of an (signed) integer type (excludes LongWord and Int64)
     /// </summary>
-    procedure CheckVariantIsInteger(_Value: variant; _Msg: string);
+    procedure CheckVariantIsInteger(_Value: variant; _Msg: string = '');
     /// <summary>
     /// Checks whether the value is a variant of an (signed) int64 type (includes LongWord and Int64)
     /// </summary>
-    procedure CheckVariantIsInt64(_Value: variant; _Msg: string);
+    procedure CheckVariantIsInt64(_Value: variant; _Msg: string = '');
     /// <summary>
     /// Checks whether the value is a variant of an (unsigned) integer type (excludes all signed integer types)
     /// </summary>
-    procedure CheckVariantIsLongWord(_Value: variant; _Msg: string);
+    procedure CheckVariantIsLongWord(_Value: variant; _Msg: string = '');
     /// <summary>
     /// Checks whether the value is a non Null variant
     /// </summary>
-    procedure CheckVariantIsNotNull(_Value: variant; _Msg: string); overload;
+    procedure CheckVariantIsNotNull(_Value: variant; _Msg: string = '');
     /// <summary>
     /// Checks whether the value is a Null variant
     /// </summary>
-    procedure CheckVariantIsNull(_Value: variant; _Msg: string); overload;
+    procedure CheckVariantIsNull(_Value: variant; _Msg: string = '');
     /// <summary>
     /// Checks whether the value is a variant of a string type
     /// </summary>
-    procedure CheckVariantIsString(_Value: variant; _Msg: string); overload;
+    procedure CheckVariantIsString(_Value: variant; _Msg: string='');
     /// <summary>
     /// Called by the CheckVAriantIsXxxx functions to show errors
     /// </summary>
@@ -57,15 +57,15 @@
     /// <summary>
     /// Checks whether the date part of two TDateTime values is equal
     /// </summary>
-    procedure CheckEqualsDate(_Expected, _Actual: TDateTime; const _Message: string);
+    procedure CheckEqualsDate(_Expected, _Actual: TDateTime; const _Message: string = '');
     /// <summary>
     /// Checks whether two TDateTime values are equal
     /// </summary>
-    procedure CheckEqualsDateTime(_Expected, _Actual: TDateTime; const _Message: string);
+    procedure CheckEqualsDateTime(_Expected, _Actual: TDateTime; const _Message: string = '');
     /// <summary>
     /// Checks whether the time part of two TDateTime values is equal
     /// </summary>
-    procedure CheckEqualsTime(_Expected, _Actual: TDateTime; const _Message: string);
+    procedure CheckEqualsTime(_Expected, _Actual: TDateTime; const _Message: string = '');
     /// <summary>
     /// Checks multiline strings for equality
     /// </summary>

Modified: utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr
===================================================================
--- utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr	2007-12-21 21:36:26 UTC (rev 259)
+++ utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr	2007-12-22 14:08:00 UTC (rev 260)
@@ -25,12 +25,12 @@
   u_dzStringUtils in '..\..\src\u_dzStringUtils.pas',
   u_dzConvertUtils in '..\..\src\u_dzConvertUtils.pas',
   u_dzTranslator in '..\..\src\u_dzTranslator.pas',
-  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas',
   u_dzUnitTestUtils in '..\..\src\u_dzUnitTestUtils.pas',
   u_dzVariantUtils in '..\..\src\u_dzVariantUtils.pas',
   Testu_dzConvertUtils in 'Testu_dzConvertUtils.pas',
-  Testu_dzClassUtils in 'Testu_dzClassUtils.pas',
-  u_dzClassUtils in '..\..\src\u_dzClassUtils.pas';
+  Testu_dzDateUtils in 'Testu_dzDateUtils.pas',
+  u_dzClassUtils in '..\..\src\u_dzClassUtils.pas',
+  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas';
 
 {$R *.RES}
 

Modified: utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj
===================================================================
--- utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj	2007-12-21 21:36:26 UTC (rev 259)
+++ utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj	2007-12-22 14:08:00 UTC (rev 260)
@@ -52,8 +52,8 @@
     <DCCReference Include="..\..\src\u_dzTranslator.pas" />
     <DCCReference Include="..\..\src\u_dzUnitTestUtils.pas" />
     <DCCReference Include="..\..\src\u_dzVariantUtils.pas" />
-    <DCCReference Include="Testu_dzClassUtils.pas" />
     <DCCReference Include="Testu_dzConvertUtils.pas" />
+    <DCCReference Include="Testu_dzDateUtils.pas" />
     <DCCReference Include="Testu_dzFileUtils.pas" />
   </ItemGroup>
 </Project>
\ No newline at end of file

Added: utilities/dzLib/trunk/tests/src/Testu_dzDateUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/src/Testu_dzDateUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
+++ utilities/dzLib/trunk/tests/src/Testu_dzDateUtils.pas	2007-12-22 14:08:00 UTC (rev 260)
@@ -0,0 +1,46 @@
+unit Testu_dzDateUtils;
+
+interface
+
+uses
+  Windows,
+  Classes,
+  SysUtils,
+  TestFramework,
+  u_dzDateUtils,
+  u_dzUnitTestUtils;
+
+type
+  TestDateUtils = class(TdzTestCase)
+  published
+    procedure TestDateTime2Iso;
+    procedure TestIso2Date;
+    procedure TestIso2Time;
+  end;
+
+implementation
+
+{ TestDateUtils }
+
+procedure TestDateUtils.TestDateTime2Iso;
+begin
+  CheckEquals('1966-05-05', DateTime2Iso(EncodeDate(1966, 5, 5)));
+  CheckEquals('2000-01-31', DateTime2Iso(EncodeDate(2000, 1, 31)));
+  CheckEquals('1966-05-05 20:15:01', DateTime2Iso(EncodeDate(1966, 5, 5) + EncodeTime(20, 15, 1, 0), true));
+end;
+
+procedure TestDateUtils.TestIso2Date;
+begin
+  CheckEqualsDate(EncodeDate(1966, 5, 5), Iso2Date('1966-05-05'));
+end;
+
+procedure TestDateUtils.TestIso2Time;
+begin
+  CheckEqualsTime(EncodeTime(20, 15, 1, 0), Iso2Time('20:15:01'));
+  CheckEqualsTime(EncodeTime(20, 15, 0, 0), Iso2Time('20:15'));
+end;
+
+initialization
+  RegisterTest(TestDateUtils.Suite);
+end.
+

Modified: utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas	2007-12-21 21:36:26 UTC (rev 259)
+++ utilities/dzLib/trunk/tests/src/Testu_dzFileUtils.pas	2007-12-22 14:08:00 UTC (rev 260)
@@ -797,13 +797,13 @@
 end;
 
 initialization
-  RegisterTest(TestTFileSystem.Suite);
-  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.Suite);
-  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.Suite);
-  RegisterTest(TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.Suite);
-  RegisterTest(TestTDirectorySync.Suite);
+  RegisterTest('FileUtils', TestTFileSystem.Suite);
+  RegisterTest('FileUtils\Generations', TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
+  RegisterTest('FileUtils\Generations', TestTFileGenerationHandler_OldestIsHighest_NotResultContainsNumber_Keep.Suite);
+  RegisterTest('FileUtils\Generations', TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_NotKeep.Suite);
+  RegisterTest('FileUtils\Generations', TestTFileGenerationHandler_NotOldestIsHighest_NotResultContainsNumber_Keep.Suite);
+  RegisterTest('FileUtils\Generations', TestTFileGenerationHandler_OldestIsHighest_ResultContainsNumber_NotKeep.Suite);
+  RegisterTest('FileUtils\Generations', TestTFileGenerationHandler_NotOldestIsHighest_ResultContainsNumber_NotKeep.Suite);
+  RegisterTest('FileUtils', TestTDirectorySync.Suite);
 end.
 



From twm at mail.berlios.de  Sat Dec 22 17:57:03 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:57:03 +0100
Subject: [Dzchart-svncheckins] r261 - in utilities/dzLib/trunk: src tests/src
Message-ID: <200712221657.lBMGv3b8012978@sheep.berlios.de>

Author: twm
Date: 2007-12-22 17:56:59 +0100 (Sat, 22 Dec 2007)
New Revision: 261

Added:
   utilities/dzLib/trunk/tests/src/Testu_dzStringUtils.pas
Modified:
   utilities/dzLib/trunk/src/u_dzStringUtils.pas
   utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr
   utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj
Log:
* added unit tests for some dzStringUtils functions
* added comments
* deprecated GetDelStr, use ExtractStr instead
* removed Delphi7Up specific ifdefs, we only support delphi7 and upwards any more (update or don't use dzlib)
* renamed RemoveFileExtIfMatching to RemoveSuffixIfMatching because that is what it does
* removed $IFOPT H- cond. define, we only support AnsiStrings
* Bugfix: RTrimSpaces did not work with empty strings
* StringOf now calls StrUtils.DupeStr


Modified: utilities/dzLib/trunk/src/u_dzStringUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzStringUtils.pas	2007-12-22 14:08:00 UTC (rev 260)
+++ utilities/dzLib/trunk/src/u_dzStringUtils.pas	2007-12-22 16:56:59 UTC (rev 261)
@@ -36,62 +36,132 @@
     '0'..'9', '?', '?', '?', '?', '?', '?', '?'];
   STANDARD_CONTROL_CHARS = [#0..' '];
 
-function GetDelStr(var _Zeile: string; _Del: char): string;
+/// <summary>
+/// function is deprecated, use ExtractStr instead
+/// </summary>
+function GetDelStr(var _Zeile: string; _Del: char): string; deprecated;
 
-{: extracts a substring from the start of Source up to the Delimiter, returns
-   true, if a substring (even an empty one) was found. }
+/// <summary>
+/// extracts the substring from the start of Source up to the Delimiter
+/// </summary>
+function ExtractStr(var _Source: string; _Delimiter: char): string; overload;
+/// <summary>
+/// extracts a substring from the start of Source up to the Delimiter
+/// @returns true, if a substring (even an empty one) was found.
+/// </summary>
 function ExtractStr(var _Source: string; _Delimiters: TCharSet; out _Substr: string): boolean; overload;
+/// <summary>
+/// extracts a substring from the start of Source up to the Delimiter
+/// @returns true, if a substring (even an empty one) was found.
+/// </summary>
 function ExtractStr(var _Source: string; _Delimiter: char; out _Substr: string): boolean; overload;
+/// <summary>
+/// extracts a substring from the start of Source up to the delimiter
+/// @param LastWasDelimiter is a boolean that is to be used in repeated calls
+///                         to the function to tell the next call that the
+///                         last call returned an empty string because there
+///                         was a double delimiter.
+/// Use like this:
+/// b := false;
+/// while ExtractStr(Source, [' ', #9], s, b) do
+///   HandleSubstring(s);
+/// </summary>
 function ExtractStr(var _Source: string; _Delimiters: TCharSet; out _Substr: string; var _LastWasDelimiter: boolean): boolean; overload;
+/// <summary>
+/// extracts a substring from the start of Source up to the delimiter
+/// @param LastWasDelimiter is a boolean that is to be used in repeated calls
+///                         to the function to tell the next call that the
+///                         last call returned an empty string because there
+///                         was a double delimiter.
+/// Use like this:
+/// b := false;
+/// while ExtractStr(Source, [' ', #9], s, b) do
+///   HandleSubstring(s);
+/// </summary>
 function ExtractStr(var _Source: string; _Delimiter: char; out _Substr: string; var _LastWasDelimiter: boolean): boolean; overload;
 
-{: Converts A to lower case. }
+/// <summary>
+/// Converts a char to lower case.
+/// </summary>
 function LoCase(_c: char): char;
+
 // function UpStr(const _s: string): string; // use SysUtils.(Ansi)UpperCase instead
 // function LoStr(const _s: string): string; // use SysUtils.(Ansi)LowerCase instead
 
-{: Entfernt im Gegensatz zu Sysutils.Trim nur Spaces und keine Sonderzeichen }
+/// <summary>
+/// like SysUtils.Trim but only removes spaces, no special characters
+/// </summary>
 function TrimSpaces(const _s: string): string;
-{: Entfernt im Gegensatz zu SysUtils.TrimRight nur Spaces, keine Sonderzeichen }
+/// <summary>
+/// like SysUtils.TrimRight but only removes spaces, no special characters
+/// </summary>
 function RTrimSpaces(const _s: string): string;
-{: Entfernt im Gegensatz zu SysUtils.TrimLeft nur Spaces, keine Sonderzeichen }
+/// <summary>
+/// like SysUtils.TrimLeft but only removes spaces, no special characters
+/// </summary>
 function LTrimSpaces(const _s: string): string;
+type
+  TTrimStr = function(const _s: string): string;
+const
+/// <summary>
+/// function is deprcated, use RTrimSpaces instead, or possibily SysUtils.TrimRight
+/// </summary>
+  RTrimStr: TTrimStr = RTrimSpaces deprecated;
+/// <summary>
+/// function is deprcated, use LTrimSpaces instead, or possibly SysUtils.TrimLeft
+/// </summary>
+  LTrimStr: TTrimStr = LTrimSpaces deprecated;
+/// <summary>
+/// function is deprcated, use TrimSpaces instead, or possibly SysUtils.Trim
+/// </summary>
+  TrimStr: TTrimStr = TrimSpaces deprecated;
 
-{: Creates a string with Anz spaces. }
-function SpaceStr(_Anz: integer): string;
+/// <summary>
+/// Creates a string with Anz spaces.
+/// </summary>
+function SpaceStr(_Cnt: integer): string;
 
-function StringOf(_c: char; _Anz: integer): string;
-{$IFDEF Delphi7up}
-deprecated; // use StrUtils.DupeString
-{$ENDIF}
+/// <summary>
+/// function is deprecated, use StrUtils.DupeString instead
+/// </summary>
+function StringOf(_c: char; _Cnt: integer): string; deprecated;
 
-{: Prepend a backslash to the string if there isn't one already. }
+/// <summary>
+/// Prepend a backslash to the string if there isn't one already.
+/// </summary>
 function PrependBackslash(const _s: string): string;
-{$IFDEF Delphi7up}
 type
   TXxxBackslash = function(const _s: string): string;
 const
+/// <summary>
+/// function is deprecated, use IncludeTrailingPathDelimiter instead
+/// </summary>
   AddBackslash: TXxxBackslash = IncludeTrailingPathDelimiter deprecated;
+/// <summary>
+/// function is deprecated, use ExcludeTrailingPathDelimiter instead
+/// </summary>
   StripBackslash: TXxxBackslash = ExcludeTrailingPathDelimiter deprecated;
-{$ELSE}
-{: Append a backslash to the string if there isn't one already. }
-function AddBackslash(const _s: string): string;
-{: Remove a trailing backslash if there is one. Note that this does also
-   remove a trailing backlash from the root directory ('c:\') which might
-   not be what you want. }
-function StripBackslash(const _s: string): string;
-{$ENDIF}
 
-{: Replaces an existing extension in Name with Ext or adds Ext to Name if
-   it does not have an extension. }
+/// <summary>
+/// Replaces an existing extension in Name with Ext or adds Ext to Name if
+/// it does not have an extension.
+/// </summary>
 function ForceExtension(const _Name, _Ext: string): string;
 {: Returns only the filename (incl. extension) portion of Name. }
 function JustFilename(const _Name: string): string;
-{: removes an extension if it matches the given one
-   @param Filename is the input filename
-   @param Extension is the extension to remove, if the file has it (comparison is case insensitive)
-   @returns the filename without the extension, if it matched, the unchanged filename otherwise }
-function RemoveFileExtIfMatching(const _Filename: string; const _Extension: string): string;
+/// <summary>
+/// function is deprecated (because it did a different thing than the name said)
+/// use RemoveSuffixIfMatching instead
+/// </summary>
+function RemoveFileExtIfMatching(const _s, _Suffix: string): string; deprecated;
+/// <summary>
+/// removes a suffix (can be a file extension, but can also be any arbitrary string)
+/// from a string if it matches the given one
+/// @param s is the input string
+/// @param Suffix is the suffix to remove, if the string has it (comparison is case insensitive)
+/// @returns the string without the suffix, if it matched, the unchanged string otherwise }
+/// </summary>
+function RemoveSuffixIfMatching(const _s, _Suffix: string): string;
 
 {: Appends spaces to the string S to bring it to the given length. If S is
    too long it is truncated, thus the result is guaranteed to be Len characters
@@ -102,15 +172,8 @@
    long. }
 function LPadStr(const _s: string; _Len: integer): string;
 
-type
-  TTrimStr = function(const _s: string): string;
-const
-  RTrimStr: TTrimStr = RTrimSpaces deprecated; // or possibily SysUtils.TrimRight
-  LTrimStr: TTrimStr = LTrimSpaces deprecated; // or possibly SysUtils.TrimLeft
-  TrimStr: TTrimStr = TrimSpaces deprecated; // or possibly SysUtils.Trim
-
-  {: Returns true, if SubStr is found in Str and sets Head to the text before
-     and Tail to the text after SubStr. Otherwise Head and Tail are undefined. }
+{: Returns true, if SubStr is found in Str and sets Head to the text before
+   and Tail to the text after SubStr. Otherwise Head and Tail are undefined. }
 function FindString(const _Substr, _Str: string; var _Head, _Tail: string): boolean;
 
 {: Returns the rightmost position of Sub in S or 0 if Sub is not found in S. }
@@ -326,12 +389,17 @@
     result := TailStr(_Name, p + 1);
 end;
 
-function RemoveFileExtIfMatching(const _Filename: string; const _Extension: string): string;
+function RemoveFileExtIfMatching(const _s, _Suffix: string): string;
 begin
-  if UEndsWith(_Extension, _Filename) then
-    Result := LeftStr(_Filename, Length(_Filename) - Length(_Extension))
+  Result := RemoveSuffixIfMatching(_s, _Suffix);
+end;
+
+function RemoveSuffixIfMatching(const _s, _Suffix: string): string;
+begin
+  if UEndsWith(_Suffix, _s) then
+    Result := LeftStr(_s, Length(_s) - Length(_Suffix))
   else
-    Result := _Filename;
+    Result := _s;
 end;
 
 function nthWordStartAndEnd(const _s: string; _WordNo: integer;
@@ -570,19 +638,9 @@
   (Result + Size)^ := #0;
 end;
 
-{$IFOPT h-}
-var
-  Pas2StrTempStr: string;
-{$ENDIF}
-
 function Pas2Str(var _s: string): PChar;
 begin
-{$IFOPT h+}
-  result := PChar(_s);
-{$ELSE}
-  Pas2StrTempStr := _s + #0;
-  result := @Pas2StrTempStr[1];
-{$ENDIF}
+  Result := PChar(_s);
 end;
 
 function Str2Pas(_p: PChar): string;
@@ -612,7 +670,7 @@
 function RTrimSpaces(const _s: string): string;
 begin
   Result := _s;
-  while NthCharOf(Result, Length(Result)) = ' ' do
+  while (Length(Result) > 0) and  (NthCharOf(Result, Length(Result)) = ' ') do
     System.Delete(Result, Length(Result), 1);
 end;
 
@@ -646,42 +704,17 @@
     Result := '\' + _s;
 end;
 
-{$IFNDEF delphi7up}
-
-function AddBackslash(const _s: string): string;
+function StringOf(_c: char; _Cnt: integer): string;
 begin
-  if RightStr(_s, 1) = '\' then
-    Result := _s
-  else
-    Result := _s + '\';
+  Result := StrUtils.DupeString(_c, _cnt);
 end;
 
-function StripBackslash(const _s: string): string;
+function SpaceStr(_Cnt: integer): string;
 begin
-  if RightStr(_s, 1) = '\' then
-    Result := LeftStr(_s, Length(_s) - 1)
-  else
-    Result := _s;
-end;
-{$ENDIF}
-
-function StringOf(_c: char; _Anz: integer): string;
-var
-  i: integer;
-begin
-  //  SetLength(Result, _Anz);
-  //  FillChar(Result[1], _Anz, _c);
-  Result := '';
-  for i := 1 to _Anz do
-    Result := Result + _c;
-end;
-
-function SpaceStr(_Anz: integer): string;
-begin
 {$IFDEF Delphi7up}
   Result := DupeString(' ', _Anz);
 {$ELSE}
-  Result := StringOf(' ', _Anz);
+  Result := StringOf(' ', _Cnt);
 {$ENDIF}
 end;
 
@@ -754,6 +787,20 @@
   _p^ := #0
 end;
 
+function ExtractStr(var _Source: string; _Delimiter: char): string;
+var
+  p: integer;
+begin
+  p := Pos(_Delimiter, _Source);
+  if p = 0 then begin
+    Result := _Source;
+    _Source := '';
+  end else begin
+    Result := LeftStr(_Source, p - 1);
+    _Source := TailStr(_Source, p + 1);
+  end;
+end;
+
 function ExtractStr(var _Source: string; _Delimiters: TCharSet; out _Substr: string; var _LastWasDelimiter: boolean): boolean;
 var
   p: integer;
@@ -807,17 +854,8 @@
 end;
 
 function GetDelStr(var _Zeile: string; _Del: char): string;
-var
-  p: integer;
 begin
-  p := Pos(_Del, _Zeile);
-  if p = 0 then begin
-    Result := _Zeile;
-    _Zeile := '';
-  end else begin
-    Result := LeftStr(_Zeile, p - 1);
-    _Zeile := TailStr(_Zeile, p + 1);
-  end;
+  Result := ExtractStr(_Zeile, _Del);
 end;
 
 function CenterStr(const _s: string; _MaxLen: integer): string;

Modified: utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr
===================================================================
--- utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr	2007-12-22 14:08:00 UTC (rev 260)
+++ utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dpr	2007-12-22 16:56:59 UTC (rev 261)
@@ -30,7 +30,8 @@
   Testu_dzConvertUtils in 'Testu_dzConvertUtils.pas',
   Testu_dzDateUtils in 'Testu_dzDateUtils.pas',
   u_dzClassUtils in '..\..\src\u_dzClassUtils.pas',
-  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas';
+  u_dzDateUtils in '..\..\src\u_dzDateUtils.pas',
+  Testu_dzStringUtils in 'Testu_dzStringUtils.pas';
 
 {$R *.RES}
 

Modified: utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj
===================================================================
--- utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj	2007-12-22 14:08:00 UTC (rev 260)
+++ utilities/dzLib/trunk/tests/src/DUnitTests_dzLib.dproj	2007-12-22 16:56:59 UTC (rev 261)
@@ -55,5 +55,6 @@
     <DCCReference Include="Testu_dzConvertUtils.pas" />
     <DCCReference Include="Testu_dzDateUtils.pas" />
     <DCCReference Include="Testu_dzFileUtils.pas" />
+    <DCCReference Include="Testu_dzStringUtils.pas" />
   </ItemGroup>
 </Project>
\ No newline at end of file

Added: utilities/dzLib/trunk/tests/src/Testu_dzStringUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/src/Testu_dzStringUtils.pas	2007-12-22 14:08:00 UTC (rev 260)
+++ utilities/dzLib/trunk/tests/src/Testu_dzStringUtils.pas	2007-12-22 16:56:59 UTC (rev 261)
@@ -0,0 +1,391 @@
+unit Testu_dzStringUtils;
+
+interface
+
+uses
+  Windows,
+  Classes,
+  SysUtils,
+  TestFramework,
+  u_dzStringUtils,
+  u_dzUnitTestUtils;
+
+type
+  TestExtractStr = class(TdzTestCase)
+  published
+    procedure TestExtractStr1;
+    procedure TestExtractStr2;
+    procedure TestExtractStr3;
+    procedure TestExtractStr4;
+    procedure TestExtractStr5;
+  end;
+
+type
+  TestTrimSpaces = class(TdzTestCase)
+  published
+    procedure TestTrimSpaces;
+    procedure TestLTrimSpaces;
+    procedure TestRTrimSpaces;
+  end;
+
+type
+  TestMisc = class(TdzTestCase)
+  published
+    procedure TestStringOf;
+    procedure TestSpaceString;
+    procedure TestPrependBackslash;
+  end;
+
+type
+  TestFileExt = class(TdzTestCase)
+  published
+    procedure TestForceExt;
+    procedure TestJustFilename;
+    procedure TestRemoveSuffixIfMatching;
+  end;
+
+implementation
+
+{ TestStringUtils }
+
+procedure TestExtractStr.TestExtractStr1;
+var
+  src: string;
+  s: string;
+begin
+  src := 'hello#world';
+  s := ExtractStr(src, '#');
+  CheckEquals('hello', s);
+  CheckEquals('world', src);
+
+  src := 'helloworld';
+  s := ExtractStr(src, '#');
+  CheckEquals('helloworld', s);
+  CheckEquals('', src);
+
+  src := '';
+  s := ExtractStr(src, '#');
+  CheckEquals('', s);
+  CheckEquals('', src);
+end;
+
+procedure TestExtractStr.TestExtractStr2;
+var
+  src: string;
+  s: string;
+begin
+  src := 'hello#world';
+  CheckTrue(ExtractStr(src, '#', s));
+  CheckEquals('hello', s);
+  CheckEquals('world', src);
+
+  src := 'helloworld';
+  CheckTrue(ExtractStr(src, '#', s));
+  CheckEquals('helloworld', s);
+  CheckEquals('', src);
+
+  src := '';
+  s := 'hello';
+  CheckFalse(ExtractStr(src, '#', s));
+  CheckEquals('', s);
+  CheckEquals('', src);
+end;
+
+procedure TestExtractStr.TestExtractStr3;
+var
+  src: string;
+  s: string;
+  b: boolean;
+  cnt: integer;
+begin
+  src := 'hello#world#';
+  b := false;
+  CheckTrue(ExtractStr(src, '#', s, b));
+  CheckFalse(b);
+  CheckEquals('hello', s);
+  CheckEquals('world#', src);
+  CheckTrue(ExtractStr(src, '#', s, b));
+  CheckTrue(b);
+  CheckEquals('world', s);
+  CheckEquals('', src);
+  CheckTrue(ExtractStr(src, '#', s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+  CheckFalse(ExtractStr(src, '#', s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+
+  src := 'hello##world';
+  b := false;
+  CheckTrue(ExtractStr(src, '#', s, b));
+  CheckFalse(b);
+  CheckEquals('hello', s);
+  CheckEquals('#world', src);
+  CheckTrue(ExtractStr(src, '#', s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('world', src);
+  CheckTrue(ExtractStr(src, '#', s, b));
+  CheckFalse(b);
+  CheckEquals('world', s);
+  CheckEquals('', src);
+  CheckFalse(ExtractStr(src, '#', s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+
+  cnt := 0;
+  src := 'hello#world#';
+  b := false;
+  while ExtractStr(src, '#', s, b) do begin
+    Inc(Cnt);
+  end;
+  CheckEquals(3, Cnt);
+end;
+
+procedure TestExtractStr.TestExtractStr4;
+var
+  src: string;
+  s: string;
+begin
+  src := 'hello#world';
+  CheckTrue(ExtractStr(src, ['#'], s));
+  CheckEquals('hello', s);
+  CheckEquals('world', src);
+
+  src := 'helloworld';
+  CheckTrue(ExtractStr(src, ['#'], s));
+  CheckEquals('helloworld', s);
+  CheckEquals('', src);
+
+  src := '';
+  s := 'hello';
+  CheckFalse(ExtractStr(src, ['#'], s));
+  CheckEquals('', s);
+  CheckEquals('', src);
+
+  src := 'hello#big world';
+  CheckTrue(ExtractStr(src, ['#', ' '], s));
+  CheckEquals('hello', s);
+  CheckEquals('big world', src);
+  CheckTrue(ExtractStr(src, ['#', ' '], s));
+  CheckEquals('big', s);
+  CheckEquals('world', src);
+
+  src := 'hellobigworld';
+  CheckTrue(ExtractStr(src, ['#', ' '], s));
+  CheckEquals('hellobigworld', s);
+  CheckEquals('', src);
+
+  src := '';
+  s := 'hello';
+  CheckFalse(ExtractStr(src, ['#', ' '], s));
+  CheckEquals('', s);
+  CheckEquals('', src);
+end;
+
+procedure TestExtractStr.TestExtractStr5;
+var
+  src: string;
+  s: string;
+  b: boolean;
+  cnt: Integer;
+begin
+  src := 'hello#world';
+  b := false;
+  CheckTrue(ExtractStr(src, ['#'], s, b));
+  CheckFalse(b);
+  CheckEquals('hello', s);
+  CheckEquals('world', src);
+
+  src := 'helloworld';
+  b := false;
+  CheckTrue(ExtractStr(src, ['#'], s, b));
+  CheckFalse(b);
+  CheckEquals('helloworld', s);
+  CheckEquals('', src);
+
+  src := '';
+  s := 'hello';
+  b := false;
+  CheckFalse(ExtractStr(src, ['#'], s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+
+  src := 'hello#big world';
+  b := false;
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('hello', s);
+  CheckEquals('big world', src);
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('big', s);
+  CheckEquals('world', src);
+
+  src := 'hellobigworld';
+  b := false;
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('hellobigworld', s);
+  CheckEquals('', src);
+
+  src := '';
+  s := 'hello';
+  b := false;
+  CheckFalse(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+
+  // this are 5 strings, delimited by ' ' and '#':
+  // 'hello'
+  // 'big'
+  // 'world'
+  // '' (between ' ' and '#')
+  // '' (after the last '#')
+  src := 'hello#big world #';
+  b := false;
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('hello', s);
+  CheckEquals('big world #', src);
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('big', s);
+  CheckEquals('world #', src);
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('world', s);
+  CheckEquals('#', src);
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckTrue(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+  CheckTrue(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+  CheckFalse(ExtractStr(src, ['#', ' '], s, b));
+  CheckFalse(b);
+  CheckEquals('', s);
+  CheckEquals('', src);
+
+  cnt := 0;
+  src := 'hello big#world# ';
+  b := false;
+  while ExtractStr(src, ['#', ' '], s, b) do begin
+    Inc(Cnt);
+  end;
+  CheckEquals(5, Cnt);
+end;
+
+{ TestTrimSpaces }
+
+procedure TestTrimSpaces.TestLTrimSpaces;
+begin
+  CheckEquals('', LTrimSpaces(''));
+  CheckEquals('', LTrimSpaces('   '));
+  CheckEquals('a', LTrimSpaces('   a'));
+  CheckEquals('a b c', LTrimSpaces('   a b c'));
+  CheckEquals('a b c  ', LTrimSpaces('   a b c  '));
+  CheckEquals(#9, LTrimSpaces(#9));
+  CheckEquals(#13#10'a'#13#10'b', LTrimSpaces('  '#13#10'a'#13#10'b'));
+end;
+
+procedure TestTrimSpaces.TestRTrimSpaces;
+begin
+  CheckEquals('', TrimSpaces(''));
+  CheckEquals('', TrimSpaces('   '));
+  CheckEquals('a', TrimSpaces('   a'));
+  CheckEquals('a b c', TrimSpaces('   a b c'));
+  CheckEquals('a b c', TrimSpaces('   a b c  '));
+  CheckEquals(#9, TrimSpaces(#9));
+  CheckEquals(#13#10'a'#13#10'b', TrimSpaces('  '#13#10'a'#13#10'b'));
+  CheckEquals(#13#10'a'#13#10'b', TrimSpaces('  '#13#10'a'#13#10'b '));
+end;
+
+procedure TestTrimSpaces.TestTrimSpaces;
+begin
+  CheckEquals('', RTrimSpaces(''));
+  CheckEquals('', RTrimSpaces('   '));
+  CheckEquals('a', RTrimSpaces('a   '));
+  CheckEquals('a b c', RTrimSpaces('a b c   '));
+  CheckEquals('   a b c', RTrimSpaces('   a b c  '));
+  CheckEquals(#9, RTrimSpaces(#9));
+  CheckEquals('  '#13#10'a'#13#10'b', RTrimSpaces('  '#13#10'a'#13#10'b'));
+  CheckEquals('  '#13#10'a'#13#10'b', RTrimSpaces('  '#13#10'a'#13#10'b '));
+end;
+
+{ TestStringOf }
+
+procedure TestMisc.TestPrependBackslash;
+begin
+  CheckEquals('\', PrependBackslash(''));
+  CheckEquals('\', PrependBackslash('\'));
+  CheckEquals('\hello', PrependBackslash('hello'));
+  CheckEquals('\hello', PrependBackslash('\hello'));
+  CheckEquals('\hello\world\', PrependBackslash('hello\world\'));
+  CheckEquals('\hello\world', PrependBackslash('\hello\world'));
+end;
+
+procedure TestMisc.TestSpaceString;
+begin
+  CheckEquals('', SpaceStr(0));
+  CheckEquals(' ', SpaceStr(1));
+  CheckEquals('     ', SpaceStr(5));
+end;
+
+procedure TestMisc.TestStringOf;
+begin
+  CheckEquals('', StringOf(' ', 0));
+  CheckEquals(' ', StringOf(' ', 1));
+  CheckEquals('     ', StringOf(' ', 5));
+end;
+
+{ TestFileExt }
+
+procedure TestFileExt.TestJustFilename;
+begin
+  CheckEquals('', JustFilename(''));
+  CheckEquals('.', JustFilename('.'));
+  CheckEquals('.txt', JustFilename('.txt'));
+  CheckEquals('hello', JustFilename('hello'));
+  CheckEquals('hello.txt', JustFilename('hello.txt'));
+  CheckEquals('hello.', JustFilename('hello.'));
+  CheckEquals('world', JustFilename('hello\world'));
+  CheckEquals('world.', JustFilename('hello\world.'));
+  CheckEquals('world.txt', JustFilename('hello\world.txt'));
+end;
+
+procedure TestFileExt.TestRemoveSuffixIfMatching;
+begin
+  CheckEquals('', RemoveSuffixIfMatching('', ''));
+  CheckEquals('', RemoveSuffixIfMatching('', '.txt'));
+  CheckEquals('', RemoveSuffixIfMatching('', '.'));
+  CheckEquals('', RemoveSuffixIfMatching('', 'abc'));
+  CheckEquals('hello', RemoveSuffixIfMatching('hello', ''));
+  CheckEquals('hello', RemoveSuffixIfMatching('hello.txt', '.txt'));
+  CheckEquals('hello.txt', RemoveSuffixIfMatching('hello.txt', '.abc'));
+  CheckEquals('hello.', RemoveSuffixIfMatching('hello.txt', 'txt'));
+  CheckEquals('hello.txt', RemoveSuffixIfMatching('hello.txt.abc', '.abc'));
+  CheckEquals('hello.txt.abc', RemoveSuffixIfMatching('hello.txt.abc', '.def'));
+  CheckEquals('hello ', RemoveSuffixIfMatching('hello World', 'World'));
+  CheckEquals('hello', RemoveSuffixIfMatching('hello World', ' World'));
+end;
+
+procedure TestFileExt.TestForceExt;
+begin
+
+end;
+
+initialization
+  RegisterTest('StringUtils', TestExtractStr.Suite);
+  RegisterTest('StringUtils', TestTrimSpaces.Suite);
+  RegisterTest('StringUtils', TestMisc.Suite);
+  RegisterTest('StringUtils', TestFileExt.Suite);
+end.
+



From twm at mail.berlios.de  Sun Dec 23 15:28:07 2007
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 23 Dec 2007 15:28:07 +0100
Subject: [Dzchart-svncheckins] r262 - utilities/dzLib/trunk/src
Message-ID: <200712231428.lBNES7ER020757@sheep.berlios.de>

Author: twm
Date: 2007-12-23 15:28:01 +0100 (Sun, 23 Dec 2007)
New Revision: 262

Modified:
   utilities/dzLib/trunk/src/u_dzConvertUtils.pas
   utilities/dzLib/trunk/src/u_dzStringUtils.pas
Log:
replaced deprecated StringOf by DupeStr

Modified: utilities/dzLib/trunk/src/u_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-12-22 16:56:59 UTC (rev 261)
+++ utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2007-12-23 14:28:01 UTC (rev 262)
@@ -469,20 +469,13 @@
 begin
   Result := Long2Dec(_l);
   if ULong(Length(Result)) < _n then
-{$IFDEF delphi7up}
     Insert(DupeString('0', _n - ULong(Length(Result))), Result, 1);
-{$ELSE}
-    Insert(StringOf('0', _n - ULong(Length(Result))), Result, 1);
-{$ENDIF}
 end;
 
-{$IFDEF Delphi7up}
-
 function TimeToSeconds(_Zeit: TDateTime): integer;
 begin
   Result := SecondOfTheDay(_Zeit);
 end;
-{$ENDIF}
 
 function SecondsToTimeStr(_Seconds: integer): string;
 begin

Modified: utilities/dzLib/trunk/src/u_dzStringUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzStringUtils.pas	2007-12-22 16:56:59 UTC (rev 261)
+++ utilities/dzLib/trunk/src/u_dzStringUtils.pas	2007-12-23 14:28:01 UTC (rev 262)
@@ -711,11 +711,7 @@
 
 function SpaceStr(_Cnt: integer): string;
 begin
-{$IFDEF Delphi7up}
-  Result := DupeString(' ', _Anz);
-{$ELSE}
-  Result := StringOf(' ', _Cnt);
-{$ENDIF}
+  Result := DupeString(' ', _Cnt);
 end;
 
 function TrimSpaces(const _s: string): string;



