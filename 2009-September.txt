From twm at mail.berlios.de  Fri Sep 25 16:37:07 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:37:07 +0200
Subject: [Dzchart-svncheckins] r336 - 3rd/jedi_inc/trunk
Message-ID: <200909251437.n8PEb7pV011448@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:36:24 +0200 (Fri, 25 Sep 2009)
New Revision: 336

Modified:
   3rd/jedi_inc/trunk/jedi.inc
Log:
allow compiling without jcl

Modified: 3rd/jedi_inc/trunk/jedi.inc
===================================================================
--- 3rd/jedi_inc/trunk/jedi.inc	2009-05-30 17:24:16 UTC (rev 335)
+++ 3rd/jedi_inc/trunk/jedi.inc	2009-09-25 14:36:24 UTC (rev 336)
@@ -1,6 +1,9 @@
 {$IFNDEF JEDI_INC}
 {$DEFINE JEDI_INC}
 
+// this means we do not really have the JCL, used somehwere in dzlib
+{$DEFINE no_jcl}
+
 {******************************************************************************}
 {                                                                              }
 {  The contents of this file are subject to the Mozilla Public License         }
@@ -81,7 +84,6 @@
   LINUX               Defined when target platform is Linux
   UNIX                Defined when target platform is Linux or Unix
 
-
 - Visual library Directives
 
   The following directives indicate for a visual library. In a Delphi/BCB
@@ -95,7 +97,6 @@
   VisualCLX           Defined for Kylix; needs to be defined for Delphi/BCB to
                       use JCL with VisualCLX applications.
 
-
 - Other cross-platform related defines
 
   These symbols are intended to help in writing portable code.
@@ -106,7 +107,6 @@
   Win32API            Code is specific for the Win32 API;
                       use instead of "{$IFNDEF CLR} {$IFDEF MSWINDOWS}" constructs
 
-
 - Delphi Versions
 
   The following directives are direct mappings from the VERXXX directives to a
@@ -126,7 +126,7 @@
   DELPHI2005          Defined when compiling with Delphi 2005
   DELPHI9             Alias for DELPHI2005
   DELPHI10            Defined when compiling with Delphi Personality of BDS 4.0
-  DELPHI11            Defined when compiling with Delphi for Win32 2007 
+  DELPHI11            Defined when compiling with Delphi for Win32 2007
   DELPHI1_UP          Defined when compiling with Delphi 1 or higher
   DELPHI2_UP          Defined when compiling with Delphi 2 or higher
   DELPHI3_UP          Defined when compiling with Delphi 3 or higher
@@ -140,7 +140,6 @@
   DELPHI10_UP         Defined when compiling with Delphi Personality of BDS 4.0 or higher
   DELPHI11_UP         Defined when compiling with Delphi for Win32 2007 or higher
 
-
 - Kylix Versions
 
   The following directives are direct mappings from the VERXXX directives to a
@@ -156,7 +155,6 @@
   KYLIX2_UP           Defined when compiling with Kylix 2 or higher
   KYLIX3_UP           Defined when compiling with Kylix 3 or higher
 
-
 - Delphi Compiler Versions (Delphi / Kylix, not in BCB mode)
 
   Directive           Description
@@ -184,7 +182,6 @@
   DELPHICOMPILER10_UP  Defined when compiling with Delphi Personality of BDS 4.0 or higher
   DELPHICOMPILER11_UP  Defined when compiling with Delphi for Win32 2007 or higher
 
-
 - C++ Builder Versions
 
   The following directives are direct mappings from the VERXXX directives to a
@@ -206,7 +203,6 @@
   BCB6_UP      Defined when compiling with C++ Builder 6 or higher
   BCB10_UP     Defined when compiling with C++ Builder Personality of BDS 4.0 or higher
 
-
 - Borland Developer Studio Versions
 
   The following directives are direct mappings from the VERXXX directives to a
@@ -263,7 +259,6 @@
   COMPILER10_UP  Defined when compiling with Delphi or C++ Builder Personalities of BDS 4.0 or higher
   COMPILER11_UP  Defined when compiling with Delphi for Win32 2007 ir higher
 
-
 - RTL Versions
 
   Use e.g. following to determine the exact RTL version since version 14.0:
@@ -291,7 +286,6 @@
   RTL180_UP     Defined when compiling with Delphi or C++ Builder Personalities of BDS 4.0 or later
   RTL185_UP     Defined when compiling with Delphi for Win32 2007 or later
 
-
 - Feature Directives
 
   The features directives are used to test if the compiler supports specific
@@ -356,7 +350,6 @@
   HAS_UNIT_STRUTILS             Unit StrUtils exists (D6+/BCB6+)
   XPLATFORM_RTL                 The RTL supports crossplatform function names (e.g. RaiseLastOSError) (D6+/BCB6+/FPC)
 
-
 - Compiler Settings
 
   The compiler settings directives indicate whether a specific compiler setting
@@ -390,15 +383,15 @@
 
 { Set FreePascal to Delphi mode }
 {$IFDEF FPC}
-  {$MODE DELPHI}
-  {$ASMMODE Intel}
-  {$UNDEF BORLAND}
+{$MODE DELPHI}
+{$ASMMODE Intel}
+{$UNDEF BORLAND}
 {$ENDIF}
 
 {$IFDEF BORLAND}
-  {$IFDEF LINUX}
-    {$DEFINE KYLIX}
-  {$ENDIF LINUX}
+{$IFDEF LINUX}
+{$DEFINE KYLIX}
+{$ENDIF LINUX}
 {$ENDIF BORLAND}
 
 {------------------------------------------------------------------------------}
@@ -406,165 +399,165 @@
 {------------------------------------------------------------------------------}
 
 {$IFDEF BORLAND}
-  {$IFDEF KYLIX}
-    {$I kylix.inc} // FPC incompatible stuff
-  {$ELSE ~KYLIX}
+{$IFDEF KYLIX}
+{$I kylix.inc} // FPC incompatible stuff
+{$ELSE ~KYLIX}
 
-    {$DEFINE UNKNOWN_COMPILER_VERSION}
+{$DEFINE UNKNOWN_COMPILER_VERSION}
 
-    {$IFDEF VER80}
-      {$DEFINE COMPILER1}
-      {$DEFINE DELPHI1}
-      {$DEFINE DELPHICOMPILER1}
-      {$DEFINE RTL80_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER80}
+{$DEFINE COMPILER1}
+{$DEFINE DELPHI1}
+{$DEFINE DELPHICOMPILER1}
+{$DEFINE RTL80_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER90}
-      {$DEFINE COMPILER2}
-      {$DEFINE DELPHI2}
-      {$DEFINE DELPHICOMPILER2}
-      {$DEFINE RTL90_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER90}
+{$DEFINE COMPILER2}
+{$DEFINE DELPHI2}
+{$DEFINE DELPHICOMPILER2}
+{$DEFINE RTL90_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER93}
-      {$DEFINE COMPILER2}
-      {$DEFINE BCB1}
-      {$DEFINE BCB}
-      {$DEFINE RTL93_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER93}
+{$DEFINE COMPILER2}
+{$DEFINE BCB1}
+{$DEFINE BCB}
+{$DEFINE RTL93_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER100}
-      {$DEFINE COMPILER3}
-      {$DEFINE DELPHI3}
-      {$DEFINE DELPHICOMPILER3}
-      {$DEFINE RTL100_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER100}
+{$DEFINE COMPILER3}
+{$DEFINE DELPHI3}
+{$DEFINE DELPHICOMPILER3}
+{$DEFINE RTL100_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER110}
-      {$DEFINE COMPILER35}
-      {$DEFINE BCB3}
-      {$DEFINE RTL110_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER110}
+{$DEFINE COMPILER35}
+{$DEFINE BCB3}
+{$DEFINE RTL110_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER120}
-      {$DEFINE COMPILER4}
-      {$DEFINE DELPHI4}
-      {$DEFINE DELPHICOMPILER4}
-      {$DEFINE RTL120_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER120}
+{$DEFINE COMPILER4}
+{$DEFINE DELPHI4}
+{$DEFINE DELPHICOMPILER4}
+{$DEFINE RTL120_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER125}
-      {$DEFINE COMPILER4}
-      {$DEFINE BCB4}
-      {$DEFINE BCB}
-      {$DEFINE RTL125_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER125}
+{$DEFINE COMPILER4}
+{$DEFINE BCB4}
+{$DEFINE BCB}
+{$DEFINE RTL125_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER130}
-      {$DEFINE COMPILER5}
-      {$IFDEF BCB}
-        {$DEFINE BCB5}
-      {$ELSE}
-        {$DEFINE DELPHI5}
-        {$DEFINE DELPHICOMPILER5}
-      {$ENDIF}
-      {$DEFINE RTL130_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER130}
+{$DEFINE COMPILER5}
+{$IFDEF BCB}
+{$DEFINE BCB5}
+{$ELSE}
+{$DEFINE DELPHI5}
+{$DEFINE DELPHICOMPILER5}
+{$ENDIF}
+{$DEFINE RTL130_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER140}
-      {$DEFINE COMPILER6}
-      {$IFDEF BCB}
-        {$DEFINE BCB6}
-      {$ELSE}
-        {$DEFINE DELPHI6}
-        {$DEFINE DELPHICOMPILER6}
-      {$ENDIF}
-      {$DEFINE RTL140_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER140}
+{$DEFINE COMPILER6}
+{$IFDEF BCB}
+{$DEFINE BCB6}
+{$ELSE}
+{$DEFINE DELPHI6}
+{$DEFINE DELPHICOMPILER6}
+{$ENDIF}
+{$DEFINE RTL140_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER150}
-      {$DEFINE COMPILER7}
-      {$DEFINE DELPHI7}
-      {$DEFINE DELPHICOMPILER7}
-      {$DEFINE RTL150_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER150}
+{$DEFINE COMPILER7}
+{$DEFINE DELPHI7}
+{$DEFINE DELPHICOMPILER7}
+{$DEFINE RTL150_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER160}
-      {$DEFINE BDS2}
-      {$DEFINE BDS}
-      {$DEFINE COMPILER8}
-      {$DEFINE DELPHI8}
-      {$DEFINE DELPHICOMPILER8}
-      {$DEFINE RTL160_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER160}
+{$DEFINE BDS2}
+{$DEFINE BDS}
+{$DEFINE COMPILER8}
+{$DEFINE DELPHI8}
+{$DEFINE DELPHICOMPILER8}
+{$DEFINE RTL160_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER170}
-      {$DEFINE BDS3}
-      {$DEFINE BDS}
-      {$DEFINE COMPILER9}
-      {$DEFINE DELPHI9}
-      {$DEFINE DELPHI2005} // synonym to DELPHI9
-      {$DEFINE DELPHICOMPILER9}
-      {$DEFINE RTL170_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER170}
+{$DEFINE BDS3}
+{$DEFINE BDS}
+{$DEFINE COMPILER9}
+{$DEFINE DELPHI9}
+{$DEFINE DELPHI2005} // synonym to DELPHI9
+{$DEFINE DELPHICOMPILER9}
+{$DEFINE RTL170_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF VER180}
-      {$DEFINE BDS}
-      {$IFDEF VER185}
-        {$DEFINE BDS5}
-        {$DEFINE COMPILER11}
-        {$IFDEF BCB}
-          {$DEFINE BCB11}
-        {$ELSE}
-          {$DEFINE DELPHI11}
-          {$DEFINE DELPHICOMPILER11}
-        {$ENDIF}
-        {$DEFINE RTL185_UP}
-      {$ELSE ~~VER185}
-        {$DEFINE BDS4}
-        {$DEFINE COMPILER10}
-        {$IFDEF BCB}
-          {$DEFINE BCB10}
-        {$ELSE}
-          {$DEFINE DELPHI10}
-          {$DEFINE DELPHICOMPILER10}
-        {$ENDIF}
-        {$DEFINE RTL180_UP}
-      {$ENDIF ~VER185}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF VER180}
+{$DEFINE BDS}
+{$IFDEF VER185}
+{$DEFINE BDS5}
+{$DEFINE COMPILER11}
+{$IFDEF BCB}
+{$DEFINE BCB11}
+{$ELSE}
+{$DEFINE DELPHI11}
+{$DEFINE DELPHICOMPILER11}
+{$ENDIF}
+{$DEFINE RTL185_UP}
+{$ELSE ~~VER185}
+{$DEFINE BDS4}
+{$DEFINE COMPILER10}
+{$IFDEF BCB}
+{$DEFINE BCB10}
+{$ELSE}
+{$DEFINE DELPHI10}
+{$DEFINE DELPHICOMPILER10}
+{$ENDIF}
+{$DEFINE RTL180_UP}
+{$ENDIF ~VER185}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-    {$IFDEF UNKNOWN_COMPILER_VERSION} // adjust for newer version
-      {$DEFINE BDS5}
-      {$DEFINE BDS}
-      {$DEFINE COMPILER11}
-      {$DEFINE DELPHI11}
-      {$DEFINE DELPHICOMPILER11}
-      {$DEFINE RTL185_UP}
-      {$UNDEF UNKNOWN_COMPILER_VERSION}
-    {$ENDIF}
+{$IFDEF UNKNOWN_COMPILER_VERSION} // adjust for newer version
+{$DEFINE BDS5}
+{$DEFINE BDS}
+{$DEFINE COMPILER11}
+{$DEFINE DELPHI11}
+{$DEFINE DELPHICOMPILER11}
+{$DEFINE RTL185_UP}
+{$UNDEF UNKNOWN_COMPILER_VERSION}
+{$ENDIF}
 
-  {$ENDIF ~KYLIX}
+{$ENDIF ~KYLIX}
 
-  {$IFDEF BCB}
-    {$DEFINE CPPBUILDER}
-    {$DEFINE BCBCOMPILER}
-  {$ELSE ~BCB}
-    {$DEFINE DELPHI}
-    {$DEFINE DELPHICOMPILER}
-  {$ENDIF ~BCB}
+{$IFDEF BCB}
+{$DEFINE CPPBUILDER}
+{$DEFINE BCBCOMPILER}
+{$ELSE ~BCB}
+{$DEFINE DELPHI}
+{$DEFINE DELPHICOMPILER}
+{$ENDIF ~BCB}
 
 {$ENDIF BORLAND}
 
@@ -572,171 +565,171 @@
 { DELPHIX_UP from DELPHIX mappings                                             }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHI11 }  {$DEFINE DELPHI11_UP }  {$ENDIF}
-{$IFDEF DELPHI10 }  {$DEFINE DELPHI10_UP }  {$ENDIF}
-{$IFDEF DELPHI9  }  {$DEFINE DELPHI9_UP  }  {$ENDIF}
-{$IFDEF DELPHI8  }  {$DEFINE DELPHI8_UP  }  {$ENDIF}
-{$IFDEF DELPHI7  }  {$DEFINE DELPHI7_UP  }  {$ENDIF}
-{$IFDEF DELPHI6  }  {$DEFINE DELPHI6_UP  }  {$ENDIF}
-{$IFDEF DELPHI5  }  {$DEFINE DELPHI5_UP  }  {$ENDIF}
-{$IFDEF DELPHI4  }  {$DEFINE DELPHI4_UP  }  {$ENDIF}
-{$IFDEF DELPHI3  }  {$DEFINE DELPHI3_UP  }  {$ENDIF}
-{$IFDEF DELPHI2  }  {$DEFINE DELPHI2_UP  }  {$ENDIF}
-{$IFDEF DELPHI1  }  {$DEFINE DELPHI1_UP  }  {$ENDIF}
+{$IFDEF DELPHI11 }{$DEFINE DELPHI11_UP }{$ENDIF}
+{$IFDEF DELPHI10 }{$DEFINE DELPHI10_UP }{$ENDIF}
+{$IFDEF DELPHI9  }{$DEFINE DELPHI9_UP  }{$ENDIF}
+{$IFDEF DELPHI8  }{$DEFINE DELPHI8_UP  }{$ENDIF}
+{$IFDEF DELPHI7  }{$DEFINE DELPHI7_UP  }{$ENDIF}
+{$IFDEF DELPHI6  }{$DEFINE DELPHI6_UP  }{$ENDIF}
+{$IFDEF DELPHI5  }{$DEFINE DELPHI5_UP  }{$ENDIF}
+{$IFDEF DELPHI4  }{$DEFINE DELPHI4_UP  }{$ENDIF}
+{$IFDEF DELPHI3  }{$DEFINE DELPHI3_UP  }{$ENDIF}
+{$IFDEF DELPHI2  }{$DEFINE DELPHI2_UP  }{$ENDIF}
+{$IFDEF DELPHI1  }{$DEFINE DELPHI1_UP  }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { DELPHIX_UP from DELPHIX_UP mappings                                          }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHI11_UP}   {$DEFINE DELPHI10_UP }  {$ENDIF}
-{$IFDEF DELPHI10_UP }  {$DEFINE DELPHI9_UP  }  {$ENDIF}
+{$IFDEF DELPHI11_UP}{$DEFINE DELPHI10_UP }{$ENDIF}
+{$IFDEF DELPHI10_UP }{$DEFINE DELPHI9_UP  }{$ENDIF}
 
 {$IFDEF DELPHI9_UP}
-  {$DEFINE DELPHI2005_UP} // synonym to DELPHI9_UP
-  {$DEFINE DELPHI8_UP}
+{$DEFINE DELPHI2005_UP} // synonym to DELPHI9_UP
+{$DEFINE DELPHI8_UP}
 {$ENDIF}
 
-{$IFDEF DELPHI8_UP }  {$DEFINE DELPHI7_UP }  {$ENDIF}
-{$IFDEF DELPHI7_UP }  {$DEFINE DELPHI6_UP }  {$ENDIF}
-{$IFDEF DELPHI6_UP }  {$DEFINE DELPHI5_UP }  {$ENDIF}
-{$IFDEF DELPHI5_UP }  {$DEFINE DELPHI4_UP }  {$ENDIF}
-{$IFDEF DELPHI4_UP }  {$DEFINE DELPHI3_UP }  {$ENDIF}
-{$IFDEF DELPHI3_UP }  {$DEFINE DELPHI2_UP }  {$ENDIF}
-{$IFDEF DELPHI2_UP }  {$DEFINE DELPHI1_UP }  {$ENDIF}
+{$IFDEF DELPHI8_UP }{$DEFINE DELPHI7_UP }{$ENDIF}
+{$IFDEF DELPHI7_UP }{$DEFINE DELPHI6_UP }{$ENDIF}
+{$IFDEF DELPHI6_UP }{$DEFINE DELPHI5_UP }{$ENDIF}
+{$IFDEF DELPHI5_UP }{$DEFINE DELPHI4_UP }{$ENDIF}
+{$IFDEF DELPHI4_UP }{$DEFINE DELPHI3_UP }{$ENDIF}
+{$IFDEF DELPHI3_UP }{$DEFINE DELPHI2_UP }{$ENDIF}
+{$IFDEF DELPHI2_UP }{$DEFINE DELPHI1_UP }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BCBX_UP from BCBX mappings                                                   }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BCB11}  {$DEFINE BCB11_UP}  {$ENDIF}
-{$IFDEF BCB10}  {$DEFINE BCB10_UP}  {$ENDIF}
-{$IFDEF BCB6 }  {$DEFINE BCB6_UP }  {$ENDIF}
-{$IFDEF BCB5 }  {$DEFINE BCB5_UP }  {$ENDIF}
-{$IFDEF BCB4 }  {$DEFINE BCB4_UP }  {$ENDIF}
-{$IFDEF BCB3 }  {$DEFINE BCB3_UP }  {$ENDIF}
-{$IFDEF BCB1 }  {$DEFINE BCB1_UP }  {$ENDIF}
+{$IFDEF BCB11}{$DEFINE BCB11_UP}{$ENDIF}
+{$IFDEF BCB10}{$DEFINE BCB10_UP}{$ENDIF}
+{$IFDEF BCB6 }{$DEFINE BCB6_UP }{$ENDIF}
+{$IFDEF BCB5 }{$DEFINE BCB5_UP }{$ENDIF}
+{$IFDEF BCB4 }{$DEFINE BCB4_UP }{$ENDIF}
+{$IFDEF BCB3 }{$DEFINE BCB3_UP }{$ENDIF}
+{$IFDEF BCB1 }{$DEFINE BCB1_UP }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BCBX_UP from BCBX_UP mappings                                                }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BCB11_UP}  {$DEFINE BCB10_UP}  {$ENDIF}
-{$IFDEF BCB10_UP}  {$DEFINE BCB6_UP }  {$ENDIF}
-{$IFDEF BCB6_UP }  {$DEFINE BCB5_UP }  {$ENDIF}
-{$IFDEF BCB5_UP }  {$DEFINE BCB4_UP }  {$ENDIF}
-{$IFDEF BCB4_UP }  {$DEFINE BCB3_UP }  {$ENDIF}
-{$IFDEF BCB3_UP }  {$DEFINE BCB1_UP }  {$ENDIF}
+{$IFDEF BCB11_UP}{$DEFINE BCB10_UP}{$ENDIF}
+{$IFDEF BCB10_UP}{$DEFINE BCB6_UP }{$ENDIF}
+{$IFDEF BCB6_UP }{$DEFINE BCB5_UP }{$ENDIF}
+{$IFDEF BCB5_UP }{$DEFINE BCB4_UP }{$ENDIF}
+{$IFDEF BCB4_UP }{$DEFINE BCB3_UP }{$ENDIF}
+{$IFDEF BCB3_UP }{$DEFINE BCB1_UP }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BDSX_UP from BDSX mappings                                                   }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BDS5 }  {$DEFINE BDS5_UP }  {$ENDIF}
-{$IFDEF BDS4 }  {$DEFINE BDS4_UP }  {$ENDIF}
-{$IFDEF BDS3 }  {$DEFINE BDS3_UP }  {$ENDIF}
-{$IFDEF BDS2 }  {$DEFINE BDS2_UP }  {$ENDIF}
+{$IFDEF BDS5 }{$DEFINE BDS5_UP }{$ENDIF}
+{$IFDEF BDS4 }{$DEFINE BDS4_UP }{$ENDIF}
+{$IFDEF BDS3 }{$DEFINE BDS3_UP }{$ENDIF}
+{$IFDEF BDS2 }{$DEFINE BDS2_UP }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BDSX_UP from BDSX_UP mappings                                                }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BDS5_UP }  {$DEFINE BDS4_UP }  {$ENDIF}
-{$IFDEF BDS4_UP }  {$DEFINE BDS3_UP }  {$ENDIF}
-{$IFDEF BDS3_UP }  {$DEFINE BDS2_UP }  {$ENDIF}
+{$IFDEF BDS5_UP }{$DEFINE BDS4_UP }{$ENDIF}
+{$IFDEF BDS4_UP }{$DEFINE BDS3_UP }{$ENDIF}
+{$IFDEF BDS3_UP }{$DEFINE BDS2_UP }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { DELPHICOMPILERX_UP from DELPHICOMPILERX mappings                             }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHICOMPILER11 }  {$DEFINE DELPHICOMPILER11_UP }  {$ENDIF}
-{$IFDEF DELPHICOMPILER10 }  {$DEFINE DELPHICOMPILER10_UP }  {$ENDIF}
-{$IFDEF DELPHICOMPILER9  }  {$DEFINE DELPHICOMPILER9_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER8  }  {$DEFINE DELPHICOMPILER8_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER7  }  {$DEFINE DELPHICOMPILER7_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER6  }  {$DEFINE DELPHICOMPILER6_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER5  }  {$DEFINE DELPHICOMPILER5_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER4  }  {$DEFINE DELPHICOMPILER4_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER3  }  {$DEFINE DELPHICOMPILER3_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER2  }  {$DEFINE DELPHICOMPILER2_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER1  }  {$DEFINE DELPHICOMPILER1_UP  }  {$ENDIF}
+{$IFDEF DELPHICOMPILER11 }{$DEFINE DELPHICOMPILER11_UP }{$ENDIF}
+{$IFDEF DELPHICOMPILER10 }{$DEFINE DELPHICOMPILER10_UP }{$ENDIF}
+{$IFDEF DELPHICOMPILER9  }{$DEFINE DELPHICOMPILER9_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER8  }{$DEFINE DELPHICOMPILER8_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER7  }{$DEFINE DELPHICOMPILER7_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER6  }{$DEFINE DELPHICOMPILER6_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER5  }{$DEFINE DELPHICOMPILER5_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER4  }{$DEFINE DELPHICOMPILER4_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER3  }{$DEFINE DELPHICOMPILER3_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER2  }{$DEFINE DELPHICOMPILER2_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER1  }{$DEFINE DELPHICOMPILER1_UP  }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { DELPHICOMPILERX_UP from DELPHICOMPILERX_UP mappings                          }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHICOMPILER11_UP }  {$DEFINE DELPHICOMPILER10_UP }  {$ENDIF}
-{$IFDEF DELPHICOMPILER10_UP }  {$DEFINE DELPHICOMPILER9_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER9_UP  }  {$DEFINE DELPHICOMPILER8_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER8_UP  }  {$DEFINE DELPHICOMPILER7_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER8_UP  }  {$DEFINE DELPHICOMPILER7_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER7_UP  }  {$DEFINE DELPHICOMPILER6_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER6_UP  }  {$DEFINE DELPHICOMPILER5_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER5_UP  }  {$DEFINE DELPHICOMPILER4_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER4_UP  }  {$DEFINE DELPHICOMPILER3_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER3_UP  }  {$DEFINE DELPHICOMPILER2_UP  }  {$ENDIF}
-{$IFDEF DELPHICOMPILER2_UP  }  {$DEFINE DELPHICOMPILER1_UP  }  {$ENDIF}
+{$IFDEF DELPHICOMPILER11_UP }{$DEFINE DELPHICOMPILER10_UP }{$ENDIF}
+{$IFDEF DELPHICOMPILER10_UP }{$DEFINE DELPHICOMPILER9_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER9_UP  }{$DEFINE DELPHICOMPILER8_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER8_UP  }{$DEFINE DELPHICOMPILER7_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER8_UP  }{$DEFINE DELPHICOMPILER7_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER7_UP  }{$DEFINE DELPHICOMPILER6_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER6_UP  }{$DEFINE DELPHICOMPILER5_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER5_UP  }{$DEFINE DELPHICOMPILER4_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER4_UP  }{$DEFINE DELPHICOMPILER3_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER3_UP  }{$DEFINE DELPHICOMPILER2_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER2_UP  }{$DEFINE DELPHICOMPILER1_UP  }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { COMPILERX_UP from COMPILERX mappings                                         }
 {------------------------------------------------------------------------------}
 
-{$IFDEF COMPILER11 }  {$DEFINE COMPILER11_UP }  {$ENDIF}
-{$IFDEF COMPILER10 }  {$DEFINE COMPILER10_UP }  {$ENDIF}
-{$IFDEF COMPILER9  }  {$DEFINE COMPILER9_UP  }  {$ENDIF}
-{$IFDEF COMPILER8  }  {$DEFINE COMPILER8_UP  }  {$ENDIF}
-{$IFDEF COMPILER7  }  {$DEFINE COMPILER7_UP  }  {$ENDIF}
-{$IFDEF COMPILER6  }  {$DEFINE COMPILER6_UP  }  {$ENDIF}
-{$IFDEF COMPILER5  }  {$DEFINE COMPILER5_UP  }  {$ENDIF}
-{$IFDEF COMPILER4  }  {$DEFINE COMPILER4_UP  }  {$ENDIF}
-{$IFDEF COMPILER35 }  {$DEFINE COMPILER35_UP }  {$ENDIF}
-{$IFDEF COMPILER3  }  {$DEFINE COMPILER3_UP  }  {$ENDIF}
-{$IFDEF COMPILER2  }  {$DEFINE COMPILER2_UP  }  {$ENDIF}
-{$IFDEF COMPILER1  }  {$DEFINE COMPILER1_UP  }  {$ENDIF}
+{$IFDEF COMPILER11 }{$DEFINE COMPILER11_UP }{$ENDIF}
+{$IFDEF COMPILER10 }{$DEFINE COMPILER10_UP }{$ENDIF}
+{$IFDEF COMPILER9  }{$DEFINE COMPILER9_UP  }{$ENDIF}
+{$IFDEF COMPILER8  }{$DEFINE COMPILER8_UP  }{$ENDIF}
+{$IFDEF COMPILER7  }{$DEFINE COMPILER7_UP  }{$ENDIF}
+{$IFDEF COMPILER6  }{$DEFINE COMPILER6_UP  }{$ENDIF}
+{$IFDEF COMPILER5  }{$DEFINE COMPILER5_UP  }{$ENDIF}
+{$IFDEF COMPILER4  }{$DEFINE COMPILER4_UP  }{$ENDIF}
+{$IFDEF COMPILER35 }{$DEFINE COMPILER35_UP }{$ENDIF}
+{$IFDEF COMPILER3  }{$DEFINE COMPILER3_UP  }{$ENDIF}
+{$IFDEF COMPILER2  }{$DEFINE COMPILER2_UP  }{$ENDIF}
+{$IFDEF COMPILER1  }{$DEFINE COMPILER1_UP  }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { COMPILERX_UP from COMPILERX_UP mappings                                      }
 {------------------------------------------------------------------------------}
 
-{$IFDEF COMPILER11_UP }  {$DEFINE COMPILER10_UP}  {$ENDIF}
-{$IFDEF COMPILER10_UP }  {$DEFINE COMPILER9_UP }  {$ENDIF}
-{$IFDEF COMPILER9_UP  }  {$DEFINE COMPILER8_UP }  {$ENDIF}
-{$IFDEF COMPILER8_UP  }  {$DEFINE COMPILER7_UP }  {$ENDIF}
-{$IFDEF COMPILER7_UP  }  {$DEFINE COMPILER6_UP }  {$ENDIF}
-{$IFDEF COMPILER6_UP  }  {$DEFINE COMPILER5_UP }  {$ENDIF}
-{$IFDEF COMPILER5_UP  }  {$DEFINE COMPILER4_UP }  {$ENDIF}
-{$IFDEF COMPILER4_UP  }  {$DEFINE COMPILER35_UP}  {$ENDIF}
-{$IFDEF COMPILER35_UP }  {$DEFINE COMPILER3_UP }  {$ENDIF}
-{$IFDEF COMPILER3_UP  }  {$DEFINE COMPILER2_UP }  {$ENDIF}
-{$IFDEF COMPILER2_UP  }  {$DEFINE COMPILER1_UP }  {$ENDIF}
+{$IFDEF COMPILER11_UP }{$DEFINE COMPILER10_UP}{$ENDIF}
+{$IFDEF COMPILER10_UP }{$DEFINE COMPILER9_UP }{$ENDIF}
+{$IFDEF COMPILER9_UP  }{$DEFINE COMPILER8_UP }{$ENDIF}
+{$IFDEF COMPILER8_UP  }{$DEFINE COMPILER7_UP }{$ENDIF}
+{$IFDEF COMPILER7_UP  }{$DEFINE COMPILER6_UP }{$ENDIF}
+{$IFDEF COMPILER6_UP  }{$DEFINE COMPILER5_UP }{$ENDIF}
+{$IFDEF COMPILER5_UP  }{$DEFINE COMPILER4_UP }{$ENDIF}
+{$IFDEF COMPILER4_UP  }{$DEFINE COMPILER35_UP}{$ENDIF}
+{$IFDEF COMPILER35_UP }{$DEFINE COMPILER3_UP }{$ENDIF}
+{$IFDEF COMPILER3_UP  }{$DEFINE COMPILER2_UP }{$ENDIF}
+{$IFDEF COMPILER2_UP  }{$DEFINE COMPILER1_UP }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 { RTLX_UP from RTLX_UP mappings                                                }
 {------------------------------------------------------------------------------}
 
-{$IFDEF RTL185_UP}  {$DEFINE RTL180_UP}  {$ENDIF}
-{$IFDEF RTL180_UP}  {$DEFINE RTL170_UP}  {$ENDIF}
-{$IFDEF RTL170_UP}  {$DEFINE RTL160_UP}  {$ENDIF}
-{$IFDEF RTL160_UP}  {$DEFINE RTL150_UP}  {$ENDIF}
-{$IFDEF RTL150_UP}  {$DEFINE RTL145_UP}  {$ENDIF}
-{$IFDEF RTL145_UP}  {$DEFINE RTL142_UP}  {$ENDIF}
-{$IFDEF RTL142_UP}  {$DEFINE RTL140_UP}  {$ENDIF}
-{$IFDEF RTL140_UP}  {$DEFINE RTL130_UP}  {$ENDIF}
-{$IFDEF RTL130_UP}  {$DEFINE RTL125_UP}  {$ENDIF}
-{$IFDEF RTL125_UP}  {$DEFINE RTL120_UP}  {$ENDIF}
-{$IFDEF RTL120_UP}  {$DEFINE RTL110_UP}  {$ENDIF}
-{$IFDEF RTL110_UP}  {$DEFINE RTL100_UP}  {$ENDIF}
-{$IFDEF RTL100_UP}  {$DEFINE RTL93_UP }  {$ENDIF}
-{$IFDEF RTL93_UP }  {$DEFINE RTL90_UP }  {$ENDIF}
-{$IFDEF RTL90_UP }  {$DEFINE RTL80_UP }  {$ENDIF}
+{$IFDEF RTL185_UP}{$DEFINE RTL180_UP}{$ENDIF}
+{$IFDEF RTL180_UP}{$DEFINE RTL170_UP}{$ENDIF}
+{$IFDEF RTL170_UP}{$DEFINE RTL160_UP}{$ENDIF}
+{$IFDEF RTL160_UP}{$DEFINE RTL150_UP}{$ENDIF}
+{$IFDEF RTL150_UP}{$DEFINE RTL145_UP}{$ENDIF}
+{$IFDEF RTL145_UP}{$DEFINE RTL142_UP}{$ENDIF}
+{$IFDEF RTL142_UP}{$DEFINE RTL140_UP}{$ENDIF}
+{$IFDEF RTL140_UP}{$DEFINE RTL130_UP}{$ENDIF}
+{$IFDEF RTL130_UP}{$DEFINE RTL125_UP}{$ENDIF}
+{$IFDEF RTL125_UP}{$DEFINE RTL120_UP}{$ENDIF}
+{$IFDEF RTL120_UP}{$DEFINE RTL110_UP}{$ENDIF}
+{$IFDEF RTL110_UP}{$DEFINE RTL100_UP}{$ENDIF}
+{$IFDEF RTL100_UP}{$DEFINE RTL93_UP }{$ENDIF}
+{$IFDEF RTL93_UP }{$DEFINE RTL90_UP }{$ENDIF}
+{$IFDEF RTL90_UP }{$DEFINE RTL80_UP }{$ENDIF}
 
 {------------------------------------------------------------------------------}
 
 {$IFDEF DELPHICOMPILER}
-  {$DEFINE DELPHILANGUAGE}
+{$DEFINE DELPHILANGUAGE}
 {$ENDIF}
 
 {$IFDEF BCBCOMPILER}
-  {$DEFINE DELPHILANGUAGE}
+{$DEFINE DELPHILANGUAGE}
 {$ENDIF}
 
 {------------------------------------------------------------------------------}
@@ -744,18 +737,18 @@
 {------------------------------------------------------------------------------}
 
 {$IFDEF KYLIX3}
-  {$DEFINE KYLIX3_UP}
-  {$DEFINE KYLIX2_UP}
-  {$DEFINE KYLIX1_UP}
+{$DEFINE KYLIX3_UP}
+{$DEFINE KYLIX2_UP}
+{$DEFINE KYLIX1_UP}
 {$ENDIF}
 
 {$IFDEF KYLIX2}
-  {$DEFINE KYLIX2_UP}
-  {$DEFINE KYLIX1_UP}
+{$DEFINE KYLIX2_UP}
+{$DEFINE KYLIX1_UP}
 {$ENDIF}
 
 {$IFDEF KYLIX1}
-  {$DEFINE KYLIX1_UP}
+{$DEFINE KYLIX1_UP}
 {$ENDIF}
 
 {------------------------------------------------------------------------------}
@@ -763,155 +756,155 @@
 {------------------------------------------------------------------------------}
 
 {$IFDEF FPC}
-  {$IFDEF  VER1_0}
-     Please use FPC 2.0 or later to compile this.
-  {$ELSE}
-    {$DEFINE SUPPORTS_OUTPARAMS}
-    {$DEFINE SUPPORTS_WIDECHAR}
-    {$DEFINE SUPPORTS_WIDESTRING}
-    {$IFDEF HASINTF}
-      {$DEFINE SUPPORTS_INTERFACE}
-    {$ENDIF}
-    {$IFDEF HASVARIANT}
-      {$DEFINE SUPPORTS_VARIANT}
-    {$ENDIF}
-    {$IFDEF FPC_HAS_TYPE_SINGLE}
-      {$DEFINE SUPPORTS_SINGLE}
-    {$ENDIF}
-    {$IFDEF FPC_HAS_TYPE_DOUBLE}
-      {$DEFINE SUPPORTS_DOUBLE}
-    {$ENDIF}
-    {$IFDEF FPC_HAS_TYPE_EXTENDED}
-      {$DEFINE SUPPORTS_EXTENDED}
-    {$ENDIF}
-    {$IFDEF HASCURRENCY}
-      {$DEFINE SUPPORTS_CURRENCY}
-    {$ENDIF}
-    {$DEFINE SUPPORTS_THREADVAR}
-    {$DEFINE SUPPORTS_CONSTPARAMS}
-    {$DEFINE SUPPORTS_LONGWORD}
-    {$DEFINE SUPPORTS_INT64}
-    {$DEFINE SUPPORTS_DYNAMICARRAYS}
-    {$DEFINE SUPPORTS_DEFAULTPARAMS}
-    {$DEFINE SUPPORTS_OVERLOAD}
-    {$DEFINE ACCEPT_DEPRECATED}
-    {$DEFINE ACCEPT_PLATFORM}
-    {$DEFINE ACCEPT_LIBRARY}
-    {$DEFINE SUPPORTS_EXTSYM}
-    {$DEFINE SUPPORTS_NODEFINE}
+{$IFDEF  VER1_0}
+Please use FPC 2.0 or later to compile this.
+{$ELSE}
+{$DEFINE SUPPORTS_OUTPARAMS}
+{$DEFINE SUPPORTS_WIDECHAR}
+{$DEFINE SUPPORTS_WIDESTRING}
+{$IFDEF HASINTF}
+{$DEFINE SUPPORTS_INTERFACE}
+{$ENDIF}
+{$IFDEF HASVARIANT}
+{$DEFINE SUPPORTS_VARIANT}
+{$ENDIF}
+{$IFDEF FPC_HAS_TYPE_SINGLE}
+{$DEFINE SUPPORTS_SINGLE}
+{$ENDIF}
+{$IFDEF FPC_HAS_TYPE_DOUBLE}
+{$DEFINE SUPPORTS_DOUBLE}
+{$ENDIF}
+{$IFDEF FPC_HAS_TYPE_EXTENDED}
+{$DEFINE SUPPORTS_EXTENDED}
+{$ENDIF}
+{$IFDEF HASCURRENCY}
+{$DEFINE SUPPORTS_CURRENCY}
+{$ENDIF}
+{$DEFINE SUPPORTS_THREADVAR}
+{$DEFINE SUPPORTS_CONSTPARAMS}
+{$DEFINE SUPPORTS_LONGWORD}
+{$DEFINE SUPPORTS_INT64}
+{$DEFINE SUPPORTS_DYNAMICARRAYS}
+{$DEFINE SUPPORTS_DEFAULTPARAMS}
+{$DEFINE SUPPORTS_OVERLOAD}
+{$DEFINE ACCEPT_DEPRECATED}
+{$DEFINE ACCEPT_PLATFORM}
+{$DEFINE ACCEPT_LIBRARY}
+{$DEFINE SUPPORTS_EXTSYM}
+{$DEFINE SUPPORTS_NODEFINE}
 
-    {$DEFINE SUPPORTS_CUSTOMVARIANTS}
-    {$DEFINE SUPPORTS_VARARGS}
-    {$DEFINE SUPPORTS_ENUMVALUE}
-    {$IFDEF LINUX}
-      {$DEFINE HAS_UNIT_LIBC}
-    {$ENDIF LINUX}
-    {$DEFINE HAS_UNIT_TYPES}
-    {$DEFINE HAS_UNIT_VARIANTS}
-    {$DEFINE HAS_UNIT_STRUTILS}
-    {$DEFINE HAS_UNIT_RTLCONSTS}
+{$DEFINE SUPPORTS_CUSTOMVARIANTS}
+{$DEFINE SUPPORTS_VARARGS}
+{$DEFINE SUPPORTS_ENUMVALUE}
+{$IFDEF LINUX}
+{$DEFINE HAS_UNIT_LIBC}
+{$ENDIF LINUX}
+{$DEFINE HAS_UNIT_TYPES}
+{$DEFINE HAS_UNIT_VARIANTS}
+{$DEFINE HAS_UNIT_STRUTILS}
+{$DEFINE HAS_UNIT_RTLCONSTS}
 
-    {$DEFINE XPLATFORM_RTL}
+{$DEFINE XPLATFORM_RTL}
 
-    {$UNDEF SUPPORTS_DISPINTERFACE}
-    {$UNDEF SUPPORTS_IMPLEMENTS}
-    {$UNDEF SUPPORTS_UNSAFE_WARNINGS}
-  {$ENDIF}
+{$UNDEF SUPPORTS_DISPINTERFACE}
+{$UNDEF SUPPORTS_IMPLEMENTS}
+{$UNDEF SUPPORTS_UNSAFE_WARNINGS}
+{$ENDIF}
 {$ENDIF FPC}
 
 {$IFDEF COMPILER1_UP}
-  {$DEFINE SUPPORTS_CONSTPARAMS}
-  {$DEFINE SUPPORTS_SINGLE}
-  {$DEFINE SUPPORTS_DOUBLE}
-  {$DEFINE SUPPORTS_EXTENDED}
+{$DEFINE SUPPORTS_CONSTPARAMS}
+{$DEFINE SUPPORTS_SINGLE}
+{$DEFINE SUPPORTS_DOUBLE}
+{$DEFINE SUPPORTS_EXTENDED}
 {$ENDIF COMPILER1_UP}
 
 {$IFDEF COMPILER2_UP}
-  {$DEFINE SUPPORTS_CURRENCY}
-  {$DEFINE SUPPORTS_THREADVAR}
-  {$DEFINE SUPPORTS_VARIANT}
-  {$DEFINE SUPPORTS_WIDECHAR}
+{$DEFINE SUPPORTS_CURRENCY}
+{$DEFINE SUPPORTS_THREADVAR}
+{$DEFINE SUPPORTS_VARIANT}
+{$DEFINE SUPPORTS_WIDECHAR}
 {$ENDIF COMPILER2_UP}
 
 {$IFDEF COMPILER3_UP}
-  {$DEFINE SUPPORTS_OUTPARAMS}
-  {$DEFINE SUPPORTS_WIDESTRING}
-  {$DEFINE SUPPORTS_INTERFACE}
-  {$DEFINE SUPPORTS_DISPINTERFACE}
-  {$DEFINE SUPPORTS_DISPID}
-  {$DEFINE SUPPORTS_WEAKPACKAGEUNIT}
+{$DEFINE SUPPORTS_OUTPARAMS}
+{$DEFINE SUPPORTS_WIDESTRING}
+{$DEFINE SUPPORTS_INTERFACE}
+{$DEFINE SUPPORTS_DISPINTERFACE}
+{$DEFINE SUPPORTS_DISPID}
+{$DEFINE SUPPORTS_WEAKPACKAGEUNIT}
 {$ENDIF COMPILER3_UP}
 
 {$IFDEF COMPILER35_UP}
-  {$DEFINE SUPPORTS_EXTSYM}
-  {$DEFINE SUPPORTS_NODEFINE}
+{$DEFINE SUPPORTS_EXTSYM}
+{$DEFINE SUPPORTS_NODEFINE}
 {$ENDIF COMPILER35_UP}
 
 {$IFDEF COMPILER4_UP}
-  {$DEFINE SUPPORTS_LONGWORD}
-  {$DEFINE SUPPORTS_INT64}
-  {$DEFINE SUPPORTS_DYNAMICARRAYS}
-  {$DEFINE SUPPORTS_DEFAULTPARAMS}
-  {$DEFINE SUPPORTS_OVERLOAD}
-  {$DEFINE SUPPORTS_IMPLEMENTS}
+{$DEFINE SUPPORTS_LONGWORD}
+{$DEFINE SUPPORTS_INT64}
+{$DEFINE SUPPORTS_DYNAMICARRAYS}
+{$DEFINE SUPPORTS_DEFAULTPARAMS}
+{$DEFINE SUPPORTS_OVERLOAD}
+{$DEFINE SUPPORTS_IMPLEMENTS}
 {$ENDIF COMPILER4_UP}
 
 {$IFDEF COMPILER6_UP}
-  {$DEFINE SUPPORTS_DEPRECATED}
-  {$DEFINE SUPPORTS_LIBRARY}
-  {$DEFINE SUPPORTS_PLATFORM}
-  {$DEFINE SUPPORTS_LOCAL}
-  {$DEFINE ACCEPT_DEPRECATED}
-  {$DEFINE ACCEPT_PLATFORM}
-  {$DEFINE ACCEPT_LIBRARY}
-  {$DEFINE SUPPORTS_DEPRECATED_WARNINGS}
-  {$DEFINE SUPPORTS_LIBRARY_WARNINGS}
-  {$DEFINE SUPPORTS_PLATFORM_WARNINGS}
-  {$DEFINE SUPPORTS_CUSTOMVARIANTS}
-  {$DEFINE SUPPORTS_VARARGS}
-  {$DEFINE SUPPORTS_ENUMVALUE}
-  {$DEFINE SUPPORTS_COMPILETIME_MESSAGES}
+{$DEFINE SUPPORTS_DEPRECATED}
+{$DEFINE SUPPORTS_LIBRARY}
+{$DEFINE SUPPORTS_PLATFORM}
+{$DEFINE SUPPORTS_LOCAL}
+{$DEFINE ACCEPT_DEPRECATED}
+{$DEFINE ACCEPT_PLATFORM}
+{$DEFINE ACCEPT_LIBRARY}
+{$DEFINE SUPPORTS_DEPRECATED_WARNINGS}
+{$DEFINE SUPPORTS_LIBRARY_WARNINGS}
+{$DEFINE SUPPORTS_PLATFORM_WARNINGS}
+{$DEFINE SUPPORTS_CUSTOMVARIANTS}
+{$DEFINE SUPPORTS_VARARGS}
+{$DEFINE SUPPORTS_ENUMVALUE}
+{$DEFINE SUPPORTS_COMPILETIME_MESSAGES}
 {$ENDIF COMPILER6_UP}
 
 {$IFDEF COMPILER7_UP}
-  {$DEFINE SUPPORTS_UNSAFE_WARNINGS}
+{$DEFINE SUPPORTS_UNSAFE_WARNINGS}
 {$ENDIF COMPILER7_UP}
 
 {$IFDEF COMPILER9_UP}
-  {$DEFINE SUPPORTS_FOR_IN}
-  {$DEFINE SUPPORTS_INLINE}
-  {$DEFINE SUPPORTS_NESTED_CONSTANTS}
-  {$DEFINE SUPPORTS_NESTED_TYPES}
-  {$IFDEF CLR}
-    {$DEFINE SUPPORTS_ENHANCED_RECORDS}
-    {$DEFINE SUPPORTS_CLASS_FIELDS}
-    {$DEFINE SUPPORTS_CLASS_HELPERS}
-    {$DEFINE SUPPORTS_CLASS_OPERATORS}
-    {$DEFINE SUPPORTS_STRICT}
-    {$DEFINE SUPPORTS_STATIC}
-    {$DEFINE SUPPORTS_FINAL}
-  {$ENDIF CLR}
+{$DEFINE SUPPORTS_FOR_IN}
+{$DEFINE SUPPORTS_INLINE}
+{$DEFINE SUPPORTS_NESTED_CONSTANTS}
+{$DEFINE SUPPORTS_NESTED_TYPES}
+{$IFDEF CLR}
+{$DEFINE SUPPORTS_ENHANCED_RECORDS}
+{$DEFINE SUPPORTS_CLASS_FIELDS}
+{$DEFINE SUPPORTS_CLASS_HELPERS}
+{$DEFINE SUPPORTS_CLASS_OPERATORS}
+{$DEFINE SUPPORTS_STRICT}
+{$DEFINE SUPPORTS_STATIC}
+{$DEFINE SUPPORTS_FINAL}
+{$ENDIF CLR}
 {$ENDIF COMPILER9_UP}
 
 {$IFDEF COMPILER10_UP}
-  {$DEFINE SUPPORTS_ENHANCED_RECORDS}
-  {$DEFINE SUPPORTS_CLASS_FIELDS}
-  {$DEFINE SUPPORTS_CLASS_HELPERS}
-  {$DEFINE SUPPORTS_CLASS_OPERATORS}
-  {$DEFINE SUPPORTS_STRICT}
-  {$DEFINE SUPPORTS_STATIC}
-  {$DEFINE SUPPORTS_FINAL}
+{$DEFINE SUPPORTS_ENHANCED_RECORDS}
+{$DEFINE SUPPORTS_CLASS_FIELDS}
+{$DEFINE SUPPORTS_CLASS_HELPERS}
+{$DEFINE SUPPORTS_CLASS_OPERATORS}
+{$DEFINE SUPPORTS_STRICT}
+{$DEFINE SUPPORTS_STATIC}
+{$DEFINE SUPPORTS_FINAL}
 {$ENDIF COMPILER10_UP}
 
 {$IFDEF RTL140_UP}
-  {$IFDEF LINUX}
-    {$DEFINE HAS_UNIT_LIBC}
-  {$ENDIF LINUX}
-  {$DEFINE HAS_UNIT_RTLCONSTS}
-  {$DEFINE HAS_UNIT_TYPES}
-  {$DEFINE HAS_UNIT_VARIANTS}
-  {$DEFINE HAS_UNIT_STRUTILS}
-  {$DEFINE XPLATFORM_RTL}
+{$IFDEF LINUX}
+{$DEFINE HAS_UNIT_LIBC}
+{$ENDIF LINUX}
+{$DEFINE HAS_UNIT_RTLCONSTS}
+{$DEFINE HAS_UNIT_TYPES}
+{$DEFINE HAS_UNIT_VARIANTS}
+{$DEFINE HAS_UNIT_STRUTILS}
+{$DEFINE XPLATFORM_RTL}
 {$ENDIF RTL140_UP}
 
 {------------------------------------------------------------------------------}
@@ -919,63 +912,64 @@
 {------------------------------------------------------------------------------}
 
 {$IFNDEF CPU386}
-  {$DEFINE PUREPASCAL}
+{$DEFINE PUREPASCAL}
 {$ENDIF}
 
 {$IFDEF WIN32}
-  {$DEFINE MSWINDOWS} // predefined for D6+/BCB6+
-  {$DEFINE Win32API}
+{$DEFINE MSWINDOWS} // predefined for D6+/BCB6+
+{$DEFINE Win32API}
 {$ENDIF}
 
 {$IFDEF DELPHILANGUAGE}
-  {$IFDEF LINUX}
-    {$DEFINE UNIX}
-  {$ENDIF}
+{$IFDEF LINUX}
+{$DEFINE UNIX}
+{$ENDIF}
 
-  {$IFNDEF CONSOLE}
-    {$IFDEF LINUX}
-      {$DEFINE VisualCLX}
-    {$ENDIF}
-    {$IFNDEF VisualCLX}
-      {$DEFINE VCL}
-    {$ENDIF}
-  {$ENDIF ~CONSOLE}
+{$IFNDEF CONSOLE}
+{$IFDEF LINUX}
+{$DEFINE VisualCLX}
+{$ENDIF}
+{$IFNDEF VisualCLX}
+{$DEFINE VCL}
+{$ENDIF}
+{$ENDIF ~CONSOLE}
 {$ENDIF DELPHILANGUAGE}
 
 {------------------------------------------------------------------------------}
 { Compiler settings                                                            }
 {------------------------------------------------------------------------------}
 
-{$IFOPT A+} {$DEFINE ALIGN_ON} {$ENDIF}
-{$IFOPT B+} {$DEFINE BOOLEVAL_ON} {$ENDIF}
+{$IFOPT A+}{$DEFINE ALIGN_ON}{$ENDIF}
+{$IFOPT B+}{$DEFINE BOOLEVAL_ON}{$ENDIF}
 {$IFDEF COMPILER2_UP}
-  {$IFOPT C+} {$DEFINE ASSERTIONS_ON} {$ENDIF}
+{$IFOPT C+}{$DEFINE ASSERTIONS_ON}{$ENDIF}
 {$ENDIF}
-{$IFOPT D+} {$DEFINE DEBUGINFO_ON} {$ENDIF}
-{$IFOPT G+} {$DEFINE IMPORTEDDATA_ON} {$ENDIF}
+{$IFOPT D+}{$DEFINE DEBUGINFO_ON}{$ENDIF}
+{$IFOPT G+}{$DEFINE IMPORTEDDATA_ON}{$ENDIF}
 {$IFDEF COMPILER2_UP}
-  {$IFOPT H+} {$DEFINE LONGSTRINGS_ON} {$ENDIF}
+{$IFOPT H+}{$DEFINE LONGSTRINGS_ON}{$ENDIF}
 {$ENDIF}
 { HINTS }
-{$IFOPT I+} {$DEFINE IOCHECKS_ON} {$ENDIF}
+{$IFOPT I+}{$DEFINE IOCHECKS_ON}{$ENDIF}
 {$IFDEF COMPILER2_UP}
-  {$IFOPT J+} {$DEFINE WRITEABLECONST_ON} {$ENDIF}
+{$IFOPT J+}{$DEFINE WRITEABLECONST_ON}{$ENDIF}
 {$ENDIF}
-{$IFOPT L+} {$DEFINE LOCALSYMBOLS} {$ENDIF}
-{$IFOPT M+} {$DEFINE TYPEINFO_ON} {$ENDIF}
-{$IFOPT O+} {$DEFINE OPTIMIZATION_ON} {$ENDIF}
-{$IFOPT P+} {$DEFINE OPENSTRINGS_ON} {$ENDIF}
-{$IFOPT Q+} {$DEFINE OVERFLOWCHECKS_ON} {$ENDIF}
-{$IFOPT R+} {$DEFINE RANGECHECKS_ON} {$ENDIF}
+{$IFOPT L+}{$DEFINE LOCALSYMBOLS}{$ENDIF}
+{$IFOPT M+}{$DEFINE TYPEINFO_ON}{$ENDIF}
+{$IFOPT O+}{$DEFINE OPTIMIZATION_ON}{$ENDIF}
+{$IFOPT P+}{$DEFINE OPENSTRINGS_ON}{$ENDIF}
+{$IFOPT Q+}{$DEFINE OVERFLOWCHECKS_ON}{$ENDIF}
+{$IFOPT R+}{$DEFINE RANGECHECKS_ON}{$ENDIF}
 { REALCOMPATIBILITY }
-{$IFOPT T+} {$DEFINE TYPEDADDRESS_ON} {$ENDIF}
-{$IFOPT U+} {$DEFINE SAFEDIVIDE_ON} {$ENDIF}
-{$IFOPT V+} {$DEFINE VARSTRINGCHECKS_ON} {$ENDIF}
-{$IFOPT W+} {$DEFINE STACKFRAMES_ON} {$ENDIF}
+{$IFOPT T+}{$DEFINE TYPEDADDRESS_ON}{$ENDIF}
+{$IFOPT U+}{$DEFINE SAFEDIVIDE_ON}{$ENDIF}
+{$IFOPT V+}{$DEFINE VARSTRINGCHECKS_ON}{$ENDIF}
+{$IFOPT W+}{$DEFINE STACKFRAMES_ON}{$ENDIF}
 { WARNINGS }
-{$IFOPT X+} {$DEFINE EXTENDEDSYNTAX_ON} {$ENDIF}
+{$IFOPT X+}{$DEFINE EXTENDEDSYNTAX_ON}{$ENDIF}
 
 // for Delphi/BCB trial versions remove the point from the line below
 {.$UNDEF SUPPORTS_WEAKPACKAGEUNIT}
 
 {$ENDIF ~JEDI_INC}
+



From twm at mail.berlios.de  Fri Sep 25 16:38:05 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:38:05 +0200
Subject: [Dzchart-svncheckins] r337 - utilities/dzLib/trunk/dzAdoDb/src
Message-ID: <200909251438.n8PEc5Re011563@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:38:04 +0200 (Fri, 25 Sep 2009)
New Revision: 337

Modified:
   utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas
Log:
new method SplitConnectionString

Modified: utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas
===================================================================
--- utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas	2009-09-25 14:36:24 UTC (rev 336)
+++ utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas	2009-09-25 14:38:04 UTC (rev 337)
@@ -18,6 +18,15 @@
   TAdoServerType = (asUnknown, asJet, asMsSql, asOracle);
 
 type
+  TConnectionInfoRec = record
+    ServerType: TAdoServerType;
+    ServerName: string;
+    Database: string;
+    Username: string;
+    Parts: array of string;
+  end;
+
+type
   ///<summary> This TAdoConnection descendant solves the problem of Connections
   ///          staying open when opened in the designer. The Connected property
   ///          will never be saved to the .DFM file and therefore always be false.
@@ -29,6 +38,7 @@
     class function EditConnectionString(_ParentHandle: THandle; var _ConnectionString: string): boolean; overload;
     function DetermineServerType: TAdoServerType; overload;
     class function DetermineServerType(const _ConnectionString: string): TAdoServerType; overload;
+    class function SplitConnectionString(const _ConnectionString: string): TConnectionInfoRec;
   published
     procedure ClearConnectionObject;
     property Connected stored false;
@@ -71,21 +81,47 @@
   s: WideString;
 begin
   DataInit := CreateComObject(CLSID_DataLinks) as IDataInitialize;
-  if _ConnectionString <> '' then
-    begin
-      s := _ConnectionString;
-      DataInit.GetDataSource(nil, CLSCTX_INPROC_SERVER,
-        PWideChar(s), IUnknown, DataSource);
-    end;
+  if _ConnectionString <> '' then begin
+    s := _ConnectionString;
+    DataInit.GetDataSource(nil, CLSCTX_INPROC_SERVER,
+      PWideChar(s), IUnknown, DataSource);
+  end;
   DBPrompt := CreateComObject(CLSID_DataLinks) as IDBPromptInitialize;
   Result := Succeeded(DBPrompt.PromptDataSource(nil, _ParentHandle,
     DBPROMPTOPTIONS_PROPERTYSHEET, 0, nil, nil, IUnknown, DataSource));
-  if Result then
-    begin
-      InitStr := nil;
-      DataInit.GetInitializationString(DataSource, True, InitStr);
-      _ConnectionString := InitStr;
+  if Result then begin
+    InitStr := nil;
+    DataInit.GetInitializationString(DataSource, True, InitStr);
+    _ConnectionString := InitStr;
+  end;
+end;
+
+class function TdzAdoConnection.SplitConnectionString(const _ConnectionString: string): TConnectionInfoRec;
+var
+  sl: TStringList;
+  s: string;
+  i: Integer;
+begin
+  Result.ServerType := DetermineServerType(_ConnectionString);
+  sl := TStringList.Create;
+  try
+    sl.Delimiter := ';';
+    sl.StrictDelimiter := true;
+    sl.DelimitedText := _ConnectionString;
+    SetLength(Result.Parts, sl.Count);
+    for i := 0 to sl.Count - 1 do begin
+      Result.Parts[i] := sl[i];
+      s := sl.Names[i];
+      if SameText(s, 'User ID') then
+        Result.Username := sl.Values[s]
+      else if SameText(s, 'Data Source') then
+        Result.ServerName := sl.Values[s]
+      else if SameText(s, 'Initial Catalog') then
+        Result.Database := sl.Values[s];
     end;
+  finally
+    sl.Free;
+  end;
 end;
 
 function TdzAdoConnection.EditConnectionString(_ParentHandle: THandle): boolean;



From twm at mail.berlios.de  Fri Sep 25 16:38:41 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:38:41 +0200
Subject: [Dzchart-svncheckins] r338 - utilities/dzLib/trunk/dzAdoDb/src
Message-ID: <200909251438.n8PEcfr4011668@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:38:40 +0200 (Fri, 25 Sep 2009)
New Revision: 338

Modified:
   utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoQuery.pas
Log:
new methods Prepare and Unprepare

Modified: utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoQuery.pas
===================================================================
--- utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoQuery.pas	2009-09-25 14:38:04 UTC (rev 337)
+++ utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoQuery.pas	2009-09-25 14:38:40 UTC (rev 338)
@@ -22,11 +22,25 @@
   private
   protected
   public
+    procedure Prepare;
+    procedure Unprepare;
   published
     property Active stored false;
   end;
 
 implementation
 
+{ TdzAdoQuery }
+
+procedure TdzAdoQuery.Prepare;
+begin
+  Prepared := true;
+end;
+
+procedure TdzAdoQuery.Unprepare;
+begin
+  Prepared := false;
+end;
+
 end.
 



From twm at mail.berlios.de  Fri Sep 25 16:39:11 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:39:11 +0200
Subject: [Dzchart-svncheckins] r339 - utilities/dzLib/trunk/components
Message-ID: <200909251439.n8PEdBa9011760@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:39:10 +0200 (Fri, 25 Sep 2009)
New Revision: 339

Modified:
   utilities/dzLib/trunk/components/c_dzShellControls.pas
Log:
fixed memory leak

Modified: utilities/dzLib/trunk/components/c_dzShellControls.pas
===================================================================
--- utilities/dzLib/trunk/components/c_dzShellControls.pas	2009-09-25 14:38:40 UTC (rev 338)
+++ utilities/dzLib/trunk/components/c_dzShellControls.pas	2009-09-25 14:39:10 UTC (rev 339)
@@ -208,6 +208,7 @@
     procedure RefreshEvent;
   public
     constructor Create(AOwner: TComponent); override;
+    destructor Destroy; override;
     procedure Refresh(Node: TTreeNode);
     function SelectedFolder: TShellFolder;
     property AutoRefresh: boolean read FAutoRefresh write SetAutoRefresh;
@@ -1597,6 +1598,12 @@
   FLoadingRoot := False;
 end;
 
+destructor TdzCustomShellTreeView.Destroy;
+begin
+   FRootFolder.Free;
+  inherited;
+end;
+
 procedure TdzCustomShellTreeView.ClearItems;
 var
   I: Integer;



From twm at mail.berlios.de  Fri Sep 25 16:40:40 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:40:40 +0200
Subject: [Dzchart-svncheckins] r340 - utilities/dzLib/trunk/src
Message-ID: <200909251440.n8PEeeK5012046@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:40:37 +0200 (Fri, 25 Sep 2009)
New Revision: 340

Modified:
   utilities/dzLib/trunk/src/u_dzClassUtils.pas
Log:
* new procedures:
 - TStrings_GetObjectIndex
 - TObjectList_Extract
* renamed TIniFiles_* to TIniFile_*



Modified: utilities/dzLib/trunk/src/u_dzClassUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzClassUtils.pas	2009-09-25 14:39:10 UTC (rev 339)
+++ utilities/dzLib/trunk/src/u_dzClassUtils.pas	2009-09-25 14:40:37 UTC (rev 340)
@@ -10,6 +10,7 @@
 uses
   SysUtils,
   Classes,
+  Contnrs,
   IniFiles,
   u_dzTranslator;
 
@@ -48,6 +49,13 @@
 /// </summary>
 procedure TStrings_DeleteAndFreeObject(_Strings: TStrings; _Idx: integer);
 
+///<summary>
+/// searches the given Obj in _Strings.Objects (does a linear search)
+/// @param Obj is the object to search for
+/// @param Idx will contain the index of the item, if found. Only valid if result is true
+/// @returns true, if found, false otherwise
+function TStrings_GetObjectIndex(_Strings: TStrings; _Obj: pointer; out _Idx: integer): boolean;
+
 /// <summary>
 /// Free a TList object an all TObjects it contains
 /// NOTE: this function is obsolete, use contnrs.TObjectList instead!
@@ -55,6 +63,11 @@
 procedure TList_FreeWithItems(var _List: TList); deprecated; // use contnrs.TObjectList
 
 /// <summary>
+/// Extracts the Idx'th item from the list without freeing it.
+/// </summary>
+function TObjectList_Extract(_lst: TObjectList; _Idx: integer): TObject;
+
+/// <summary>
 /// Write a string to the stream
 /// @param Stream is the TStream to write to.
 /// @param s is the string to write
@@ -129,8 +142,12 @@
 /// reads a char from an ini file, if the value is longer than one char, it returns
 /// the first char, if it is empty, it returns the default
 /// </summary>
-function TIniFiles_ReadChar(_Ini: TCustomIniFile; const _Section, _Ident: string; _Default: char): char;
+function TIniFile_ReadChar(_Ini: TCustomIniFile; const _Section, _Ident: string; _Default: char): char;
 
+///<summary> Like TIniFile.ReadString but allows to specify whether to use the Default if the read string
+///          is empty. </summary>
+function TIniFile_ReadString(_Ini: TCustomIniFile; const _Section, _Ident: string; const _Default: string; _DefaultIfEmtpy: boolean = false): string;
+
 ///<summary>
 /// reads a string list from an ini file section of the form
 /// [section]
@@ -139,12 +156,24 @@
 /// Item1=blub
 /// @returns the number of strings read
 /// </summary>
-function TIniFiles_ReadStrings(_Ini: TCustomIniFile; const _Section: string; _st: TStrings): integer;
+function TIniFile_ReadStrings(_Ini: TCustomIniFile; const _Section: string; _st: TStrings): integer;
 
+///<summary>
+/// Tries to read a floating point value from the ini-file, always using '.' as decimal separator.
+/// @returns true, if a value could be read and converted
+///</summary>
+function TIniFile_ReadFloat(_Ini: TCustomIniFile; const _Section, _Ident: string; out _Value: extended): boolean;
+
+///<summary>
+/// Writes a floating point value to the ini-file, always using '.' as decimal separator.
+///</summary>
+procedure TIniFile_WriteFloat(_Ini: TCustomIniFile; const _Section, _Ident: string; _Value: extended);
+
 implementation
 
 uses
   StrUtils,
+  u_dzConvertUtils,
   u_dzStringUtils;
 
 function _(const _s: string): string; inline;
@@ -164,6 +193,20 @@
   end;
 end;
 
+function TObjectList_Extract(_lst: TObjectList; _Idx: integer): TObject;
+var
+  b: boolean;
+begin
+  b := _lst.OwnsObjects;
+  _lst.OwnsObjects := false;
+  try
+    Result := _lst[_Idx];
+    _lst.Delete(_Idx);
+  finally
+    _lst.OwnsObjects := b;
+  end;
+end;
+
 function TStrings_RemoveTrailingSpaces(_Strings: tStrings): boolean;
 var
   i: integer;
@@ -214,6 +257,20 @@
   _Strings.Delete(_Idx);
 end;
 
+function TStrings_GetObjectIndex(_Strings: TStrings; _Obj: pointer; out _Idx: integer): boolean;
+var
+  i: integer;
+begin
+  Result := false;
+  for i := 0 to _Strings.Count - 1 do begin
+    Result := (_Strings.Objects[i] = _Obj);
+    if Result then begin
+      _Idx := i;
+      exit;
+    end;
+  end;
+end;
+
 function TStream_WriteString(_Stream: TStream; const _s: string): integer;
 begin
   Result := _Stream.Write(pChar(_s)^, Length(_s));
@@ -234,7 +291,7 @@
   Len: byte;
 begin
   _Stream.Read(Len, SizeOf(Len));
-  Result[0] := Chr(Len);
+  Result[0] := AnsiChar(Chr(Len));
   if Len > 0 then
     _Stream.Read(Result[1], Len);
 end;
@@ -310,7 +367,7 @@
   end;
 end;
 
-function TIniFiles_ReadChar(_Ini: TCustomIniFile; const _Section, _Ident: string; _Default: char): char;
+function TIniFile_ReadChar(_Ini: TCustomIniFile; const _Section, _Ident: string; _Default: char): char;
 var
   s: string;
 begin
@@ -320,7 +377,14 @@
   Result := s[1];
 end;
 
-function TIniFiles_ReadStrings(_Ini: TCustomIniFile; const _Section: string; _st: TStrings): integer;
+function TIniFile_ReadString(_Ini: TCustomIniFile; const _Section, _Ident: string; const _Default: string; _DefaultIfEmtpy: boolean = false): string;
+begin
+  Result := _Ini.ReadString(_Section, _Ident, _Default);
+  if (Result = '') and _DefaultIfEmtpy then
+    Result := _Default;
+end;
+
+function TIniFile_ReadStrings(_Ini: TCustomIniFile; const _Section: string; _st: TStrings): integer;
 var
   i: integer;
 begin
@@ -329,5 +393,18 @@
     _st.Add(_Ini.ReadString(_Section, 'Item' + IntToStr(i), ''));
 end;
 
+function TIniFile_ReadFloat(_Ini: TCustomIniFile; const _Section, _Ident: string; out _Value: extended): boolean;
+var
+  s: string;
+begin
+  s := _Ini.ReadString(_Section, _Ident, '');
+  Result := TryStr2Float(s, _Value);
+end;
+
+procedure TIniFile_WriteFloat(_Ini: TCustomIniFile; const _Section, _Ident: string; _Value: extended);
+begin
+  _Ini.WriteString(_Section, _Ident, Float2Str(_Value));
+end;
+
 end.
 



From twm at mail.berlios.de  Fri Sep 25 16:42:05 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:42:05 +0200
Subject: [Dzchart-svncheckins] r341 - utilities/dzLib/trunk/src
Message-ID: <200909251442.n8PEg56C012224@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:42:03 +0200 (Fri, 25 Sep 2009)
New Revision: 341

Modified:
   utilities/dzLib/trunk/src/u_dzConvertUtils.pas
Log:
* new constant MaxLongWord
* new functions
 - LongWord2ByteArr
 - ByteArr2LongWord
 - Swap16
 - Swap32


Modified: utilities/dzLib/trunk/src/u_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2009-09-25 14:40:37 UTC (rev 340)
+++ utilities/dzLib/trunk/src/u_dzConvertUtils.pas	2009-09-25 14:42:03 UTC (rev 341)
@@ -1,4 +1,4 @@
-{GXFormatter.config=twm}
+{.GXFormatter.config=twm}
 /// <summary>
 /// Integer to string and string to integer conversion functions for decimal
 /// hexadecimal and custom number bases. This was taken from u_dzStringUtils
@@ -41,6 +41,7 @@
 const
   MinInt64 = Int64($8000000000000000);
   MaxInt64 = Int64($7FFFFFFFFFFFFFFF);
+  MaxLongWord = $FFFFFFFF;
 
 const
   /// <summary>
@@ -86,7 +87,7 @@
 
 // Str <-> Hex conversion
 /// <summary>
-/// Returns true if A is a valid hexadecimal (base 16) digit 
+/// Returns true if A is a valid hexadecimal (base 16) digit
 /// </summary>
 function isHexDigit(_a: char): boolean;
 /// <summary>
@@ -322,6 +323,35 @@
 /// </summary>
 function GetSystemDefaultLocaleSettings: TFormatSettings;
 
+///<summary>
+/// returns the long word split into an array of byte
+/// @param Value is the LongWord value to split
+/// @param MsbFirst, if true the most significant byte is the first in the array (Motorola format)
+///                  if false the least significatn byte is the first in the array (Intel format)
+///</summary>
+function LongWord2ByteArr(_Value: LongWord; _MsbFirst: boolean = false): TBytes;
+
+///<summary>
+/// returns the the array of byte combined into a LongWord
+/// @param Value is the array to combine
+/// @param MsbFirst, if true the most significant byte is the first in the array (Motorola format)
+///                  if false the least significatn byte is the first in the array (Intel format)
+///</summary>
+function ByteArr2LongWord(const _Arr: array of byte; _MsbFirst: boolean = false): LongWord;
+
+///<summary>
+/// returns a 16 bit in reversed byte order, e.g. $1234 => $3412)
+/// aka converts intel (little endian) to motorola (big endian) byte order format
+/// (This is just an alias for system.swap for consistency with Swap32.)
+///</summary
+function Swap16(_Value: word): word; inline;
+
+///<summary>
+/// returns a 32 bit value in reversed byte order e.g. $12345678 -> $78563412
+/// aka converts intel (little endian) to motorola (big endian) byte order format
+///</summary>
+function Swap32(_Value: LongWord): LongWord;
+
 implementation
 
 uses
@@ -715,6 +745,44 @@
   GetLocaleFormatSettings(GetUserDefaultLCID, Result);
 end;
 
+function LongWord2ByteArr(_Value: LongWord; _MsbFirst: boolean = false): TBytes;
+begin
+  SetLength(Result, SizeOf(_Value));
+  if _MsbFirst then begin
+    Result[0] := _Value shr 24 and $FF;
+    Result[1] := _Value shr 16 and $FF;
+    Result[2] := _Value shr 8 and $FF;
+    Result[3] := _Value shr 0 and $FF;
+  end else begin
+    Result[3] := _Value shr 24 and $FF;
+    Result[2] := _Value shr 16 and $FF;
+    Result[1] := _Value shr 8 and $FF;
+    Result[0] := _Value shr 0 and $FF;
+  end;
+end;
+
+function ByteArr2LongWord(const _Arr: array of byte; _MsbFirst: boolean = false): LongWord;
+begin
+  if Length(_Arr) <> SizeOf(Result) then
+    raise Exception.CreateFmt(_('Length of byte array (%d) does not match size of a LongWord (%d)'), [Length(_Arr), SizeOf(Result)]);
+  if _MsbFirst then begin
+    Result := _Arr[0] shl 24 + _Arr[1] shl 16 + _Arr[2] shl 8 + _Arr[3];
+  end else begin
+    Result := _Arr[3] shl 24 + _Arr[2] shl 16 + _Arr[1] shl 8 + _Arr[0];
+  end;
+end;
+
+function Swap16(_Value: word): word; inline;
+begin
+  Result := swap(_Value);
+end;
+
+function Swap32(_Value: LongWord): LongWord;
+asm
+  bswap eax
+end;
+
+
 initialization
   DZ_FORMAT_DECIMAL_POINT := GetUserDefaultLocaleSettings;
   DZ_FORMAT_DECIMAL_POINT.DecimalSeparator := '.';



From twm at mail.berlios.de  Fri Sep 25 16:44:23 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:44:23 +0200
Subject: [Dzchart-svncheckins] r342 - utilities/dzLib/trunk/src
Message-ID: <200909251444.n8PEiNJV012566@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:44:22 +0200 (Fri, 25 Sep 2009)
New Revision: 342

Modified:
   utilities/dzLib/trunk/src/u_dzDatasetHelpers.pas
Log:
new methods:
* TryFieldAsString
* TryFieldAsInteger
* TryFieldAsDouble
* FieldAsExtended
* TryFieldAsExended
* FieldAsDate
* FieldAsGuid
* TryFieldAsGuid
* MoveBy
* TrySetParamByName
* TrySetFieldValue
* ClearField
* HasField

Modified: utilities/dzLib/trunk/src/u_dzDatasetHelpers.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzDatasetHelpers.pas	2009-09-25 14:42:03 UTC (rev 341)
+++ utilities/dzLib/trunk/src/u_dzDatasetHelpers.pas	2009-09-25 14:44:22 UTC (rev 342)
@@ -10,7 +10,8 @@
   AdoDb,
   DB,
   DBTables,
-  u_dzTranslator;
+  u_dzTranslator,
+  u_dzGuidUtils;
 
 type
   ///<summary> Interface definition for the Dataset-Helper, the idea is to have simplified
@@ -19,52 +20,72 @@
   ///          that contain the table and field name rather than just saying
   ///          "Variant conversion error". </summary>
   IDatasetHelper = interface ['{756CC74A-1623-4FC4-A347-4CA3D90B4D69}']
-    ///<summary> return the field value as a string, raise an exception if it cannot be converted </summary>
+    ///<summary> returns the field value as a string, raise an exception if it cannot be converted,
+    ///          Note that strings are automatically trimmed. </summary>
     function FieldAsString(const _Fieldname: string): string; overload;
-    ///<summary> return the field value as a string, return the default if it cannot be converted </summary>
+    ///<summary> returns the field value as a string, return the default if it cannot be converted
+    ///          Note that strings are automatically trimmed. </summary>
     function FieldAsString(const _Fieldname, _Default: string): string; overload;
+    function TryFieldAsString(const _Fieldname: string; out _Value: string): boolean;
     ///<summary> sets the field as a string, if the value is empty set it to NULL </summary>
     procedure SetFieldStringNotEmpty(const _Fieldname: string; const _Value: string);
 
-    ///<summary> return the field value as an integer, raise an exception if it cannot be converted </summary>
+    ///<summary> returns the field value as an integer, raise an exception if it cannot be converted </summary>
     function FieldAsInteger(const _Fieldname: string): integer; overload;
-    ///<summary> return the field value as an integer, return the default if it cannot be converted </summary>
+    ///<summary> returns the field value as an integer, return the default if it cannot be converted </summary>
     function FieldAsInteger(const _Fieldname: string; _Default: integer): integer; overload;
-    ///<summary> return the field value as an integer, raise an exception with the given error message if it cannot be converted </summary>
+    ///<summary> returns the field value as an integer, raise an exception with the given error message if it cannot be converted </summary>
     function FieldAsInteger(const _Fieldname: string; const _Error: string): integer; overload;
+    function TryFieldAsInteger(const _Fieldname: string; out _Value: integer): boolean;
 
-    ///<summary> return the field value as a double, raise an exception if it cannot be converted </summary>
+    ///<summary> returns the field value as a double, raise an exception if it cannot be converted </summary>
     function FieldAsDouble(const _Fieldname: string): double; overload;
-    ///<summary> return the field value as a double, return the default if it cannot be converted </summary>
+    ///<summary> returns the field value as a double, return the default if it cannot be converted </summary>
     function FieldAsDouble(const _Fieldname: string; const _Default: double): double; overload;
-    ///<summary> return the field value as a double, raise an exception with the given error message if it cannot be converted </summary>
+    ///<summary> returns the field value as a double, raise an exception with the given error message if it cannot be converted </summary>
     function FieldAsDouble(const _Fieldname: string; const _Error: string): double; overload;
+    function TryFieldAsDouble(const _Fieldname: string; out _Value: double): boolean;
 
-    ///<summary> return the field value as a TDateTime, raise an exception if it cannot be converted </summary>
-    function FieldAsDate(const _Fieldname: string): TDateTime;
+    ///<summary> returns the field value as an extended, raise an exception if it cannot be converted </summary>
+    function FieldAsExtended(const _Fieldname: string): extended; overload;
+    ///<summary> returns the field value as a extended, return the default if it cannot be converted </summary>
+    function FieldAsExtended(const _Fieldname: string; const _Default: extended): extended; overload;
+    ///<summary> returns the field value as a extended, raise an exception with the given error message if it cannot be converted </summary>
+    function FieldAsExtended(const _Fieldname: string; const _Error: string): extended; overload;
+    function TryFieldAsExtended(const _Fieldname: string; out _Value: extended): boolean;
+
+    ///<summary> returns the field value as a TDateTime, raise an exception if it cannot be converted </summary>
+    function FieldAsDate(const _Fieldname: string): TDateTime; overload;
+    function FieldAsDate(const _Fieldname: string; _Default: TDateTime): TDateTime; overload;
     function TryFieldAsDate(const _Fieldname: string; out _Date: TDateTime): boolean;
 
-    ///<summary> return the field value as a boolean, raise an exception if it cannot be converted </summary>
+    ///<summary> returns the field value as a boolean, raise an exception if it cannot be converted </summary>
     function FieldAsBoolean(const _FieldName: string): boolean; overload;
-    ///<summary> return the field value as a boolean, return the default if it cannot be converted </summary>
+    ///<summary> returns the field value as a boolean, return the default if it cannot be converted </summary>
     function FieldAsBoolean(const _FieldName: string; _Default: boolean): boolean; overload;
-
-    ///<summary> Open the dataset </summary>
+    ///<summary> returns the field value as a TNullableGuid record, note that the guid might be
+    ///          invalid if the field contained NULL </summary>
+    function FieldAsGuid(const _FieldName: string): TNullableGuid;
+    ///<summary> tries to convert the field to a GUID, returns false, if that's not possible </summary>
+    function TryFieldAsGuid(const _Fieldname: string; out _Value: TNullableGuid): boolean;
+    ///<summary> Opens the dataset </summary>
     procedure Open;
-    ///<summary> Close the dataset </summary>
+    ///<summary> Closes the dataset </summary>
     procedure Close;
 
-    ///<summary> Move to the first record of the dataset </summary>
+    ///<summary> Moves to the first record of the dataset </summary>
     procedure First;
-    ///<summary> Move to the last record of the dataset </summary>
+    ///<summary> Moves to the last record of the dataset </summary>
     procedure Last;
-    ///<summary> Move to the next record of the dataset, returns true if not EOF </summary>
+    ///<summary> Moves to the next record of the dataset, returns true if not EOF </summary>
     function Next: boolean;
-    ///<summary> Move to the previous record of the dataset, returns true if not BOF </summary>
+    ///<summary> Moves to the previous record of the dataset, returns true if not BOF </summary>
     function Prior: boolean;
-    ///<summary> True if at the end of the dataset </summary>
+    ///<summary> Moves by Distance records (can be negative), returns the number of records actually moved </summary>
+    function MoveBy(_Distance: integer): integer;
+    ///<summary> Returns true if at the end of the dataset </summary>
     function Eof: boolean;
-    ///<summary> True if at the beginning of the dataset </summary>
+    ///<summary> Returns true if at the beginning of the dataset </summary>
     function Bof: boolean;
 
     ///<summary> insert a new record into the dataset </summary>
@@ -82,11 +103,16 @@
     function IsEmpty: boolean;
     function Locate(const _KeyFields: string; const _KeyValues: Variant; _Options: TLocateOptions): boolean;
     procedure SetParamByName(const _Param: string; _Value: variant);
+    function TrySetParamByName(const _Param: string; _Value: variant): boolean;
 
     ///<summary> returns the field value as variant (getter method for FieldValues property) </summary>
     function GetFieldValue(const _FieldName: string): Variant;
     ///<summary> sets the field value as variant (setter method for FieldValues property) </summary>
     procedure SetFieldValue(const _FieldName: string; const _Value: Variant);
+    function TrySetFieldValue(const _FieldName: string; const _Value: Variant): boolean;
+    procedure ClearField(const _Fieldname: string);
+
+    function HasField(const _Fieldname: string): boolean;
     ///<summary> allows access to field values as variants </summary>
     property FieldValues[const _FieldName: string]: Variant read GetFieldValue write SetFieldValue; default;
   end;
@@ -111,22 +137,34 @@
   public // implementation of IDatasetHelper, see there for a description
     function FieldAsString(const _Fieldname: string): string; overload;
     function FieldAsString(const _Fieldname, _Default: string): string; overload;
+    function TryFieldAsString(const _Fieldname: string; out _Value: string): boolean;
     procedure SetFieldStringNotEmpty(const _Fieldname: string; const _Value: string);
 
     function FieldAsInteger(const _Fieldname: string): integer; overload;
     function FieldAsInteger(const _Fieldname: string; _Default: integer): integer; overload;
     function FieldAsInteger(const _Fieldname: string; const _Error: string): integer; overload;
+    function TryFieldAsInteger(const _Fieldname: string; out _Value: integer): boolean;
 
     function FieldAsDouble(const _Fieldname: string): double; overload;
     function FieldAsDouble(const _Fieldname: string; const _Default: double): double; overload;
     function FieldAsDouble(const _Fieldname: string; const _Error: string): double; overload;
+    function TryFieldAsDouble(const _Fieldname: string; out _Value: double): boolean;
 
-    function FieldAsDate(const _Fieldname: string): TDateTime;
+    function FieldAsExtended(const _Fieldname: string): extended; overload;
+    function FieldAsExtended(const _Fieldname: string; const _Default: extended): extended; overload;
+    function FieldAsExtended(const _Fieldname: string; const _Error: string): extended; overload;
+    function TryFieldAsExtended(const _Fieldname: string; out _Value: extended): boolean;
+
+    function FieldAsDate(const _Fieldname: string): TDateTime; overload;
+    function FieldAsDate(const _Fieldname: string; _Default: TDateTime): TDateTime; overload;
     function TryFieldAsDate(const _Fieldname: string; out _Date: TDateTime): boolean;
 
     function FieldAsBoolean(const _FieldName: string): boolean; overload;
     function FieldAsBoolean(const _FieldName: string; _Default: boolean): boolean; overload;
 
+    function FieldAsGuid(const _FieldName: string): TNullableGuid;
+    function TryFieldAsGuid(const _Fieldname: string; out _Value: TNullableGuid): boolean;
+
     procedure Open;
     procedure Close;
 
@@ -135,6 +173,7 @@
 
     function Next: boolean;
     function Prior: boolean;
+    function MoveBy(_Distance: integer): integer;
 
     function Eof: boolean;
     function Bof: boolean;
@@ -151,9 +190,13 @@
 
     function Locate(const _KeyFields: string; const _KeyValues: Variant; _Options: TLocateOptions): boolean;
     procedure SetParamByName(const _Param: string; _Value: variant);
+    function TrySetParamByName(const _Param: string; _Value: variant): boolean;
 
     function GetFieldValue(const _FieldName: string): Variant;
     procedure SetFieldValue(const _FieldName: string; const _Value: Variant);
+    function TrySetFieldValue(const _FieldName: string; const _Value: Variant): boolean;
+    procedure ClearField(const _Fieldname: string);
+    function HasField(const _Fieldname: string): boolean;
     property FieldValues[const _FieldName: string]: Variant read GetFieldValue write SetFieldValue; default;
   end;
 
@@ -161,7 +204,7 @@
 
 uses
   Variants,
-  u_dzTranslator,
+  u_dzVariantUtils,
   u_dzMiscUtils;
 
 function _(const _s: string): string; inline;
@@ -213,11 +256,37 @@
   Result := Var2DateTimeEx(FDataset[_Fieldname], FTableName + '.' + _Fieldname);
 end;
 
+function TDatasetHelper.FieldAsDate(const _Fieldname: string; _Default: TDateTime): TDateTime;
+begin
+  if not TryFieldAsDate(_Fieldname, Result) then
+    Result := _Default;
+end;
+
 function TDatasetHelper.TryFieldAsDate(const _Fieldname: string; out _Date: TDateTime): boolean;
 begin
-  Result := TryVar2DateTime(FDataset[_Fieldname], _Date);
+  Result := not IsEmpty and TryVar2DateTime(FDataset[_Fieldname], _Date);
 end;
 
+function TDatasetHelper.TryFieldAsExtended(const _Fieldname: string; out _Value: extended): boolean;
+begin
+  Result := not IsEmpty and TryVar2Ext(FDataset[_Fieldname], _Value);
+end;
+
+function TDatasetHelper.TryFieldAsGuid(const _Fieldname: string; out _Value: TNullableGuid): boolean;
+begin
+  if IsEmpty then
+    Result := false
+  else begin
+    _Value.AssignVariant(FDataset[_Fieldname]);
+    Result := _Value.IsValid;
+  end;
+end;
+
+function TDatasetHelper.TryFieldAsInteger(const _Fieldname: string; out _Value: integer): boolean;
+begin
+  Result := not IsEmpty and TryVar2Int(FDataset[_Fieldname], _Value);
+end;
+
 function TDatasetHelper.FieldAsDouble(const _Fieldname: string): double;
 begin
   Result := Var2DblEx(FDataset[_Fieldname], FTableName + '.' + _Fieldname);
@@ -228,6 +297,26 @@
   Result := Var2DblEx(FDataset[_Fieldname], _Error);
 end;
 
+function TDatasetHelper.FieldAsExtended(const _Fieldname: string): extended;
+begin
+  Result := Var2ExtEx(FDataset[_Fieldname], FTableName + '.' + _Fieldname);
+end;
+
+function TDatasetHelper.FieldAsExtended(const _Fieldname: string; const _Default: extended): extended;
+begin
+  Result := Var2Ext(FDataset[_Fieldname], _Default);
+end;
+
+function TDatasetHelper.FieldAsExtended(const _Fieldname, _Error: string): extended;
+begin
+  Result := Var2ExtEx(FDataset[_Fieldname], _Error);
+end;
+
+function TDatasetHelper.FieldAsGuid(const _FieldName: string): TNullableGuid;
+begin
+  Result.AssignVariant(FDataset[_FieldName]);
+end;
+
 function TDatasetHelper.FieldAsInteger(const _Fieldname: string): integer;
 begin
   Result := Var2IntEx(FDataset[_Fieldname], FTableName + '.' + _Fieldname);
@@ -240,9 +329,14 @@
 
 function TDatasetHelper.FieldAsString(const _Fieldname: string): string;
 begin
-  Result := Var2StrEx(FDataset[_Fieldname], FTableName + '.' + _Fieldname);
+  Result := Trim(Var2StrEx(FDataset[_Fieldname], FTableName + '.' + _Fieldname));
 end;
 
+function TDatasetHelper.TryFieldAsString(const _Fieldname: string; out _Value: string): boolean;
+begin
+  Result := not IsEmpty and TryVar2Str(FDataset[_Fieldname], _Value);
+end;
+
 function TDatasetHelper.FieldAsBoolean(const _FieldName: string): boolean;
 begin
   Result := FieldAsInteger(_FieldName) <> 0;
@@ -250,17 +344,24 @@
 
 function TDatasetHelper.FieldAsDouble(const _Fieldname: string; const _Default: double): double;
 begin
-  Result := Var2Dbl(FDataset[_Fieldname], _Default);
+  if not TryFieldAsDouble(_Fieldname, Result) then
+    Result := _Default;
 end;
 
+function TDatasetHelper.TryFieldAsDouble(const _Fieldname: string; out _Value: double): boolean;
+begin
+  Result := not IsEmpty and TryVar2Dbl(FDataset[_Fieldname], _Value);
+end;
+
 function TDatasetHelper.FieldAsInteger(const _Fieldname: string; _Default: integer): integer;
 begin
-  Result := Var2Int(FDataset[_Fieldname], _Default);
+  if not TryFieldAsInteger(_Fieldname, Result) then
+    Result := _Default;
 end;
 
 function TDatasetHelper.FieldAsString(const _Fieldname, _Default: string): string;
 begin
-  Result := Var2Str(FDataset[_Fieldname], _Default);
+  Result := Trim(Var2Str(FDataset[_Fieldname], _Default));
 end;
 
 function TDatasetHelper.FieldAsBoolean(const _FieldName: string; _Default: boolean): boolean;
@@ -276,6 +377,11 @@
     FDataset[_Fieldname] := _Value;
 end;
 
+procedure TDatasetHelper.ClearField(const _Fieldname: string);
+begin
+  FDataset.Fields.FieldByName(_Fieldname).Clear
+end;
+
 procedure TDatasetHelper.Close;
 begin
   FDataset.Close;
@@ -318,23 +424,71 @@
   Result := FDataset[_FieldName];
 end;
 
+function TDatasetHelper.HasField(const _Fieldname: string): boolean;
+begin
+  Result := (FDataset.FindField(_Fieldname) <> nil);
+end;
+
 procedure TDatasetHelper.SetFieldValue(const _FieldName: string; const _Value: Variant);
 begin
   FDataset[_FieldName] := _Value;
 end;
 
+function TDatasetHelper.TrySetFieldValue(const _FieldName: string; const _Value: Variant): boolean;
+var
+  Field: TField;
+begin
+  Field := FDataset.FindField(_FieldName);
+  Result := Assigned(Field);
+  if Result then
+    Field.Value := _Value;
+end;
+
+type
+  THackAdoDataset = class(TCustomAdoDataset)
+  end;
+
 procedure TDatasetHelper.SetParamByName(const _Param: string; _Value: variant);
+var
+  i: Integer;
+  Hack: THackAdoDataset;
+  Query: TQuery;
 begin
-  if FDataset is TAdoDataset then
-    (FDataset as TADODataSet).Parameters.ParamByName(_Param).Value := _Value
-  else if FDataset is TAdoQuery then
-    (FDataset as TAdoQuery).Parameters.ParamByName(_Param).Value := _Value
-  else if FDataset is TQuery then
-    (FDataset as TQuery).ParamByName(_Param).Value := _Value
-  else
+  // Do not use ParamByName -> only works if param is unique
+  if FDataset is TCustomAdoDataset then begin
+    Hack := THackAdoDataset(FDataset);
+    for i := 0 to Hack.Parameters.Count - 1 do begin
+      if SameText(Hack.Parameters[i].Name, _Param) then
+        Hack.Parameters[i].Value := _Value;
+    end;
+  end else if FDataset is TQuery then begin
+    Query := (FDataset as TQuery);
+    for i := 0 to Query.Params.Count - 1 do
+      if SameText(Query.Params[i].Name, _Param) then
+        Query.Params[i].Value := _Value;
+  end else
     raise Exception.CreateFmt(_('SetParamByName is not supported for a %s (only TQuery and TAdoDataset descendants).'), [FDataset.ClassName]);
 end;
 
+function TDatasetHelper.TrySetParamByName(const _Param: string; _Value: variant): boolean;
+var
+  AdoParam: TParameter;
+  BdeParam: TParam;
+begin
+  if FDataset is TCustomAdoDataset then begin
+    AdoParam := THackAdoDataset(FDataset).Parameters.FindParam(_Param);
+    Result := Assigned(AdoParam);
+    if Result then
+      AdoParam.Value := _Value
+  end else if FDataset is TQuery then begin
+    BdeParam := (FDataset as TQuery).Params.FindParam(_Param);
+    Result := Assigned(BdeParam);
+    if Result then
+      BdeParam.Value := _Value;
+  end else
+    raise Exception.CreateFmt(_('SetParamByName is not supported for a %s (only TQuery and TAdoDataset descendants).'), [FDataset.ClassName]);
+end;
+
 procedure TDatasetHelper.Cancel;
 begin
   FDataset.Cancel;
@@ -366,6 +520,11 @@
   Result := FDataset.Locate(_KeyFields, _KeyValues, _Options);
 end;
 
+function TDatasetHelper.MoveBy(_Distance: integer): integer;
+begin
+  Result := FDataset.MoveBy(_Distance);
+end;
+
 procedure TDatasetHelper.Post;
 begin
   FDataset.Post;



From twm at mail.berlios.de  Fri Sep 25 16:47:48 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:47:48 +0200
Subject: [Dzchart-svncheckins] r343 - utilities/dzLib/trunk/src
Message-ID: <200909251447.n8PElm1C013157@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:47:44 +0200 (Fri, 25 Sep 2009)
New Revision: 343

Modified:
   utilities/dzLib/trunk/src/u_dzFileUtils.pas
Log:
* additional optional parameter MayHaveAttr for TSimpleDirEnumerator.Create
* Paramter FilesSkipped of TFileSystem.CopyMatchingFiles is now optional
* new optional parameter ExceptMask for TFileSystem.DeleteMatchingFiles
* new TFileSystem methods
 - FileExists
 - IsFileReadonly
* new function etpd (short for ExcludeTrailingPathDelimiter)


Modified: utilities/dzLib/trunk/src/u_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzFileUtils.pas	2009-09-25 14:44:22 UTC (rev 342)
+++ utilities/dzLib/trunk/src/u_dzFileUtils.pas	2009-09-25 14:47:44 UTC (rev 343)
@@ -73,7 +73,7 @@
     /// but the special '.' and '..' directories
     /// @param Mask is the file search mask and should include a path
     /// </summary>
-    constructor Create(const _Mask: string);
+    constructor Create(const _Mask: string; _MayHaveAttr: TFileAttributeSet = [faHidden, faSysFile, faVolumeID, faDirectory, faArchive]);
     /// <summary>
     /// Destructor, will call FindClose if necessary
     /// </summary>
@@ -81,7 +81,7 @@
     /// <summary>
     /// creates a TSimpleDirEnumerator, calls its FindAll method and frees it
     /// </summary>
-    class function Execute(const _Mask: string; _List: TStrings): integer;
+    class function Execute(const _Mask: string; _List: TStrings; _MayHaveAttr: TFileAttributeSet = [faHidden, faSysFile, faVolumeID, faDirectory, faArchive]): integer;
     /// <summary>
     /// Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
     /// calls.
@@ -431,10 +431,10 @@
     ///   the file is skipped or an exception is raised
     /// * If cfFailIfExists is not set and cfForceOverwrite is set, the function
     ///   will also try to overwrite readonly files.
-    /// if FilesSkipped is given, all skipped files will be added to that list
+    /// if FilesSkipped is given, all skipped files will be added to that list (may be nil)
     ///</summary>
     class function CopyMatchingFiles(const _Mask, _SrcDir, _DestDir: string; _Flags: TCopyFileFlagset;
-      _FilesSkipped: TStrings): integer;
+      _FilesSkipped: TStrings = nil): integer;
 
     /// <summary>
     /// Copies the file Source to Dest using the Windows MoveFileWithProgress function which
@@ -513,11 +513,14 @@
     /// @param Force is a boolean which controls whether this function will try to delete
     ///              readonly files, If true, it will use SetFileAttr to reset the
     ///              readonly attribut and try to delete the file again.
+    /// @param ExceptMask is a string contaning a mask for files not to delete even if they
+    ///                   match the Mask, defaults to an empty string meaning no exceptions.
+    ///                   The comparison is case insensitive.
     /// @returns the number of files that could not be deleted.
     /// @raises EOSError if there was an error and RaiseException was true
     /// </summary>
     class function DeleteMatchingFiles(const _Dir, _Mask: string;
-      _RaiseException: boolean = true; _Force: boolean = false): integer;
+      _RaiseException: boolean = true; _Force: boolean = false; _ExceptMask: string = ''): integer;
 
     /// <summary>
     /// tries to find a matching file
@@ -528,6 +531,8 @@
     /// </summary>
     class function FindMatchingFile(const _Mask: string; out _Filename: string): TMatchingFileResult;
 
+    class function FileExists(const _Filename: string): boolean;
+
     /// <summary>
     /// deletes an empty directory using the SysUtils function RemoveDir
     /// The function will fail if the directory is not empty.
@@ -595,6 +600,9 @@
     /// </summary>
     class function IsValidFilename(const _s: string; out _ErrPos: integer; _AllowDot: boolean = true): boolean; overload;
 
+    /// <summary> Returns true if the file exists and is readonly </summary>
+    class function IsFileReadonly(const _Filename: string): boolean;
+
     /// <summary>
     /// creates a backup of the file appending the current date and time to the base
     /// file name. See also TFileGenerationHandler.
@@ -686,9 +694,15 @@
 /// </summary>
 function itpd(const _Dirname: string): string; inline;
 
+///<summary>
+/// This is an abbreviation for ExcludeTrailingPathDelimiter
+///</summary>
+function etpd(const _Dirname: string): string; inline;
+
 implementation
 
 uses
+  Masks,
   u_dzMiscUtils,
   u_dzStringUtils,
   u_dzDateUtils;
@@ -703,13 +717,18 @@
   Result := IncludeTrailingPathDelimiter(_Dirname);
 end;
 
+function etpd(const _Dirname: string): string; inline;
+begin
+  Result := ExcludeTrailingPathDelimiter(_Dirname);
+end;
+
 { TSimpleDirEnumerator }
 
-constructor TSimpleDirEnumerator.Create(const _Mask: string);
+constructor TSimpleDirEnumerator.Create(const _Mask: string; _MayHaveAttr: TFileAttributeSet = [faHidden, faSysFile, faVolumeID, faDirectory, faArchive]);
 begin
   FMask := _Mask;
   FMustHaveAttr := [];
-  FMayHaveAttr := [faHidden, faSysFile, faVolumeID, faDirectory, faArchive];
+  FMayHaveAttr := _MayHaveAttr;
 end;
 
 destructor TSimpleDirEnumerator.Destroy;
@@ -718,15 +737,16 @@
   inherited;
 end;
 
-class function TSimpleDirEnumerator.Execute(const _Mask: string; _List: TStrings): integer;
+class function TSimpleDirEnumerator.Execute(const _Mask: string; _List: TStrings;
+  _MayHaveAttr: TFileAttributeSet = [faHidden, faSysFile, faVolumeID, faDirectory, faArchive]): integer;
 var
   enum: TSimpleDirEnumerator;
 begin
-  enum := TSimpleDirEnumerator.Create(_Mask);
+  enum := TSimpleDirEnumerator.Create(_Mask, _MayHaveAttr);
   try
     Result := enum.FindAll(_List);
   finally
-    enum.Free;
+    FreeAndNil(enum);
   end;
 end;
 
@@ -1142,12 +1162,12 @@
     end else
       Result := cfwOK;
   finally
-    Redir.Free;
+    FreeAndNil(Redir);
   end;
 end;
 
 class function TFileSystem.CopyMatchingFiles(const _Mask, _SrcDir, _DestDir: string;
-  _Flags: TCopyFileFlagset; _FilesSkipped: TStrings): integer;
+  _Flags: TCopyFileFlagset; _FilesSkipped: TStrings = nil): integer;
 var
   Files: TStringList;
   s: string;
@@ -1159,7 +1179,7 @@
   DestDirBs := itpd(_DestDir);
   Files := TStringList.Create;
   try
-    TSimpleDirEnumerator.Execute(SrcDirBs + _Mask, Files);
+    TSimpleDirEnumerator.Execute(SrcDirBs + _Mask, Files, [faHidden, faSysFile, faArchive]);
     for s in Files do begin
       if CopyFile(SrcDirBs + s, DestDirBs + s, _Flags) then
         Inc(Result)
@@ -1169,7 +1189,7 @@
       end;
     end;
   finally
-    Files.Free;
+    FreeAndNil(Files);
   end;
 end;
 
@@ -1218,7 +1238,7 @@
     end else
       Result := cfwOK;
   finally
-    Redir.Free;
+    FreeAndNil(Redir);
   end;
 end;
 
@@ -1243,7 +1263,7 @@
 end;
 
 class function TFileSystem.DeleteMatchingFiles(const _Dir, _Mask: string;
-  _RaiseException: boolean = true; _Force: boolean = false): integer;
+  _RaiseException: boolean = true; _Force: boolean = false; _ExceptMask: string = ''): integer;
 var
   sr: TSearchRec;
   Dir: string;
@@ -1251,20 +1271,35 @@
   Assert(_Dir <> '', 'Dir parameter must not be an empty string');
   Assert(_Mask <> '', 'Dir parameter must not be an empty string');
 
+  _ExceptMask := LowerCase(_ExceptMask);
   Result := 0;
   Dir := IncludeTrailingPathDelimiter(_Dir);
   if 0 = FindFirst(Dir + _Mask, faAnyFile, sr) then
     try
       repeat
-        if (sr.Name <> '.') and (sr.Name <> '..') and ((sr.Attr and (SysUtils.faVolumeID or SysUtils.faDirectory)) = 0) then
-          if not DeleteFile(Dir + sr.Name, _RaiseException, _Force) then
-            Inc(Result);
+        if (sr.Name <> '.') and (sr.Name <> '..') then
+          if ((sr.Attr and (SysUtils.faVolumeID or SysUtils.faDirectory)) = 0) then
+            if (_ExceptMask = '') or not MatchesMask(LowerCase(sr.Name), _ExceptMask) then
+              if not DeleteFile(Dir + sr.Name, _RaiseException, _Force) then
+                Inc(Result);
       until 0 <> FindNext(sr);
     finally
       FindClose(sr);
     end;
 end;
 
+class function TFileSystem.FileExists(const _Filename: string): boolean;
+var
+  OldErrorMode: Cardinal;
+begin
+  OldErrorMode := SetErrorMode(SEM_NOOPENFILEERRORBOX);
+  try
+    Result := SysUtils.FileExists(_Filename);
+  finally
+    SetErrorMode(OldErrorMode)
+  end;
+end;
+
 class function TFileSystem.FindMatchingFile(const _Mask: string; out _Filename: string): TMatchingFileResult;
 var
   sr: TSearchRec;
@@ -1380,10 +1415,21 @@
     sl.LoadFromFile(_Filename);
     Result := sl.Text;
   finally
-    sl.Free;
+    FreeAndNil(sl);
   end;
 end;
 
+class function TFileSystem.IsFileReadonly(const _Filename: string): boolean;
+var
+  Attributes: Word;
+begin
+  Result := False;
+  if FileExists(_Filename) then begin
+    Attributes := FileGetAttr(_Filename);
+    Result := ((Attributes and SysUtils.faReadOnly) <> 0);
+  end;
+end;
+
 class function TFileSystem.IsValidFilename(const _s: string; out _ErrPos: integer; _AllowDot: boolean = true): boolean;
 var
   i: Integer;
@@ -1658,7 +1704,7 @@
       end;
     end;
   finally
-    EnumA.Free;
+    FreeAndNil(EnumA);
   end;
 end;
 
@@ -1699,7 +1745,7 @@
       end;
     end;
   finally
-    EnumA.Free;
+    FreeAndNil(EnumA);
   end;
 end;
 



From twm at mail.berlios.de  Fri Sep 25 16:49:49 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:49:49 +0200
Subject: [Dzchart-svncheckins] r344 - utilities/dzLib/trunk/src
Message-ID: <200909251449.n8PEnnOK013428@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:49:47 +0200 (Fri, 25 Sep 2009)
New Revision: 344

Modified:
   utilities/dzLib/trunk/src/u_dzLogging.pas
Log:
* ILogger is now interface compatible to SmartInspect so it can be redirected to SmartInspect more easily
* can optionally use the JCL for getting (and logging) the stack trace

Modified: utilities/dzLib/trunk/src/u_dzLogging.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzLogging.pas	2009-09-25 14:47:44 UTC (rev 343)
+++ utilities/dzLib/trunk/src/u_dzLogging.pas	2009-09-25 14:49:47 UTC (rev 344)
@@ -1,4 +1,4 @@
-{GXFormatter.config=twm}
+{.GXFormatter.config=twm}
 {: Implements a logging interface which can be used in a procedural or OO way }
 unit u_dzLogging;
 
@@ -6,93 +6,126 @@
 
 interface
 
+uses
+  SysUtils,
+  Classes;
+
+{$WARN SYMBOL_DEPRECATED OFF}
+
 type
   {: supported log levels }
-  TLogLevel = (llError, llWarning, llInfo, llDebug, llTrace, llDump);
+  TLogLevel = (llDump, llTrace, llDebug, llInfo, llWarning, llError);
 
 type
-  {: Logger-Interface, must be implemented by all classes that are used for logging }
-  ILogger = interface
-    {: Logs a line
-       @param s is the string to log
-       @param Level is the log level, defaults to llDump }
-    procedure LogLine(const _s: string; _Level: TLogLevel = llDump);
-    {: Logs a string at error level }
+  {: used for callbacks }
+  TOnLog = procedure(const _s: string; _Level: TLogLevel) of object;
+
+type
+  ILogTrackMethod = interface ['{296AA9F4-599D-4338-849A-E648B1CD8E1E}']
+  end;
+
+type
+  ILogger = interface ['{BE5D915E-C384-4648-9272-621981A48AED}']
+    procedure LogLine(const _s: string; _Level: TLogLevel = llDump); deprecated; // use Log method instead
+    procedure LogException(_e: exception; const _Where: string = ''; _IncludeCallstack: boolean = true);
     procedure LogError(const _s: string);
-    {: Logs a string at warning level }
     procedure LogWarning(const _s: string);
-    {: Logs a string at info level }
     procedure LogInfo(const _s: string);
-    {: Logs a string at debug level }
     procedure LogDebug(const _s: string);
-    {: Logs a string at trace level }
     procedure LogTrace(const _s: string);
-    {: Logs a string at dump level }
     procedure LogDump(const _s: string);
-    {: Logs the entry into a procedure }
     procedure LogProcEnter(const _Proc: string = '');
-    {: Logs the exit from a procedure }
     procedure LogProcExit(const _Proc: string = '');
+    procedure SetCallback(_Callback: TOnLog);
+    // the following methods are now preferred because they are easier to use with code completion:
+    procedure Log(const _s: string; _Level: TLogLevel = llDump); // alternative to LogLine
+    procedure Error(const _s: string); // alternative to LogError
+    procedure Warning(const _s: string); // alternative to LogWarning
+    procedure Info(const _s: string); // alternative to LogInfo
+    procedure Debug(const _s: string); // alternative to LogDebug
+    procedure Dump(const _s: string); // alternative to LogDump
+    procedure MethodEnter(const _s: string = ''); // alternative to LogProcEnter
+    procedure MethodLeave(const _s: string = ''); // alternative to LogProcExit
+    function MethodTrack(const _Proc: string = ''): IInterface;
+    procedure ProcessEnter(const _s: string);
+    procedure ProcessLeave(const _s: string);
+    procedure ThreadEnter(const _s: string);
+    procedure ThreadLeave(const _s: string);
+
+    function CreateSession(const _SessionName: string): ILogger;
   end;
 
 type
   {: An abstract ancestor that can be used as an ancestor for classes implementing
-     the ILogger interface. Descendants then only need to override LogLine }
-  TAbstractLogger = class(TInterfacedObject)
+     the ILogger interface. Descendants then only need to override the Log method }
+  TAbstractLogger = class(TInterfacedObject, ILogger)
+  protected
+    FCallback: TOnLog;
+    procedure doCallback(const _s: string; _Level: TLogLevel);
   protected // implements ILogger
+    // the following methods are now preferred because they are easier to use with code completion:
+    ///<summary> This is the main logging method, all other methods eventually call Log
+    ///          In this implementation it does nothing but call doCallback which calls the registered
+    ///          callback event.
+    ///          Descendant classes should write to the log first and then call inherited. </summary>
+    procedure Log(const _s: string; _Level: TLogLevel = llDump); virtual;
+    procedure Error(const _s: string); inline;
+    procedure Warning(const _s: string); inline;
+    procedure Info(const _s: string); inline;
+    procedure Debug(const _s: string); inline;
+    procedure Dump(const _s: string); inline;
+    procedure MethodEnter(const _s: string = ''); virtual;
+    procedure MethodLeave(const _s: string = ''); virtual;
+
     {: Logs a line
        @param s is the string to log
        @param Level is the log level, defaults to llDump }
-    procedure LogLine(const _s: string; _Level: TLogLevel = llDump); virtual; abstract;
+    procedure LogLine(const _s: string; _Level: TLogLevel = llDump); virtual; deprecated; // use Log method instead
+    procedure LogException(_e: exception; const _Where: string = ''; _IncludeCallstack: boolean = true);
     {: Logs a string at error level }
-    procedure LogError(const _s: string);
+    procedure LogError(const _s: string); deprecated;
     {: Logs a string at warning level }
-    procedure LogWarning(const _s: string);
+    procedure LogWarning(const _s: string); deprecated;
     {: Logs a string at info level }
-    procedure LogInfo(const _s: string);
+    procedure LogInfo(const _s: string); deprecated;
     {: Logs a string at debug level }
-    procedure LogDebug(const _s: string);
+    procedure LogDebug(const _s: string); deprecated;
     {: Logs a string at trace level }
-    procedure LogTrace(const _s: string);
+    procedure LogTrace(const _s: string); deprecated;
     {: Logs a string at dump level }
-    procedure LogDump(const _s: string);
+    procedure LogDump(const _s: string); deprecated;
     {: Logs the entry into a procedure }
-    procedure LogProcEnter(const _Proc: string = '');
+    procedure LogProcEnter(const _Proc: string = ''); deprecated;
     {: Logs the exit from a procedure }
-    procedure LogProcExit(const _Proc: string = '');
+    procedure LogProcExit(const _Proc: string = ''); deprecated;
+
+    function MethodTrack(const _Proc: string = ''): IInterface; virtual;
+
+    procedure ProcessEnter(const _s: string); virtual;
+    procedure ProcessLeave(const _s: string); virtual;
+
+    procedure ThreadEnter(const _s: string); virtual;
+    procedure ThreadLeave(const _s: string); virtual;
+
+    procedure SetCallback(_Callback: TOnLog); virtual;
+    function CreateSession(const _SessionName: string): ILogger; virtual;
   end;
 
 type
-  {: used for the OnLogLine event the TEventLogger class }
-  TOnLogLine = procedure(const _s: string; _Level: TLogLevel) of object;
-  {: used for the OnLogLineNoLevel event the TEventLogger class }
-  TOnLogLineNoLevel = procedure(const _s: string) of object;
-
-type
-  {: Implements the ILogger interface by sending all logging calls to
-     an event handler }
+  {: Implements the ILogger interface by sending all logging calls to an event handler }
   TEventLogger = class(TAbstractLogger, ILogger)
   private
-    {: Normal OnLogLine event, called from the LogLine method }
-    FOnLogLine: TOnLogLine;
-    {: simplified OnLogLine event, ignores the level }
-    FOnLogLineNoLevel: TOnLogLineNoLevel;
-    {: used internally if the constructor is called with a TOnLogLineNoLevel event
-       to redirect logging to this event }
-    procedure LogLineNoLevel(const _s: string; _Level: TLogLevel);
+    {: OnLogLine event, called from the LogLine method }
+    FOnLog: TOnLog;
     {: used internally when Disconnect is called }
-    procedure LogLineIgnore(const _s: string; _Level: TLogLevel);
+    procedure LogIgnore(const _s: string; _Level: TLogLevel);
   protected
     {: calls the FOnLogLine event }
-    procedure LogLine(const _s: string; _Level: TLogLevel = llDump); override;
+    procedure Log(const _s: string; _Level: TLogLevel = llDump); override;
   public
     {: Default constructor, creates a TEventLogger instance and sets the
-       FOnLogLine field }
-    constructor Create(_OnLogLine: TOnLogLine); overload;
-    {: simplified constructor, creates a TEventLogger instance, sets the
-       FOnLogLineNoLevel field and sets the FOnLogLine field to the LogLineNoLevel
-       method }
-    constructor Create(_OnLogLine: TOnLogLineNoLevel); overload;
+       FOnLog field }
+    constructor Create(_OnLog: TOnLog);
     {: disconnects the event by changing the FOnLogLine field to the LogLineIgnore method }
     procedure Disconnect;
   end;
@@ -102,19 +135,31 @@
      An instance of this class is automatically created and assigned to the gblLogger
      variable. }
   TNoLogging = class(TAbstractLogger, ILogger)
+    // This is just an alias for TAbstractLogger, it does not do any logging but calls
+    // the callback method.
+  end;
+
+type
+  TFileLogger = class(TAbstractLogger, ILogger)
+  private
+    FFilename: string;
+    FFileOpen: boolean;
+    FFile: TextFile;
+    function OpenFile(const _Filename: string): boolean;
   protected
-    {: does nothing }
-    procedure LogLine(const _s: string; _Level: TLogLevel = llDump); override;
+    procedure Log(const _s: string; _Level: TLogLevel = llDump); override;
+    function CreateSession(const _SessionName: string): ILogger; override;
+  public
+    constructor Create(const _Filename: string);
+    destructor Destroy; override;
   end;
 
-var
-  {: Global ILogger interface, automtically initialized to a TNoLogging class }
-  gblLogger: ILogger = nil;
-
 {: procedureal interface for calling the gblLogger.LogLine method }
 procedure LogLine(const _s: string; _Level: TLogLevel = llDump);
 {: procedureal interface for calling the gblLogger.LogError method }
 procedure LogError(const _s: string);
+{: procedureal interface for calling the gblLogger.LogException method }
+procedure LogException(_e: exception; const _Where: string = ''; _IncludeCallstack: boolean = true);
 {: procedureal interface for calling the gblLogger.LogWarning method }
 procedure LogWarning(const _s: string);
 {: procedureal interface for calling the gblLogger.LogInfo method }
@@ -129,9 +174,40 @@
 procedure LogProcEnter(const _Proc: string = '');
 {: procedureal interface for calling the gblLogger.LogProcExit method }
 procedure LogProcExit(const _Proc: string = '');
+{: procedureal interface for calling the gblLogger.MethodTrack method }
+function MethodTrack(const _Proc: string = ''): IInterface;
 
+function GetGlobalLogger: ILogger;
+procedure SetGlobalLogger(_Logger: ILogger);
+
+type
+  TOnGetCallstack = procedure(_sl: TStrings);
+const
+  gblOnGetCallstack: TOnGetCallstack = nil;
+
 implementation
 
+uses
+  Windows,
+  u_dzFileUtils;
+
+var
+  {: Global ILogger interface, automtically initialized to a TNoLogging class }
+  gblLogger: ILogger = nil;
+
+procedure SetGlobalLogger(_Logger: ILogger);
+begin
+  if _Logger = nil then
+    gblLogger := TNoLogging.Create
+  else
+    gblLogger := _Logger;
+end;
+
+function GetGlobalLogger: ILogger;
+begin
+  Result := gblLogger; // TRedirectToGlobalLogger.Create;
+end;
+
 procedure LogLine(const _s: string; _Level: TLogLevel = llDump);
 begin
   gblLogger.LogLine(_s, _Level);
@@ -142,6 +218,11 @@
   gblLogger.LogError(_s);
 end;
 
+procedure LogException(_e: exception; const _Where: string = ''; _IncludeCallstack: boolean = true);
+begin
+  gblLogger.LogException(_e, _Where, _IncludeCallstack);
+end;
+
 procedure LogWarning(const _s: string);
 begin
   gblLogger.LogWarning(_s);
@@ -177,8 +258,43 @@
   gblLogger.LogProcExit(_Proc);
 end;
 
+function MethodTrack(const _Proc: string = ''): IInterface;
+begin
+  Result := gblLogger.MethodTrack(_Proc);
+end;
+
+type
+  TLogProcEnterExit = class(TInterfacedObject, ILogTrackMethod)
+  private
+    FProc: string;
+    FLogger: ILogger;
+  public
+    constructor Create(_Logger: ILogger; const _Proc: string);
+    destructor Destroy; override;
+  end;
+
+{ TLogProcEnterExit }
+
+constructor TLogProcEnterExit.Create(_Logger: ILogger; const _Proc: string);
+begin
+  inherited Create;
+  FLogger := _Logger;
+  FProc := _Proc;
+end;
+
+destructor TLogProcEnterExit.Destroy;
+begin
+  FLogger.LogProcExit(FProc);
+  inherited;
+end;
+
 { TAbstractLogger }
 
+procedure TAbstractLogger.Log(const _s: string; _Level: TLogLevel);
+begin
+  doCallback(_s, _Level);
+end;
+
 procedure TAbstractLogger.LogDebug(const _s: string);
 begin
   LogLine(_s, llDebug);
@@ -194,11 +310,73 @@
   LogLine(_s, llError);
 end;
 
+procedure TAbstractLogger.LogException(_e: exception; const _Where: string; _IncludeCallstack: boolean);
+var
+  s: string;
+  sl: TStringList;
+begin
+  if _Where <> '' then
+    s := _Where + ': '
+  else
+    s := '';
+  LogError(s + _e.ClassName + ': ' + _e.Message);
+  if _IncludeCallstack and Assigned(gblOnGetCallstack) then begin
+    sl := TStringList.Create;
+    try
+      LogError('<begin call stack>');
+      gblOnGetCallstack(sl);
+      for s in sl do
+        LogError(s);
+      LogError('<end call stack>');
+    finally
+      sl.Free;
+    end;
+  end;
+end;
+
+function TAbstractLogger.CreateSession(const _SessionName: string): ILogger;
+begin
+  // The default implementation does not distinguish between sessions
+  // override this, to create a different ILogger instance for each session
+  Result := Self;
+end;
+
+procedure TAbstractLogger.Debug(const _s: string);
+begin
+  Self.Log(_s, llDebug);
+end;
+
+procedure TAbstractLogger.doCallback(const _s: string; _Level: TLogLevel);
+begin
+  if Assigned(FCallback) then
+    FCallback(_s, _Level);
+end;
+
+procedure TAbstractLogger.Dump(const _s: string);
+begin
+  Self.Log(_s, llDump);
+end;
+
+procedure TAbstractLogger.Error(const _s: string);
+begin
+  Self.Log(_s, llError);
+end;
+
+procedure TAbstractLogger.Info(const _s: string);
+begin
+  Self.Log(_s, llInfo);
+end;
+
 procedure TAbstractLogger.LogInfo(const _s: string);
 begin
   LogLine(_s, llInfo);
 end;
 
+procedure TAbstractLogger.LogLine(const _s: string; _Level: TLogLevel);
+begin
+  Self.Log(_s, _Level);
+end;
+
 procedure TAbstractLogger.LogProcEnter(const _Proc: string);
 begin
   LogLine('>>' + _Proc, llTrace);
@@ -219,48 +397,148 @@
   LogLine(_s, llWarning);
 end;
 
-{ TEventLogger }
+procedure TAbstractLogger.MethodEnter(const _s: string);
+begin
+  Self.LogProcEnter(_s);
+end;
 
-constructor TEventLogger.Create(_OnLogLine: TOnLogLine);
+procedure TAbstractLogger.MethodLeave(const _s: string);
 begin
-  inherited Create;
-  FOnLogLine := _OnLogLine;
+  Self.LogProcExit(_s);
 end;
 
-constructor TEventLogger.Create(_OnLogLine: TOnLogLineNoLevel);
+function TAbstractLogger.MethodTrack(const _Proc: string): IInterface;
 begin
+  MethodEnter(_Proc);
+  Result := TLogProcEnterExit.Create(Self as ILogger, _Proc);
+end;
+
+procedure TAbstractLogger.ProcessEnter(const _s: string);
+begin
+  Log('EnterProcess: ' + _s);
+end;
+
+procedure TAbstractLogger.ProcessLeave(const _s: string);
+begin
+  Log('ExitProcess: ' + _s);
+end;
+
+procedure TAbstractLogger.SetCallback(_Callback: TOnLog);
+begin
+  FCallback := _Callback;
+end;
+
+procedure TAbstractLogger.ThreadEnter(const _s: string);
+begin
+  Log('EnterThread: ' + _s);
+end;
+
+procedure TAbstractLogger.ThreadLeave(const _s: string);
+begin
+  Log('ExitThread: ' + _s);
+end;
+
+procedure TAbstractLogger.Warning(const _s: string);
+begin
+  Self.Log(_s, llWarning);
+end;
+
+{ TEventLogger }
+
+constructor TEventLogger.Create(_OnLog: TOnLog);
+begin
   inherited Create;
-  FOnLogLineNoLevel := _OnLogLine;
-  FOnLogLine := LogLineNoLevel;
+  FOnLog := _OnLog;
 end;
 
 procedure TEventLogger.Disconnect;
 begin
-  FOnLogLine := LogLineIgnore;
+  FOnLog := LogIgnore;
 end;
 
-procedure TEventLogger.LogLine(const _s: string; _Level: TLogLevel);
+procedure TEventLogger.Log(const _s: string; _Level: TLogLevel);
 begin
-  FOnLogLine(_s, _Level);
+  // FOnLog is always assigned since disconnect sets it to LogIngore rather than nil
+  FOnLog(_s, _Level);
 end;
 
-procedure TEventLogger.LogLineIgnore(const _s: string; _Level: TLogLevel);
+procedure TEventLogger.LogIgnore(const _s: string; _Level: TLogLevel);
 begin
   // ignore
 end;
 
-procedure TEventLogger.LogLineNoLevel(const _s: string; _Level: TLogLevel);
+{ TFileLogger }
+
+constructor TFileLogger.Create(const _Filename: string);
+var
+  Filename: string;
 begin
-  FOnLogLineNoLevel(_s);
+  inherited Create;
+  Filename := _Filename;
+  FFileOpen := OpenFile(Filename);
+  if not FFileOpen then begin
+    // alternatively try to write to %TEMP%
+    Filename := ExtractFileName(Filename);
+    FFileOpen := OpenFile(itpd(TFileSystem.GetTempPath) + Filename);
+    // if even that fails, give up, we just run without logging
+  end;
 end;
 
-{ TNoLogging }
+destructor TFileLogger.Destroy;
+begin
+  if FFileOpen then
+    CloseFile(FFile);
+  inherited;
+end;
 
-procedure TNoLogging.LogLine(const _s: string; _Level: TLogLevel);
+procedure TFileLogger.Log(const _s: string; _Level: TLogLevel);
+var
+  SystemTime: TSystemTime;
+  s: string;
 begin
-  // do nothing
+  if FFileOpen then begin
+    GetLocalTime(SystemTime);
+    with SystemTime do
+      s := Format('%.2d:%.2d:%.2d:%.3d', [wHour, wMinute, wSecond, wMilliSeconds]);
+    WriteLn(FFile, s + #9 + IntToStr(Ord(_Level)) + #9 + _s);
+    Flush(FFile);
+  end;
 end;
 
+function TFileLogger.OpenFile(const _Filename: string): boolean;
+var
+  Dir: string;
+begin
+  try
+    Dir := ExcludeTrailingPathDelimiter(ExtractFilePath(_Filename));
+    if (Dir <> '') then
+      ForceDirectories(Dir);
+
+    AssignFile(FFile, _Filename);
+    if FileExists(_Filename) then
+      Append(FFile)
+    else
+      Rewrite(FFile);
+    Result := true;
+    FFilename := _Filename;
+  except
+    Result := false;
+  end;
+end;
+
+function TFileLogger.CreateSession(const _SessionName: string): ILogger;
+var
+  ext: string;
+  Filename: string;
+begin
+  ext := ExtractFileExt(FFilename);
+  Filename := ChangeFileExt(FFilename, '');
+  Filename := Filename + '_' + _SessionName;
+  Filename := ChangeFileExt(Filename, ext);
+  Info('Opening log session "' + _SessionName + '" to file "' + Filename + '"');
+  Result := TFileLogger.Create(Filename);
+end;
+
 initialization
   gblLogger := TNoLogging.Create;
 end.



From twm at mail.berlios.de  Fri Sep 25 16:50:51 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:50:51 +0200
Subject: [Dzchart-svncheckins] r345 - utilities/dzLib/trunk/src
Message-ID: <200909251450.n8PEopNJ013657@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:50:50 +0200 (Fri, 25 Sep 2009)
New Revision: 345

Modified:
   utilities/dzLib/trunk/src/u_dzOsUtils.pas
Log:
* new function OsHasNTSecurity
* renamed CurrentUserIsAdmin to CurrentUserHasAdminRights


Modified: utilities/dzLib/trunk/src/u_dzOsUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzOsUtils.pas	2009-09-25 14:49:47 UTC (rev 344)
+++ utilities/dzLib/trunk/src/u_dzOsUtils.pas	2009-09-25 14:50:50 UTC (rev 345)
@@ -84,9 +84,13 @@
 
 procedure RegisterFileAssociation(const _Extension, _DocumentName, _OpenCommand: string);
 
-///<summary> Checks whether the currently logged on user (the one who runs this process) is an Administrator }
-function CurrentUserIsAdmin: Boolean;
+function OsHasNTSecurity: boolean;
 
+///<summary> Checks whether the currently logged on user (the one who runs this process) has administrator rights
+///          (In Win9x this always returns true, in WinNT+ it checks whether the user is member of the
+///          administrators group </summary>
+function CurrentUserHasAdminRights: Boolean;
+
 ///<summary> tries to open a file with the associated application
 ///          @param Filename is the name of the file to open
 ///          @returns true on success, false otherwise </summary>
@@ -325,6 +329,16 @@
     Result := 'unknown';
 end;
 
+function OsHasNTSecurity: boolean;
+var
+  vi: TOSVersionInfo;
+begin
+  FillChar(vi, SizeOf(vi), 0);
+  vi.dwOSVersionInfoSize := SizeOf(vi);
+  GetVersionEx(vi);
+  Result := (vi.dwPlatformId = VER_PLATFORM_WIN32_NT);
+end;
+
 const
   SECURITY_NT_AUTHORITY: SID_IDENTIFIER_AUTHORITY = (Value: (0, 0, 0, 0, 0, 5)); // ntifs
 
@@ -334,45 +348,57 @@
   DOMAIN_ALIAS_RID_GUESTS: DWORD = $00000222;
   DOMAIN_ALIAS_RID_POWER_: DWORD = $00000223;
 
-function CurrentUserIsAdmin: Boolean;
+function CurrentUserIsInAdminGroup: boolean;
 var
-  hAccessToken: THandle;
+  bSuccess: Boolean;
+  psidAdministrators: Pointer;
+  x: Integer;
   ptgGroups: PTokenGroups;
-  dwInfoBufferSize: DWORD;
-  psidAdministrators: PSID;
-  x: Integer;
-  bSuccess: BOOL;
+  hAccessToken: Cardinal;
+  dwInfoBufferSize: Cardinal;
 begin
   Result := False;
-  bSuccess := OpenThreadToken(GetCurrentThread, TOKEN_QUERY, True,
-    hAccessToken);
+  bSuccess := OpenThreadToken(GetCurrentThread, TOKEN_QUERY, True, hAccessToken);
   if not bSuccess then begin
     if GetLastError = ERROR_NO_TOKEN then
-      bSuccess := OpenProcessToken(GetCurrentProcess, TOKEN_QUERY,
-        hAccessToken);
+      bSuccess := OpenProcessToken(GetCurrentProcess, TOKEN_QUERY, hAccessToken);
   end;
   if bSuccess then begin
-    GetMem(ptgGroups, 1024);
-    bSuccess := GetTokenInformation(hAccessToken, TokenGroups,
-      ptgGroups, 1024, dwInfoBufferSize);
-    CloseHandle(hAccessToken);
-    if bSuccess then begin
-      AllocateAndInitializeSid(SECURITY_NT_AUTHORITY, 2,
-        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
-        0, 0, 0, 0, 0, 0, psidAdministrators);
+    try
+      GetMem(ptgGroups, 1024);
+      try
+        bSuccess := GetTokenInformation(hAccessToken, TokenGroups, ptgGroups, 1024, dwInfoBufferSize);
+        if bSuccess then begin
+          AllocateAndInitializeSid(SECURITY_NT_AUTHORITY, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, psidAdministrators);
+          try
 {$R-}
-      for x := 0 to ptgGroups.GroupCount - 1 do
-        if EqualSid(psidAdministrators, ptgGroups.Groups[x].Sid) then begin
-          Result := True;
-          Break;
+            for x := 0 to ptgGroups.GroupCount - 1 do
+              if EqualSid(psidAdministrators, ptgGroups.Groups[x].Sid) then begin
+                Result := True;
+                Break;
+              end;
+          finally
+{$R+}
+            FreeSid(psidAdministrators);
+          end;
         end;
-{$R+}
-      FreeSid(psidAdministrators);
+      finally
+        FreeMem(ptgGroups);
+      end;
+    finally
+      CloseHandle(hAccessToken);
     end;
-    FreeMem(ptgGroups);
   end;
 end;
 
+function CurrentUserHasAdminRights: Boolean;
+begin
+  if OsHasNTSecurity then
+    Result := CurrentUserIsInAdminGroup
+  else
+    Result := true;
+end;
+
 function ShellExecEx(const FileName: string; const Parameters: string;
   const Verb: string; CmdShow: Integer): Boolean;
 var



From twm at mail.berlios.de  Fri Sep 25 16:51:56 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:51:56 +0200
Subject: [Dzchart-svncheckins] r346 - utilities/dzLib/trunk/src
Message-ID: <200909251451.n8PEpuvn013940@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:51:55 +0200 (Fri, 25 Sep 2009)
New Revision: 346

Modified:
   utilities/dzLib/trunk/src/u_dzShellApiUtils.pas
Log:
new methods
 - GetCommonAppData / GetCommonAppDataDir
 - GetLocalAppData / GetLocalAppDataDir
 - GetAppData / GetAppDataDir

Modified: utilities/dzLib/trunk/src/u_dzShellApiUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzShellApiUtils.pas	2009-09-25 14:50:50 UTC (rev 345)
+++ utilities/dzLib/trunk/src/u_dzShellApiUtils.pas	2009-09-25 14:51:55 UTC (rev 346)
@@ -2,7 +2,7 @@
 ///<summary> implements an object with utility functions regarding the ShellAPI </summary>
 unit u_dzShellApiUtils;
 
-{$i jedi.inc}
+{$I jedi.inc}
 
 interface
 
@@ -46,10 +46,22 @@
     ///<summary> returns the 'common files' folder </summary>
     function GetCommonFiles: string;
     class function GetCommonFilesDir(_ApplicationHandle: THandle = 0): string;
-    ///<summary> returngs the 'program files' folder </summary>
+    ///<summary> returns the 'program files' folder </summary>
     function GetProgramFiles: string;
     class function GetProgramFilesDir(_ApplicationHandle: THandle = 0): string;
+    ///<summary> @returns the 'common files\Application Data' folder </summary>
+    function GetCommonAppData: string;
+    class function GetCommonAppDataDir(_ApplicationHandle: THandle = 0): string;
 
+    ///<summary> @returns the '<home>\Local Settings\Application Data' folder,
+    ///          or '' for oder Windows versions </summary>
+    function GetLocalAppData: string;
+    class function GetLocalAppDataDir(_ApplicationHandle: THandle = 0): string;
+
+    ///<summary> @returns the '<home>\Application Data' folder </summary>
+    function GetAppData: string;
+    class function GetAppDataDir(_ApplicationHandle: THandle = 0): string;
+
     function GetSystem32: string;
     class function GetSystem32Dir: string;
 
@@ -77,12 +89,11 @@
 begin
   Result := 0;
   Hdl := LoadLibrary('SHFOLDER.DLL');
-  if Hdl <> 0 then
-    begin
-      @SHGetFolderPath := GetProcAddress(Hdl, 'SHGetFolderPathA');
-      if @SHGetFolderPath <> nil then
-        Result := Hdl;
-    end;
+  if Hdl <> 0 then begin
+    @SHGetFolderPath := GetProcAddress(Hdl, 'SHGetFolderPathA');
+    if @SHGetFolderPath <> nil then
+      Result := Hdl;
+  end;
 end;
 
 function TWindowsShell.GetSpecialFolder(_CSIDL: Integer): string;
@@ -94,18 +105,15 @@
 begin
   ZeroMemory(@Path, SizeOf(Path));
   Hdl := LoadSHFolder(SHGetFolderPath);
-  if Hdl <> 0 then
-    begin
-      if Succeeded(SHGetFolderPath(Application.Handle, _CSIDL, 0, SHGFP_TYPE_CURRENT, Path)) then
-        Result := Path;
-      FreeLibrary(Hdl);
-    end
-  else
-    begin
-      if Succeeded(SHGetspecialfolderLocation(Application.Handle, _CSIDL, PIdl)) then
-        SHGetPathFromIDList(Pidl, Path);
+  if Hdl <> 0 then begin
+    if Succeeded(SHGetFolderPath(Application.Handle, _CSIDL, 0, SHGFP_TYPE_CURRENT, Path)) then
       Result := Path;
-    end;
+    FreeLibrary(Hdl);
+  end else begin
+    if Succeeded(SHGetspecialfolderLocation(Application.Handle, _CSIDL, PIdl)) then
+      SHGetPathFromIDList(Pidl, Path);
+    Result := Path;
+  end;
 end;
 
 { TWindowsShell }
@@ -160,6 +168,36 @@
   Result := GetSpecialFolder(CSIDL_MYPICTURES);
 end;
 
+function TWindowsShell.GetAppData: string;
+begin
+  Result := GetSpecialFolder(CSIDL_APPDATA);
+end;
+
+class function TWindowsShell.GetAppDataDir(_ApplicationHandle: THandle): string;
+begin
+  with TWindowsShell.Create(_ApplicationHandle) do
+    try
+      Result := GetAppData;
+    finally
+      Free;
+    end;
+end;
+
+function TWindowsShell.GetCommonAppData: string;
+begin
+  Result := GetSpecialFolder(CSIDL_COMMON_APPDATA);
+end;
+
+class function TWindowsShell.GetCommonAppDataDir(_ApplicationHandle: THandle): string;
+begin
+  with TWindowsShell.Create(_ApplicationHandle) do
+    try
+      Result := GetCommonAppData;
+    finally
+      Free;
+    end;
+end;
+
 function TWindowsShell.GetCommonFiles: string;
 begin
   Result := GetSpecialFolder(CSIDL_PROGRAM_FILES_COMMON);
@@ -175,6 +213,21 @@
     end;
 end;
 
+function TWindowsShell.GetLocalAppData: string;
+begin
+  Result := GetSpecialFolder(CSIDL_LOCAL_APPDATA);
+end;
+
+class function TWindowsShell.GetLocalAppDataDir(_ApplicationHandle: THandle): string;
+begin
+  with TWindowsShell.Create(_ApplicationHandle) do
+    try
+      Result := GetLocalAppData;
+    finally
+      Free;
+    end;
+end;
+
 function TWindowsShell.GetProgramFiles: string;
 begin
   Result := GetSpecialFolder(CSIDL_PROGRAM_FILES);
@@ -235,18 +288,16 @@
   GetSystemWindowsDirectoryA: TGetSystemWindowsDirectoryA;
 begin
   HModule := LoadLibrary(kernel32);
-  if HModule = 0 then
-    begin
+  if HModule = 0 then begin
+    Result := GetSysWindowsDir;
+    exit;
+  end;
+  try
+    GetSystemWindowsDirectoryA := GetProcAddress(HModule, 'GetSystemWindowsDirectoryA');
+    if not Assigned(GetSystemWindowsDirectoryA) then begin
       Result := GetSysWindowsDir;
       exit;
     end;
-  try
-    GetSystemWindowsDirectoryA := GetProcAddress(HModule, 'GetSystemWindowsDirectoryA');
-    if not Assigned(GetSystemWindowsDirectoryA) then
-      begin
-        Result := GetSysWindowsDir;
-        exit;
-      end;
     SetLength(Result, MAX_PATH);
     GetSystemWindowsDirectoryA(PChar(Result), Length(Result));
     Result := PChar(Result);



From twm at mail.berlios.de  Fri Sep 25 16:56:22 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:56:22 +0200
Subject: [Dzchart-svncheckins] r347 - utilities/dzLib/trunk/src
Message-ID: <200909251456.n8PEuLJ2015072@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:56:20 +0200 (Fri, 25 Sep 2009)
New Revision: 347

Modified:
   utilities/dzLib/trunk/src/u_dzStringUtils.pas
Log:
* new overloaded ReplaceChars that optionally allows to remove duplicates
* new functions LoadStringFromFile / SaveStringToFile
* new methods for TLineBuilder
 - AddQuoted
 - Formatted Add for floats
 - formatted Add for times
* TLineBuilder's FormatSettings can now be read

Modified: utilities/dzLib/trunk/src/u_dzStringUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzStringUtils.pas	2009-09-25 14:51:55 UTC (rev 346)
+++ utilities/dzLib/trunk/src/u_dzStringUtils.pas	2009-09-25 14:56:20 UTC (rev 347)
@@ -227,9 +227,14 @@
 function PosStr(const _SubStr, _s: string; _Start: integer): integer; deprecated;
 
 ///<summary> Replaces all occurences of characters in Search in S with the corresponding
-///          character in Replace. </summary>
-function ReplaceChars(const _s, _Search, _Replace: string): string;
+///          character in Replace. If there is no matching character in Replace,
+///          the character will be omitted. </summary>
+function ReplaceChars(const _s, _Search, _Replace: string): string; overload;
 
+///<summary> Replaces all occurences of characters in Search in S with the Replace string.
+///          If Replace is an empty string, the characters will be omitted. </summary>
+function ReplaceChars(const _s: string; _Search: TCharSet; const _Replace: string; _RemoveDuplicates: boolean = true): string; overload;
+
 ///<summary> Replaces all control characters (ord(c) < ord(' ')) with ReplaceChar.
 ///          If RemoveDuplicates is true, a sequence of control characters is replaced
 ///          by a single ReplaceChar. </summary>
@@ -322,6 +327,11 @@
 function GetUserDefaultLocaleSettings: TFormatSettings;
 function GetSystemDefaultLocaleSettings: TFormatSettings;
 
+///<summary> Read the content of the file into a string and return it </summary>
+function LoadStringFromFile(const _Filename: string): string;
+///<summary> Write the content of the string to a file </summary>
+procedure SaveStringToFile(const _Filename: string; const _Content: string);
+
 type
   ///<summary> Helper class for building a text line </summary>
   TLineBuilder = class
@@ -329,6 +339,7 @@
     FListSeparator: string;
     FContent: string;
     FFormatSettings: TFormatSettings;
+    FQuoteChar: char;
   public
     ///<summary> Creates a TLineBuilder instance with the given separator
     ///          @param ListSeparator is the separator string to use, defaults to TAB (#9)
@@ -339,12 +350,19 @@
     procedure Assign(_Source: TLineBuilder);
     ///<summary> Adds a string column </summary>
     procedure Add(const _Column: string); overload;
+    ///<summary> Adds a string column, putting it in quotes </summary>
+    procedure AddQuoted(const _Column: string);
     ///<summary> Adds an integer value column </summary>
     procedure Add(_IntValue: integer); overload;
     ///<summary> Adds a floating point value column with the given number of decimals </summary>
     procedure Add(_FloatValue: extended; _Decimals: integer); overload;
+    ///<summary> Adds a floating point value column with the given number of integer digits
+    ///          and the given number of fractional digits </summary>
+    procedure Add(_FloatValue: extended; _IntDigits, _FracDigits: integer); overload;
     ///<summary> Adds a column with a time in hh:mm:ss format </summary>
     procedure Add(_Hours, _Minutes, _Seconds: integer); overload;
+    ///<summary> Adds a column with a time in hh:mm:ss:tt format </summary>
+    procedure Add(_Hours, _Minutes, _Seconds, _Hundredth: integer); overload;
     ///<summary> Adds a boolean column, with 'Y' for true and 'N' for false </summary>
     procedure Add(_b: Boolean); overload;
     ///<summary> Clears the line </summary>
@@ -359,6 +377,8 @@
     property Content: string read FContent;
     property DecimalSeparator: char read FFormatSettings.DecimalSeparator write FFormatSettings.DecimalSeparator default '.';
     property ListSeparator: string read FListSeparator write FListSeparator;
+    property QuoteChar: char read FQuoteChar write FQuoteChar;
+    property FormatSettings: TFormatSettings read FFormatSettings;
   end;
 
 implementation
@@ -433,7 +453,7 @@
 end;
 
 function nthWordStartAndEnd(const _s: string; _WordNo: integer;
-  const _Delimiter: string; var _Start, _Ende: integer): boolean; overload;
+  const _Delimiter: AnsiString; var _Start, _Ende: integer): boolean; overload;
 var
   i: integer;
   DelimiterSet: TCharSet;
@@ -464,7 +484,7 @@
     Result := '';
 end;
 
-function ExtractFirstWord(var _s: string; _Delimiter: TCharSet): string; overload;
+function ExtractFirstWord(var _s: string; _Delimiter: TCharSet): string;
 begin
   if not ExtractFirstWord(_s, _Delimiter, Result) then begin // s contained only Delimiters
     Result := '';
@@ -480,7 +500,7 @@
   end;
 end;
 
-function ExtractFirstWord(var _s: string; const _Delimiter: string; out _FirstWord: string): boolean; overload;
+function ExtractFirstWord(var _s: string; const _Delimiter: string; out _FirstWord: string): boolean;
 var
   Start, Ende: integer;
 begin
@@ -491,7 +511,7 @@
   end;
 end;
 
-function ExtractFirstWord(var _s: string; _Delimiter: TCharSet; out _FirstWord: string): boolean; overload;
+function ExtractFirstWord(var _s: string; _Delimiter: TCharSet; out _FirstWord: string): boolean;
 var
   Start, Ende: integer;
 begin
@@ -541,6 +561,26 @@
   SetLength(Result, j - 1);
 end;
 
+function ReplaceChars(const _s: string; _Search: TCharSet; const _Replace: string; _RemoveDuplicates: boolean = true): string;
+var
+  i: LongInt;
+  Dup: boolean;
+begin
+  Result := '';
+  Dup := false;
+  for i := 1 to Length(_s) do begin
+    if _s[i] in _Search then begin
+      if not Dup or not _RemoveDuplicates then begin
+        Result := Result + _Replace;
+        Dup := true;
+      end;
+    end else begin
+      Result := Result + _s[i];
+      Dup := false;
+    end;
+  end;
+end;
+
 function ReplaceCtrlChars(const _s: string; _ReplaceChar: char; _RemoveDuplicates: boolean = true): string;
 var
   i: integer;
@@ -575,12 +615,12 @@
   Result := ReplaceCtrlChars(_s, ' ', _RemoveDuplicates);
 end;
 
-function HexEncodeControlChars(_Prefix: char; const _s: string; _ControlChars: TCharSet): string;
+function HexEncodeControlChars(_Prefix: Char; const _s: string; _ControlChars: TCharSet): string;
 var
   i: integer;
 begin
   Result := '';
-  Include(_ControlChars, _Prefix);
+  Include(_ControlChars, AnsiChar(_Prefix));
   for i := 1 to Length(_s) do begin
     if _s[i] in _ControlChars then
       Result := Result + Format('%s%.2x', [_Prefix, Ord(_s[i])]) // do not translate
@@ -857,7 +897,7 @@
   Result := ExtractStr(_Source, _Delimiters, _Substr, b);
 end;
 
-function ExtractStr(var _Source: string; _Delimiter: char; out _Substr: string; var _LastWasDelimiter: boolean): boolean; overload;
+function ExtractStr(var _Source: string; _Delimiter: char; out _Substr: string; var _LastWasDelimiter: boolean): boolean;
 begin
   Result := ExtractStr(_Source, [_Delimiter], _SubStr, _LastWasDelimiter);
 end;
@@ -1050,6 +1090,7 @@
   FFormatSettings := GetUserDefaultLocaleSettings;
   FFormatSettings.DecimalSeparator := _DecimalSeparator;
   FFormatSettings.ThousandSeparator := #0;
+  FQuoteChar := '"';
 end;
 
 procedure TLineBuilder.Add(_IntValue: integer);
@@ -1062,6 +1103,11 @@
   Add(FloatToStrF(_FloatValue, ffFixed, 18, _Decimals, FFormatSettings));
 end;
 
+procedure TLineBuilder.Add(_FloatValue: extended; _IntDigits, _FracDigits: integer);
+begin
+  Add(Format('%*.*f', [_IntDigits, _FracDigits, _FloatValue], FFormatSettings));
+end;
+
 procedure TLineBuilder.Add(const _Column: string);
 begin
   if FContent <> '' then
@@ -1069,24 +1115,34 @@
   FContent := FContent + _Column;
 end;
 
+function ZeroPadLeft(_Value: Integer; _Len: Integer): string;
+begin
+  Str(_Value, Result);
+  while Length(Result) < _Len do
+    Result := '0' + Result;
+end;
+
 procedure TLineBuilder.Add(_Hours, _Minutes, _Seconds: integer);
-
-  function ZeroPadLeft(_Value: Integer; _Len: Integer): string;
-  begin
-    Str(_Value, Result);
-    while Length(Result) < _Len do
-      Result := '0' + Result;
-  end;
-
 begin
   Add(ZeroPadLeft(_Hours, 2) + ':' + ZeroPadLeft(_Minutes, 2) + ':' + ZeroPadLeft(_Seconds, 2));
 end;
 
+procedure TLineBuilder.Add(_Hours, _Minutes, _Seconds, _Hundredth: integer);
+begin
+  Add(ZeroPadLeft(_Hours, 2) + ':' + ZeroPadLeft(_Minutes, 2) + ':' + ZeroPadLeft(_Seconds, 2)
+    + ':' + ZeroPadLeft(_Hundredth, 2));
+end;
+
 procedure TLineBuilder.Add(_b: Boolean);
 begin
   Add(IfThen(_B, 'Y', 'N'));
 end;
 
+procedure TLineBuilder.AddQuoted(const _Column: string);
+begin
+  Add(FQuoteChar + _Column + FQuoteChar);
+end;
+
 procedure TLineBuilder.Append(_Line: TLineBuilder);
 var
   s: string;
@@ -1135,5 +1191,31 @@
     FContent := s;
 end;
 
+function LoadStringFromFile(const _Filename: string): string;
+var
+  sl: TStringList;
+begin
+  sl := TStringList.Create;
+  try
+    sl.LoadFromFile(_Filename);
+    Result := sl.Text;
+  finally
+    sl.Free;
+  end;
+end;
+
+procedure SaveStringToFile(const _Filename: string; const _Content: string);
+var
+  sl: TStringList;
+begin
+  sl := TStringList.Create;
+  try
+    sl.Text := _Content;
+    sl.SaveToFile(_Filename);
+  finally
+    sl.Free;
+  end;
+end;
+
 end.
 



From twm at mail.berlios.de  Fri Sep 25 16:58:34 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:58:34 +0200
Subject: [Dzchart-svncheckins] r348 - utilities/dzLib/trunk/src
Message-ID: <200909251458.n8PEwYoH015612@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:58:33 +0200 (Fri, 25 Sep 2009)
New Revision: 348

Modified:
   utilities/dzLib/trunk/src/u_dzTranslator.pas
Log:
* new function dzGetText to avoid warnings in GetText utility
* new internal function TP_TryGlobalIgnoreClass which does not raise an exception if the class is already being ignored

Modified: utilities/dzLib/trunk/src/u_dzTranslator.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzTranslator.pas	2009-09-25 14:56:20 UTC (rev 347)
+++ utilities/dzLib/trunk/src/u_dzTranslator.pas	2009-09-25 14:58:33 UTC (rev 348)
@@ -24,7 +24,8 @@
   Classes;
 
 function _(const _s: string): string;
-function GetText(const _s: string): string;
+function GetText(const _s: string): string; inline;
+function dzGetText(const _s: string): string; inline;
 function DGetText(const _s: string; const _TextDomain: string = ''): string;
 ///<summary> use this if you pass variables rather than constants to avoid warnings in the dxgettext tool </summary>
 function dzDGetText(const _s: string; const _TextDomain: string = ''): string; inline;
@@ -52,7 +53,8 @@
 uses
   Controls,
   ActnList,
-  Graphics;
+  Graphics,
+  ExtCtrls;
 
 function _(const _s: string): string;
 begin
@@ -68,6 +70,11 @@
   Result := u_dzTranslator._(_s);
 end;
 
+function dzGetText(const _s: string): string;
+begin
+  Result := u_dzTranslator._(_s);
+end;
+
 function DGetText(const _s: string; const _TextDomain: string = ''): string;
 begin
 {$IFDEF gnugettext}
@@ -117,6 +124,15 @@
 {$ENDIF}
 end;
 
+function TP_TryGlobalIgnoreClass(_IgnClass: TClass): boolean;
+begin
+{$IFDEF gnugettext}
+  Result := gnugettext.TP_TryGlobalIgnoreClass(_IgnClass);
+{$ELSE}
+  Result := true;
+{$ENDIF}
+end;
+
 procedure TP_GlobalIgnoreClassProperty(_IgnClass: TClass; const _PropertyName: string);
 begin
 {$IFDEF gnugettext}
@@ -212,10 +228,11 @@
   AddDomainForResourceString('dzlib');
 
   // ignore these VCL properties / classes
+  TP_GlobalIgnoreClassProperty(TAction, 'Category');
   TP_GlobalIgnoreClassProperty(TControl, 'ImeName');
   TP_GlobalIgnoreClassProperty(TControl, 'HelpKeyword');
-  TP_GlobalIgnoreClassProperty(TAction, 'Category');
-  TP_GlobalIgnoreClass(TFont);
+  TP_TryGlobalIgnoreClass(TFont);
+  TP_GlobalIgnoreClassProperty(TNotebook, 'Pages');
 
 {$IFDEF TranslateReporting}
   { TODO -otwm -ccheck : This should not always be called because it links in all ReportBuilder units. }



From twm at mail.berlios.de  Fri Sep 25 16:59:16 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 16:59:16 +0200
Subject: [Dzchart-svncheckins] r349 - utilities/dzLib/trunk/src
Message-ID: <200909251459.n8PExGZH015811@sheep.berlios.de>

Author: twm
Date: 2009-09-25 16:59:12 +0200 (Fri, 25 Sep 2009)
New Revision: 349

Modified:
   utilities/dzLib/trunk/src/u_dzVariantUtils.pas
Log:
new function Var2Ext

Modified: utilities/dzLib/trunk/src/u_dzVariantUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzVariantUtils.pas	2009-09-25 14:58:33 UTC (rev 348)
+++ utilities/dzLib/trunk/src/u_dzVariantUtils.pas	2009-09-25 14:59:12 UTC (rev 349)
@@ -134,6 +134,13 @@
 ///          @raises EVariantConvertError if there is some other conversion error </summary>
 function Var2ExtEx(const _v: variant; const _Source: string): extended;
 
+///<summary> Converts a variant to an extended.
+///          If v is null or empty, it returns the Default.
+///          @param v Variant value to convert
+///          @param Default Value to return if v is empty or null
+///          @returns the extended value of v or the Default if v can not be converted </summary>
+function Var2Ext(const _v: variant; const _Default: extended): extended;
+
 ///<summary> Converts a variant to a TDateTime.
 ///          Raises an exception if v can not be converted.
 ///          @param v Variant value to convert
@@ -450,6 +457,12 @@
   end;
 end;
 
+function Var2Ext(const _v: variant; const _Default: extended): extended;
+begin
+  if not TryVar2Ext(_v, Result) then
+    Result := _Default
+end;
+
 function Var2DblStr(const _v: variant; const _NullValue: string = '*NULL*'): string;
 var
   Value: double;



From twm at mail.berlios.de  Fri Sep 25 17:05:12 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:05:12 +0200
Subject: [Dzchart-svncheckins] r350 - utilities/dzLib/trunk/src
Message-ID: <200909251505.n8PF5CAo016663@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:05:10 +0200 (Fri, 25 Sep 2009)
New Revision: 350

Modified:
   utilities/dzLib/trunk/src/u_dzVclUtils.pas
Log:
* new procedures
 - TBitBtn_GlyphFromString
 - TWinControl_Lock
 - TEdit_TextToDouble
 - TStatusBar_EnableLongSimpleText
 - TStatusBar_SetLongSimpleText
 - TStatusBar_GetClickedPanel
 - TComboBox_SelectWithoutChangeEvent
 - TControl_SetReadonly
 - TListBox_GetSelected
 - TListBox_UnselectAll
 - TCheckListBox_GetCheckedObjects
 - TListView_ClearWithObjects
 - TListView_UnselectAll
 - TListView_GetSelectedCount
 - TRadioGroup_GetButton
 - TButtonControl_GetChecked
 - TButtonControl_SetChecked
 - TButtonControl_SetCaption
 - TCursor_TemporaryChange
* new class Interposer class TLongSimpleTextStatusBar (used in TStatusBar_EnableLongSimpleText


Modified: utilities/dzLib/trunk/src/u_dzVclUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzVclUtils.pas	2009-09-25 14:59:12 UTC (rev 349)
+++ utilities/dzLib/trunk/src/u_dzVclUtils.pas	2009-09-25 15:05:10 UTC (rev 350)
@@ -18,6 +18,7 @@
   ExtCtrls,
   Grids,
   DbGrids,
+  Buttons,
   u_dzTranslator;
 
 type
@@ -52,6 +53,17 @@
 ///<summary> returns the global file formats list </summary>
 function GetFileFormats: TFileFormatsList;
 
+///<summary> Assigns the TBitBtn's glyph from the hex string (e.g. copied from .dfm)
+///          if ContainsLength is true, the first 4 bytes (8 characters) contain the length of the
+///          data (as is the case with the strings stored in the .dfm file) </summary>
+procedure TBitBtn_GlyphFromString(_btn: TBitBtn; const _GlyphStr: AnsiString; _ContainsLength: boolean = true);
+
+///<summary> This is meant as a replacement to the LockWindowUpate function which shouldn't really be used
+///          any more.
+///          @param Ctrl is a TWinControl which should be locked
+///          @returns an interface, if that interface is released, it will automatically unlock the control </summary>
+function TWinControl_Lock(_Ctrl: TWinControl): IInterface;
+
 ///<summary> checks whether the integer array contains the given element
 ///          @param Element is the integer to check for
 ///          @param Arr is the array to check
@@ -195,6 +207,12 @@
 ///          @raises EConvertError if the controls content could not be converted </summary>
 function TEdit_TextToDouble(_ed: TEdit; _FocusControl: boolean = true): double;
 
+///<summary> Tries to convert the edit control text to a double, if an error occurs, it changes it's
+///          color to ErrColor and returns false, otherwise it changes the color to OkColor and
+///          returns true. </summary>
+function TEdit_TryTextToDouble(_ed: TEdit; _OkColor: TColor = clWindow; _ErrColor: TColor = clYellow): boolean; overload;
+function TEdit_TryTextToDouble(_ed: TEdit; out _Value: double; _OkColor: TColor = clWindow; _ErrColor: TColor = clYellow): boolean; overload;
+
 ///<summary> Tries to convert the edit control text to an integer, if an error occurs, it raises
 ///          an exception and optionally focuses the control.
 ///          @param ed is the edit control
@@ -243,6 +261,34 @@
 ///          to display horizontal text in tabs on the left or right hand side </summary>
 procedure TTabControl_AdjustTabWidth(_TabControl: TTabControl; _Form: TForm; _MinWidth: integer = 80);
 
+///<summary> Enables longer SimpleText (longer than 127 characters)
+///          Call once to enable. Works, by adding a single panel with owner drawing and
+///          setting the StatusBar's OnDrawPanel to a custom drawing method.
+///          To make it work, you must use TStatusBar_SetLongSimpleText to set
+///          the text, or use TLongSimpleTextStatusBar as an interposer class. </summary>
+procedure TStatusBar_EnableLongSimpleText(_StatusBar: TStatusBar);
+
+///<summary> Set the SimpleText of the StatusBar and invalidate it to enforce a redraw </summary>
+procedure TStatusBar_SetLongSimpleText(_StatusBar: TStatusBar; const _Text: string);
+
+///<summary> call this function to determine which panel of a TStatusBar has been clicked
+//           Note: This assumes, that the status bar actually was clicked, so only call it
+//           from the status bar's OnClick, OnMouseDown or OnMouseUp event handlers
+//           If the status bar does not have any panels (e.g. SimplePanel=true), this function
+//           will return 0.
+function TStatusBar_GetClickedPanel(_sb: TStatusBar): integer;
+
+type
+  ///<summary> Interposer class for TStatusBar to allow longer than 127 characters in SimpleText </summary>
+  TLongSimpleTextStatusBar = class(TStatusBar)
+  private
+    function GetSimpleText: string;
+    procedure SetSimpleText(const Value: string);
+  published
+  public
+    property SimpleText: string read GetSimpleText write SetSimpleText;
+  end;
+
 ///<summary> sets the control and all its child controls Enabled property and changes their
 ///          caption to reflect this
 ///          @param Control is the TControl to change
@@ -273,8 +319,9 @@
 ///          @param FocusControl is a boolean which determines whether to focus the control
 ///                              if it does not contain a valid value, default = false
 ///          @returns true, if these out parameters are valid </summary>
+function TComboBox_GetSelectedObject(_cmb: TCustomCombobox; out _Obj: pointer; _FocusControl: boolean = false): boolean; overload; inline;
 function TComboBox_GetSelectedObject(_cmb: TCustomCombobox; out _Idx: integer;
-  out _Obj: pointer; _FocusControl: boolean = false): boolean;
+  out _Obj: pointer; _FocusControl: boolean = false): boolean; overload;
 
 ///<summary> Gets the caption of the selected combobox item
 ///          @param cmb is the TCustomCombobox (descendant) to read from
@@ -293,6 +340,14 @@
 ///          @returns the index of the newly selected item or -1 if it doesn't exist </summary>
 function TComboBox_Select(_cmb: TCustomComboBox; const _Item: string; _DefaultIdx: integer = -1): integer;
 
+///<summary> Selects an item (or no Item, if Idx = -1) without triggering an OnChange event </summary>
+procedure TComboBox_SelectWithoutChangeEvent(_cmb: TComboBox; _Idx: integer);
+
+///<summary> Sets the control to readonly by adding a TPanel as parent and disable it. Note that this does
+///          not grey out the control as the Enabled property would.
+///          This is meant for controls that do not have a readonly property like TComboBox or TCheckBox. </summary>
+procedure TControl_SetReadonly(_ctrl: TControl; _ReadOnly: boolean);
+
 ///<summary> Gets the object pointer of the selected listbox item
 ///          @param lst is the TCustomListbox (descendant) to read from
 ///          @param Idx is the listbox's ItemIndex, only valid if the function returns true
@@ -311,6 +366,12 @@
   _FocusControl: boolean = false): boolean; overload;
 function TListBox_GetSelected(_lb: TCustomListBox): string; overload;
 
+///<summary> @Returns the number of selected items in the ListBox
+///          @param Selected will contain the selected items as well as the
+///                          associated objects. May be passed as NIL if only the count
+///                          is required. </summary>
+function TListBox_GetSelected(_lb: TCustomListBox; _Selected: TStrings): integer; overload;
+
 ///<summary> Selects the item if it is in the list and returns the new ItemIndex
 ///          @param lb is the TCustomListbox (descendant) to use
 ///          @param Item is the item to select
@@ -326,17 +387,33 @@
 function TListBox_DeleteSelected(_lst: TCustomListbox): boolean; overload;
 function TListBox_DeleteSelected(_lst: TCustomListBox; out _s: string): boolean; overload;
 
+procedure TListBox_UnselectAll(_lb: TCustomListbox);
+
+///<summary> Frees all objects assigned to the list and then clears the list </summary>
+procedure TListbox_ClearWithObjects(_lst: TCustomListBox);
+
 ///<summary> Returns the nunber of items that are checked </summary>
 function TCheckListBox_GetCheckedCount(_clb: TCheckListBox): integer;
 procedure TCheckListBox_DeleteDisabled(_clb: TCheckListBox);
 procedure TCheckListBox_InvertCheckmarks(_clb: TCheckListBox; _IncludeDisabled: boolean = false);
 procedure TCheckListBox_UncheckAll(_clb: TCheckListBox);
 procedure TCheckListBox_CheckAll(_clb: TCheckListBox; _IncludeDisabled: boolean = false);
+///<summary> Returns the checked items and the objects associated in them
+///          @param clb is the TCheckListBox
+///          @param Checked is a TStrings to which the selected items and objects are to be added
+///          @param IncludeDisabled determines whether the disabled items should also be returned if they are checked
+///          @returns the number of Items in Checked </summary>
 function TCheckListBox_GetChecked(_clb: TCheckListBox; _Checked: TStrings; _IncludeDisabled: boolean = false): integer;
+///<summary> Returns the objects associated with the checked items
+///          @param clb is the TCheckListBox
+///          @param Objects is a TList to which the selected objects are to be added
+///          @param IncludeDisabled determines whether the disabled items should also be returned if they are checked
+///          @returns the number of Items in Objects </summary>
+function TCheckListBox_GetCheckedObjects(_clb: TCheckListBox; _Objects: TList; _IncludeDisabled: boolean = false): integer;
 ///<summary> Checks all items contained in the Checked string list
 ///          @param clb is the TCheckListBox to modify
 ///          @param Checked is a string list containing the items to be checked
-///          @param UnchekOthers determines whether any items not in the list should
+///          @param UncheckOthers determines whether any items not in the list should
 ///                 be unchecked (defaults to true).
 ///          @returns the number of items that have been checked. </summary>
 function TCheckListBox_SetChecked(_clb: TCheckListBox; _Checked: TStrings; _UncheckOthers: boolean = true): integer;
@@ -447,6 +524,34 @@
 ///          @param Form is the TForm to unmerge </summary>
 procedure UnMergeForm(_Form: TCustomForm); deprecated; // use a frame instead
 
+///<summary> free all lv.Items[n].Data objects and then clear the items </summary>
+procedure TListView_ClearWithObjects(_lv: TListView);
+
+///<summary> Unselect all items, if WithSelectEvents is false, OnSelectItem events will be temporarily
+///          disabled. </summary>
+procedure TListView_UnselectAll(_lv: TListView; _WithSelectEvents: boolean = true);
+
+///<summary> Returns the number of selected items in the ListView </summary>
+function TListView_GetSelectedCount(_lv: TListView): integer;
+
+///<summary> Returns the first item in the radio group with the caption ItemText </summary>
+function TRadioGroup_GetButton(_rg: TRadioGroup; _ItemText: string): TRadioButton; overload;
+///<summary> Returns the ItemIdx'th item in the radio group </summary>
+function TRadioGroup_GetButton(_rg: TRadioGroup; _ItemIdx: integer): TRadioButton; overload;
+
+///<summary> Returns the Checked value of a TCheckbox or TRadioButton (which both descend from TButtonControl) </summary>
+function TButtonControl_GetChecked(_bctrl: TButtonControl): boolean;
+
+///<summary> Sets the Checked value of a TCheckbox or TRadioButton (which both descend from TButtonControl) </summary>
+procedure TButtonControl_SetChecked(_bctrl: TButtonControl; _Value: boolean);
+
+///<summary> Sets the Caption value of a TCheckbox or TRadioButton (which both descend from TButtonControl) </summary>
+procedure TButtonControl_SetCaption(_bctrl: TButtonControl; _Value: string);
+
+///<summary> sets Screen.Cursor to NewCursor and restores it automatically when the returned interface
+///          goes out of scope </summary>
+function TCursor_TemporaryChange(_NewCursor: TCursor): IInterface;
+
 implementation
 
 uses
@@ -460,18 +565,46 @@
   rxGif,
 {$ENDIF GIFByRx}
   u_dzConvertUtils,
-  u_dzStringUtils;
+  u_dzStringUtils,
+  u_dzClassUtils;
 
+function _(const _s: string): string; inline;
+begin
+  Result := dzDGetText(_s, 'dzlib');
+end;
+
+procedure TBitBtn_GlyphFromString(_btn: TBitBtn; const _GlyphStr: AnsiString; _ContainsLength: boolean = true);
+var
+  st: TMemoryStream;
+  s: AnsiString;
+  Buf: array of byte;
+  res: Integer;
+  Size: integer;
+begin
+  if _ContainsLength then
+    s := LowerCase(Copy(_GlyphStr, 9))
+  else
+    s := LowerCase(_GlyphStr);
+  Size := Length(s) div 2;
+  SetLength(Buf, Size);
+  res := HexToBin(PAnsiChar(s), @Buf[0], Size);
+  if res <> Size then
+    raise Exception.CreateFmt(_('Glyph string contained invalid character at position %d.'), [res]);
+  st := TMemoryStream.Create;
+  try
+    st.Write(Buf[0], Size);
+    st.Position := 0;
+    _btn.Glyph.LoadFromStream(st);
+  finally
+    FreeAndNil(st);
+  end;
+end;
+
 // we need this to access protected methods
 type
   TGridHack = class(TCustomGrid);
   TDbGridHack = class(TCustomDbGrid);
 
-function _(const _s: string): string; inline;
-begin
-  Result := dzDGetText(_s, 'dzlib');
-end;
-
 function TGrid_GetText(_Grid: TCustomGrid; _IncludeFixed: boolean = false): string;
 var
   Selection: TGridRect;
@@ -512,11 +645,11 @@
         Content.Add(Line.Content);
       end;
     finally
-      Line.Free;
+      FreeAndNil(Line);
     end;
     Result := Content.Content;
   finally
-    Content.Free;
+    FreeAndNil(Content);
   end;
 end;
 
@@ -733,6 +866,25 @@
   end;
 end;
 
+function TEdit_TryTextToDouble(_ed: TEdit; out _Value: double; _OkColor: TColor = clWindow; _ErrColor: TColor = clYellow): boolean;
+var
+  s: string;
+begin
+  s := _ed.Text;
+  Result := TryStr2Float(s, _Value, #0);
+  if Result then
+    _ed.Color := _OkColor
+  else
+    _ed.Color := _ErrColor;
+end;
+
+function TEdit_TryTextToDouble(_ed: TEdit; _OkColor: TColor = clWindow; _ErrColor: TColor = clYellow): boolean;
+var
+  Value: double;
+begin
+  Result := TEdit_TryTextToDouble(_ed, Value, _OkColor, _ErrColor);
+end;
+
 function TEdit_TextToInt(_ed: TEdit; _FocusControl: boolean = true): integer;
 var
   s: string;
@@ -1010,6 +1162,45 @@
   end;
 end;
 
+type
+  // Note: This class is never instantiated, only the DrawPanel method will be used
+  //       without ever referencing the self pointer (which is NIL), so it should work
+  TStatusBarPainter = class
+  public
+    procedure DrawPanel(StatusBar: TStatusBar; Panel: TStatusPanel; const Rect: TRect);
+  end;
+
+procedure TStatusBarPainter.DrawPanel(StatusBar: TStatusBar; Panel: TStatusPanel; const Rect: TRect);
+var
+  cnv: TCanvas;
+  s: string;
+  h: Integer;
+begin
+  s := StatusBar.SimpleText;
+  cnv := StatusBar.Canvas;
+  h := cnv.TextHeight(s);
+  cnv.TextRect(Rect, 2, (StatusBar.ClientHeight - h) div 2, StatusBar.SimpleText);
+end;
+
+procedure TStatusBar_EnableLongSimpleText(_StatusBar: TStatusBar);
+var
+  Painter: TStatusBarPainter;
+  pnl: TStatusPanel;
+begin
+  _StatusBar.SimplePanel := false;
+  _StatusBar.Panels.Clear;
+  pnl := _StatusBar.Panels.Add;
+  pnl.Style := psOwnerDraw;
+  Painter := nil;
+  _StatusBar.OnDrawPanel := Painter.DrawPanel;
+end;
+
+procedure TStatusBar_SetLongSimpleText(_StatusBar: TStatusBar; const _Text: string);
+begin
+  _StatusBar.SimpleText := _Text;
+  _StatusBar.Invalidate;
+end;
+
 procedure SetControlEnabled(_Control: TControl; _Enabled: boolean);
 var
   i: integer;
@@ -1060,6 +1251,13 @@
   Result := false;
 end;
 
+function TComboBox_GetSelectedObject(_cmb: TCustomCombobox; out _Obj: pointer; _FocusControl: boolean = false): boolean;
+var
+  Idx: integer;
+begin
+  Result := TComboBox_GetSelectedObject(_cmb, Idx, _Obj, _FocusControl);
+end;
+
 function TComboBox_GetSelectedObject(_cmb: TCustomCombobox; out _Idx: integer;
   out _Obj: pointer; _FocusControl: boolean = false): boolean;
 begin
@@ -1109,6 +1307,20 @@
     raise EdzListBoxNoSelection(_('No item selected in listbox'));
 end;
 
+function TListBox_GetSelected(_lb: TCustomListBox; _Selected: TStrings): integer;
+var
+  i: Integer;
+begin
+  Result := 0;
+  for i := 0 to _lb.Items.Count - 1 do begin
+    if _lb.Selected[i] then begin
+      Inc(Result);
+      if Assigned(_Selected) then
+        _Selected.AddObject(_lb.Items[i], _lb.Items.Objects[i]);
+    end;
+  end;
+end;
+
 function TListBox_GetSelectedObject(_lst: TCustomListbox; out _Idx: integer; out _Obj: pointer): boolean;
 begin
   _Idx := _lst.ItemIndex;
@@ -1144,6 +1356,20 @@
   Result := TListBox_DeleteSelected(_lst, Idx);
 end;
 
+procedure TListBox_UnselectAll(_lb: TCustomListbox);
+var
+  i: Integer;
+begin
+  for i := 0 to _lb.Items.count - 1 do
+    _lb.Selected[i] := false;
+end;
+
+procedure TListbox_ClearWithObjects(_lst: TCustomListBox);
+begin
+  TStrings_FreeAllObjects(_lst.Items);
+  _lst.Items.Clear;
+end;
+
 function TCheckListBox_GetCheckedCount(_clb: TCheckListBox): integer;
 var
   i: Integer;
@@ -1227,10 +1453,23 @@
 begin
   for i := 0 to _clb.Items.Count - 1 do
     if _clb.Checked[i] and (_IncludeDisabled or _clb.ItemEnabled[i]) then
-      _Checked.Add(_clb.Items[i]);
+      _Checked.AddObject(_clb.Items[i], _clb.Items.Objects[i]);
   Result := _Checked.Count;
 end;
 
+function TCheckListBox_GetCheckedObjects(_clb: TCheckListBox; _Objects: TList; _IncludeDisabled: boolean = false): integer;
+var
+  i: Integer;
+begin
+  Assert(Assigned(_clb));
+  Assert(Assigned(_Objects));
+
+  for i := 0 to _clb.Items.Count - 1 do
+    if _clb.Checked[i] and (_IncludeDisabled or _clb.ItemEnabled[i]) then
+      _Objects.Add(_clb.Items.Objects[i]);
+  Result := _Objects.Count;
+end;
+
 function TComboBox_Select(_cmb: TCustomComboBox; const _Item: string; _DefaultIdx: integer = -1): integer;
 begin
   Result := _Cmb.Items.IndexOf(_Item);
@@ -1239,6 +1478,58 @@
   _Cmb.ItemIndex := Result;
 end;
 
+procedure TComboBox_SelectWithoutChangeEvent(_cmb: TComboBox; _Idx: integer);
+var
+  Event: TNotifyEvent;
+begin
+  Event := _cmb.OnChange;
+  try
+    _cmb.OnChange := nil;
+    _cmb.ItemIndex := _Idx;
+  finally
+    _cmb.OnChange := Event;
+  end;
+end;
+
+procedure TControl_SetReadonly(_ctrl: TControl; _ReadOnly: boolean);
+var
+  Panel: TPanel;
+  comp: TComponent;
+  PanelName: string;
+begin
+  if _ctrl.Name = '' then
+    raise Exception.Create('Combobox must have a name to be set readonly');
+  PanelName := 'p_dzVclUtils' + _ctrl.Name;
+  comp := _ctrl.Owner.FindComponent(PanelName);
+  if Assigned(comp) then begin
+    if not (comp is TPanel) then
+      raise Exception.Create(PanelName + ' is not a TPanel');
+    Panel := comp as TPanel;
+    if _ReadOnly then
+      exit; // assume it is already readonly
+    _ctrl.Parent := Panel.Parent;
+    _ctrl.Top := Panel.Top;
+    _ctrl.Left := Panel.Left;
+    FreeAndNil(Panel);
+    exit;
+  end;
+  if not _ReadOnly then
+    exit; // assume it is not readonly
+
+  Panel := TPanel.Create(_ctrl.Owner);
+  Panel.Name := PanelName;
+  Panel.Parent := _ctrl.Parent;
+  Panel.Top := _ctrl.Top;
+  Panel.Left := _ctrl.Left;
+  Panel.Height := _ctrl.Height;
+  Panel.Width := _ctrl.Width;
+  Panel.BevelOuter := bvNone;
+  _ctrl.Top := 0;
+  _ctrl.Left := 0;
+  _ctrl.Parent := Panel;
+  Panel.Enabled := false;
+end;
+
 function TListBox_Select(_lb: TCustomListBox; const _Item: string; _DefaultIdx: integer = -1): integer;
 begin
   Result := _lb.Items.IndexOf(_Item);
@@ -1299,7 +1590,7 @@
     _Re.Lines.SaveToStream(st);
     Result := PChar(st.Memory);
   finally
-    st.Free;
+    FreeAndNil(st);
   end;
 end;
 
@@ -1313,7 +1604,7 @@
     st.Position := 0;
     _Re.Lines.LoadFromStream(st);
   finally
-    st.Free;
+    FreeAndNil(st);
   end;
 end;
 
@@ -1330,7 +1621,7 @@
       Result := Result + #26 + st.DataString;
     end
   finally
-    st.Free;
+    FreeAndNil(st);
   end;
 end;
 
@@ -1360,7 +1651,7 @@
       _Pic.Graphic := GraphicObj;
     end;
   finally
-    st.Free;
+    FreeAndNil(st);
   end;
 end;
 
@@ -1492,9 +1783,11 @@
 
 procedure TForm_CenterOn(_frm: TForm; _Center: TWinControl); overload;
 begin
-  Assert(Assigned(_Center), 'Center is not assigned'); // do not translate
-
-  TForm_CenterOn(_frm, _Center.ClientToScreen(Point(_Center.Width div 2, _Center.Height div 2)));
+  if Assigned(_Center) then
+    TForm_CenterOn(_frm, _Center.ClientToScreen(Point(_Center.Width div 2, _Center.Height div 2)))
+  else begin
+    TForm_CenterOn(_frm, Point(Screen.Width div 2, Screen.Height div 2));
+  end;
 end;
 
 function TWinControl_SetFocus(_Ctrl: TWinControl): boolean;
@@ -1732,5 +2025,190 @@
   _Form.Parent := nil;
 end;
 
+procedure TListView_ClearWithObjects(_lv: TListView);
+var
+  i: Integer;
+begin
+  for i := 0 to _lv.Items.Count - 1 do begin
+    TObject(_lv.Items[i].Data).Free;
+    _lv.Items[i].Data := nil;
+  end;
+  _lv.Clear;
+end;
+
+function TRadioGroup_GetButton(_rg: TRadioGroup; _ItemIdx: integer): TRadioButton;
+// taken from http://delphi.about.com/od/adptips2006/qt/radiogroupbtns.htm
+begin
+  if (_ItemIdx < 0) or (_ItemIdx >= _rg.Items.Count) then
+    Result := nil
+  else
+    Result := _rg.Controls[_ItemIdx] as TRadioButton;
+end;
+
+function TRadioGroup_GetButton(_rg: TRadioGroup; _ItemText: string): TRadioButton;
+// taken from http://delphi.about.com/od/adptips2006/qt/radiogroupbtns.htm
+var
+  cnt: integer;
+  Idx: integer;
+begin
+  Idx := -1;
+  for cnt := 0 to -1 + _rg.Items.Count do begin
+    if _rg.Items[cnt] = _ItemText then begin
+      Idx := cnt;
+      break;
+    end;
+  end;
+  Result := TRadioGroup_GetButton(_rg, Idx);
+end;
+
+type
+  THackButtonControl = class(TButtonControl)
+  end;
+
+function TButtonControl_GetChecked(_bctrl: TButtonControl): boolean;
+begin
+  Result := THackButtonControl(_bctrl).Checked;
+end;
+
+procedure TButtonControl_SetChecked(_bctrl: TButtonControl; _Value: boolean);
+begin
+  THackButtonControl(_bctrl).Checked := _Value;
+end;
+
+procedure TButtonControl_SetCaption(_bctrl: TButtonControl; _Value: string);
+begin
+  THackButtonControl(_bctrl).Caption := _Value;
+end;
+
+procedure TListView_UnselectAll(_lv: TListView; _WithSelectEvents: boolean = true);
+var
+  i: Integer;
+  Event: TLVSelectItemEvent;
+begin
+  Event := _lv.OnSelectItem;
+  if not _WithSelectEvents then
+    _lv.OnSelectItem := nil;
+  try
+    for i := 0 to _lv.Items.Count - 1 do
+      _lv.Items[i].Selected := false;
+  finally
+    _lv.OnSelectItem := Event;
+  end;
+end;
+
+function TListView_GetSelectedCount(_lv: TListView): integer;
+var
+  i: Integer;
+begin
+  Result := 0;
+  for i := 0 to _lv.Items.Count - 1 do
+    if _lv.Items[i].Selected then
+      Inc(Result);
+end;
+
+function TStatusBar_GetClickedPanel(_sb: TStatusBar): integer;
+// call this to determine which panel of a TStatusBar has been clicked
+// Note: This assumes, that the status bar actually was clicked, so only call it
+//       from the status bar's OnClick, OnMouseDown or OnMouseUp event handlers
+// If the status bar does not have any panels (e.g. SimplePanel=true), this function
+// will return 0.
+var
+  mpt: TPoint;
+  x: Integer;
+  j: Integer;
+  cnt: Integer;
+begin
+  cnt := _sb.Panels.Count;
+  if _sb.SimplePanel then
+    cnt := 0;
+
+  mpt := _sb.ScreenToClient(Mouse.CursorPos);
+
+  Result := -1;
+  x := 0;
+  for j := 0 to cnt - 1 do begin
+    x := x + _sb.Panels[j].Width;
+    if mpt.X < x then begin
+      Result := j;
+      Break;
+    end;
+  end;
+
+  //clicked "after" the last panel -
+  //fake it as if the last one was clicked
+  if Result = -1 then
+    Result := _sb.Panels.Count - 1;
+end;
+
+{ TLongSimpleTextStatusBar }
+
+function TLongSimpleTextStatusBar.GetSimpleText: string;
+begin
+  Result := inherited SimpleText;
+end;
+
+procedure TLongSimpleTextStatusBar.SetSimpleText(const Value: string);
+begin
+  TStatusBar_SetLongSimpleText(Self, Value);
+end;
+
+type
+  TCursorRestorer = class(TInterfacedObject, IInterface)
+  private
+    FOldCursor: TCursor;
+    constructor Create(_NewCursor: TCursor);
+    destructor Destroy; override;
+  end;
+
+{ TCursorRestorer }
+
+constructor TCursorRestorer.Create(_NewCursor: TCursor);
+begin
+  inherited Create;
+  FOldCursor := Screen.Cursor;
+  Screen.Cursor := _NewCursor;
+end;
+
+destructor TCursorRestorer.Destroy;
+begin
+  Screen.Cursor := FOldCursor;
+  inherited;
+end;
+
+function TCursor_TemporaryChange(_NewCursor: TCursor): IInterface;
+begin
+  Result := TCursorRestorer.Create(_NewCursor);
+end;
+
+type
+  TWinControlLocker = class(TInterfacedObject, IInterface)
+  private
+    FCtrl: TWinControl;
+  public
+    constructor Create(_Ctrl: TWinControl);
+    destructor Destroy; override;
+  end;
+
+function TWinControl_Lock(_Ctrl: TWinControl): IInterface;
+begin
+  Result := TWinControlLocker.Create(_Ctrl);
+end;
+
+{ TWinControlLocker }
+
+constructor TWinControlLocker.Create(_Ctrl: TWinControl);
+begin
+  inherited Create;
+  FCtrl := _Ctrl;
+  SendMessage(FCtrl.Handle, WM_SETREDRAW, integer(LongBool(false)), 0);
+end;
+
+destructor TWinControlLocker.Destroy;
+begin
+  SendMessage(FCtrl.Handle, WM_SETREDRAW, integer(LongBool(true)), 0);
+  RedrawWindow(FCtrl.Handle, nil, 0, RDW_ERASE or RDW_INVALIDATE or RDW_ALLCHILDREN);
+  inherited;
+end;
+
 end.
 



From twm at mail.berlios.de  Fri Sep 25 17:08:05 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:08:05 +0200
Subject: [Dzchart-svncheckins] r351 - utilities/dzLib/trunk/src
Message-ID: <200909251508.n8PF857s016940@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:08:03 +0200 (Fri, 25 Sep 2009)
New Revision: 351

Modified:
   utilities/dzLib/trunk/src/u_dzVersionInfo.pas
Log:
* now also reads copyright and company name
* FileVersionStr now has got a parameter Pars which determines which parts of the version to usee


Modified: utilities/dzLib/trunk/src/u_dzVersionInfo.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzVersionInfo.pas	2009-09-25 15:05:10 UTC (rev 350)
+++ utilities/dzLib/trunk/src/u_dzVersionInfo.pas	2009-09-25 15:08:03 UTC (rev 351)
@@ -1,4 +1,4 @@
-{GXFormatter.config=twm}
+{.GXFormatter.config=twm}
 unit u_dzVersionInfo;
 
 interface
@@ -13,10 +13,13 @@
   EAIInvalidVersionInfo = class(EApplicationInfo);
 
 type
-  TFileProperty = (FpProductName, FpProductVersion, FpFileDescription, FpFileVersion);
+  TFileProperty = (FpProductName, FpProductVersion, FpFileDescription, FpFileVersion, FpCopyright, FpCompanyName);
   TFilePropertySet = set of TFileProperty;
 
 type
+  TVersionParts = (vpMajor, vpMajorMinor, vpMajorMinorRevision, vpFull);
+
+type
   TFileVersionRec = record
     Major: integer;
     Minor: integer;
@@ -45,14 +48,18 @@
     function FileDir: string;
     ///<summary> The file description from the version resource </summary>
     function FileDescription: string;
-    ///<summary> The file version from the file properties.</summary>
+    ///<summary> The file version from the file version resource </summary>
     function FileVersion: string;
     function FileVersionRec: TFileVersionRec;
-    ///<summary> The file's product name from the resources </summary>
+    function FileVersionStr(_Parts: TVersionParts = vpMajorMinorRevision): string;
+    ///<summary> The file's product name from the version resource </summary>
     function ProductName: string;
-    ///<summary> The the product version from the file properties.</summary>
+    ///<summary> The the product version from the version resource </summary>
     function ProductVersion: string;
-
+    ///<summary> The company name from the version resource </summary>
+    function Company: string;
+    ///<summary> The LegalCopyRight string from the file version resources </summary>
+    function LegalCopyRight: string;
   end;
 
 type
@@ -74,9 +81,14 @@
     function FileDescription: string;
     function FileVersion: string;
     function FileVersionRec: TFileVersionRec;
+    function FileVersionStr(_Parts: TVersionParts = vpMajorMinorRevision): string;
 
     function ProductName: string;
     function ProductVersion: string;
+    ///<summary> The company name from the version resource </summary>
+    function Company: string;
+    ///<summary> The LegalCopyRight string from the file version resources </summary>
+    function LegalCopyRight: string;
   public
     constructor Create;
     destructor Destroy; override;
@@ -162,41 +174,54 @@
 begin
   result := '';
 
-  if not (_Property in FFilePropertiesRead) then
-    begin
-      try
-        case _Property of
-          FpProductName,
-            FpProductVersion,
-            FpFileDescription,
-            FpFileVersion:
-            begin
-              fi := TJclFileVersionInfo.Create(FileName);
-              try
-                FFileProperties[FpFileVersion] := fi.FileVersion;
-                FFileProperties[FpFileDescription] := fi.FileDescription;
-                FFileProperties[FpProductName] := fi.ProductName;
-                FFileProperties[FpProductVersion] := fi.ProductVersion;
+  if not (_Property in FFilePropertiesRead) then begin
+    try
+      case _Property of
+        FpProductName,
+          FpProductVersion,
+          FpFileDescription,
+          FpFileVersion,
+          FpCopyright: begin
+            fi := TJclFileVersionInfo.Create(FileName);
+            try
+              FFileProperties[FpFileVersion] := fi.FileVersion;
+              FFileProperties[FpFileDescription] := fi.FileDescription;
+              FFileProperties[FpProductName] := fi.ProductName;
+              FFileProperties[FpProductVersion] := fi.ProductVersion;
+              FFileProperties[FpCopyright] := fi.LegalCopyright;
+              FFileProperties[FpCompanyName] := fi.CompanyName;
 
-                Include(FFilePropertiesRead, FpFileVersion);
-                Include(FFilePropertiesRead, FpFileDescription);
-                Include(FFilePropertiesRead, FpProductVersion);
-                Include(FFilePropertiesRead, FpProductName);
-              finally
-                fi.Free;
-              end;
+              Include(FFilePropertiesRead, FpFileVersion);
+              Include(FFilePropertiesRead, FpFileDescription);
+              Include(FFilePropertiesRead, FpProductVersion);
+              Include(FFilePropertiesRead, FpProductName);
+              Include(FFilePropertiesRead, FpCopyright);
+              Include(FFilePropertiesRead, FpCompanyName);
+            finally
+              fi.Free;
             end;
-        end;
-      except
-        if FAllowExceptions then
-          raise;
-        exit;
+          end;
       end;
+    except
+      if FAllowExceptions then
+        raise;
+      exit;
     end;
+  end;
 
   Result := FFileProperties[_Property];
 end;
 
+function TCustomFileInfo.Company: string;
+begin
+  Result := GetFileProperty(FpCompanyName);
+end;
+
+function TCustomFileInfo.LegalCopyRight: string;
+begin
+  Result := GetFileProperty(FpCopyright);
+end;
+
 function TCustomFileInfo.FileVersion: string;
 begin
   Result := GetFileProperty(FpFileVersion);
@@ -207,6 +232,21 @@
   Result.IsValid := GetFileBuildInfo(FFileName, Result.Major, Result.Minor, Result.Revision, Result.Build);
 end;
 
+function TCustomFileInfo.FileVersionStr(_Parts: TVersionParts = vpMajorMinorRevision): string;
+var
+  Rec: TFileVersionRec;
+begin
+  Rec := FileVersionRec;
+  case _Parts of
+    vpMajor: Result := IntToStr(Rec.Major);
+    vpMajorMinor: Result := IntToStr(Rec.Major) + '.' + IntToStr(Rec.Minor);
+    vpMajorMinorRevision: Result := IntToStr(Rec.Major) + '.' + IntToStr(Rec.Minor) + '.' + IntToStr(Rec.Revision);
+    vpFull: Result := IntToStr(Rec.Major) + '.' + IntToStr(Rec.Minor) + '.' + IntToStr(Rec.Revision) + '.' + IntToStr(Rec.Build)
+  else
+    raise Exception.CreateFmt('Invalid version part (%d)', [Ord(_Parts)]);
+  end;
+end;
+
 function TCustomFileInfo.ProductName: string;
 begin
   Result := GetFileProperty(FpProductName);
@@ -263,16 +303,14 @@
   _b.CheckValid;
 
   Result := _a.Major > _b.Major;
-  if not Result and (_a.Major = _b.Major) then
-    begin
-      Result := _a.Minor > _b.Minor;
-      if not Result and (_a.Minor = _b.Minor) then
-        begin
-          Result := _a.Revision > _b.Revision;
-          if not Result and (_a.Revision = _b.Revision) then
-            Result := _a.Build > _b.Build;
-        end;
+  if not Result and (_a.Major = _b.Major) then begin
+    Result := _a.Minor > _b.Minor;
+    if not Result and (_a.Minor = _b.Minor) then begin
+      Result := _a.Revision > _b.Revision;
+      if not Result and (_a.Revision = _b.Revision) then
+        Result := _a.Build > _b.Build;
     end;
+  end;
 end;
 
 class operator TFileVersionRec.GreaterThanOrEqual(_a, _b: TFileVersionRec): boolean;
@@ -297,16 +335,14 @@
   _b.CheckValid;
 
   Result := _a.Major < _b.Major;
-  if not Result and (_a.Major = _b.Major) then
-    begin
-      Result := _a.Minor < _b.Minor;
-      if not Result and (_a.Minor = _b.Minor) then
-        begin
-          Result := _a.Revision < _b.Revision;
-          if not Result and (_a.Revision = _b.Revision) then
-            Result := _a.Build < _b.Build;
-        end;
+  if not Result and (_a.Major = _b.Major) then begin
+    Result := _a.Minor < _b.Minor;
+    if not Result and (_a.Minor = _b.Minor) then begin
+      Result := _a.Revision < _b.Revision;
+      if not Result and (_a.Revision = _b.Revision) then
+        Result := _a.Build < _b.Build;
     end;
+  end;
 end;
 
 class operator TFileVersionRec.LessThanOrEqual(_a, _b: TFileVersionRec): boolean;
@@ -327,4 +363,3 @@
 
 end.
 
-



From twm at mail.berlios.de  Fri Sep 25 17:08:41 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:08:41 +0200
Subject: [Dzchart-svncheckins] r352 - utilities/dzLib/trunk/tests/src
Message-ID: <200909251508.n8PF8fgP017025@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:08:40 +0200 (Fri, 25 Sep 2009)
New Revision: 352

Modified:
   utilities/dzLib/trunk/tests/src/Testu_dzConvertUtils.pas
Log:
unit tests for Swap16 and Swap32

Modified: utilities/dzLib/trunk/tests/src/Testu_dzConvertUtils.pas
===================================================================
--- utilities/dzLib/trunk/tests/src/Testu_dzConvertUtils.pas	2009-09-25 15:08:03 UTC (rev 351)
+++ utilities/dzLib/trunk/tests/src/Testu_dzConvertUtils.pas	2009-09-25 15:08:40 UTC (rev 352)
@@ -24,6 +24,8 @@
     procedure TestLong2Dec4(_l: ULong);
     procedure TestLong2DecN(_l: ULong; _n: ULong);
     procedure TestLong2Dec(_l: ULong);
+    procedure TestSwap16;
+    procedure TestSwap32;
   end;
 
 implementation
@@ -99,6 +101,30 @@
 
 end;
 
+procedure TestDecimalConversion.TestSwap16;
+var
+  i: Integer;
+begin
+  for i := 0 to $FFFF do begin
+    CheckEquals(i shr 8 + ((i and $FF) shl 8), Swap16(i));
+  end;
+end;
+
+procedure TestDecimalConversion.TestSwap32;
+var
+  i: LongWord;
+begin
+  i := 0;
+  // to prevent an integer overflow we can not use while i <= $FFFFFFFF do
+  while true do begin
+    CheckEquals(i shr 24 + ((i shr 16) and $FF) shl 8 + ((i shr 8 and $FF) shl 16) + ((i and $FF) shl 24), Swap32(i));
+    if i <= $FFFFFFFF then
+      Inc(i)
+    else
+      break;
+  end;
+end;
+
 initialization
   RegisterTest(TestDecimalConversion.Suite);
 end.



From twm at mail.berlios.de  Fri Sep 25 17:13:10 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:13:10 +0200
Subject: [Dzchart-svncheckins] r353 - utilities/dzLib/trunk/forms
Message-ID: <200909251513.n8PFDAR3017487@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:13:08 +0200 (Fri, 25 Sep 2009)
New Revision: 353

Modified:
   utilities/dzLib/trunk/forms/w_dzDialog.pas
Log:
* can now specify which button to focus
* new property ExceptionExtendedMessage
* using JclDebug is now optional


Modified: utilities/dzLib/trunk/forms/w_dzDialog.pas
===================================================================
--- utilities/dzLib/trunk/forms/w_dzDialog.pas	2009-09-25 15:08:40 UTC (rev 352)
+++ utilities/dzLib/trunk/forms/w_dzDialog.pas	2009-09-25 15:13:08 UTC (rev 353)
@@ -1,4 +1,4 @@
-{GXFormatter.config=twm}
+{.GXFormatter.config=twm}
 ///<summary> Generic exception and message dialog.
 ///          This unit implements a generic Dialog to display exceptions and messages.
 ///          For exceptions, it only displays the exception's class name and a
@@ -8,6 +8,8 @@
 ///          @author twm </summary>
 unit w_dzDialog;
 
+{$INCLUDE jedi.inc}
+
 interface
 
 uses
@@ -21,8 +23,10 @@
   Dialogs,
   StdCtrls,
   ExtCtrls,
-  u_dzTranslator,
-  Jcldebug;
+{$IFNDEF no_jcl}
+  Jcldebug,
+{$ENDIF}
+  u_dzTranslator;
 
 type
   EInvalidModalResult = class(Exception);
@@ -52,11 +56,11 @@
   TShowMaximizeOption = (smSmart, smShow, smHide);
 
 type
-  ///<summary> used for the property OnButtonClick in asyncronous mode
-  ///          @param Sender is the Exceptiondialog
-  ///          @param Button is the ModalResult value of the button pressed
-  ///          @param Action is a TCloseAction indicating whether the dialog can be closed,
-  ///                        it is initialized to caNone and can be set to caHide, caFree or caMinimize </summary>
+  { used for the property OnButtonClick in asyncronous mode
+    @param(Sender is the Exceptiondialog)
+    @param(Button is the ModalResult value of the button pressed)
+    @param(Action is a TCloseAction indicating whether the dialog can be closed,
+           it is initialized to caNone and can be set to caHide, caFree or caMinimize)}
   TOnButtonClick = procedure(Sender: TObject; _Button: TModalResult; var _Action: TCloseAction);
 
 type
@@ -99,6 +103,7 @@
     FVisibleButtons: TDialogButtonArr;
     FUserMessage: string;
     FDetails: string;
+    FFocusButton: Integer;
     FDialogType: TMsgDlgType;
     FShowDetailButton: boolean;
     FDontShowAgainText: string;
@@ -117,6 +122,7 @@
     procedure MakeNonModal;
     procedure ButtonClick(_Sender: TObject);
     procedure SetVisibleButtons(const _Buttons: array of TDialogButtonEnum);
+    procedure SetFocusButton(_ButtonIndex: Integer);
   protected
     procedure b_DetailsClick(Sender: TObject);
     procedure DoShow; override;
@@ -130,7 +136,11 @@
     property ExceptionClass: string read FExceptionClass write FExceptionClass;
     ///<summary> message of the exception </summary>
     property ExceptionMessage: string read FExceptionMessage write FExceptionMessage;
-    ///<summary> exception address (initialized to ExcptAddr </summary>
+    ///<summary> exception address (initialized to ExcptAddr) </summary>
+    //    property ExcptionAddress: pointer read fExceptionAddress write fExceptionAddress;
+    {: extended exception messsage }
+    property ExceptionExtendedMessage: string read FExceptionExtendedMessage write FExceptionExtendedMessage;
+    {: exception procedure }
     property ExceptionProcedure: string read FExceptionProcedure write FExceptionProcedure;
     property CallStack: TStrings read FCallStack write SetCallStack;
     ///<summary> array of buttons to show, note that this is an array, not a set, so the
@@ -234,7 +244,7 @@
     ///          @returns one of the mrXxxx values </summary>
     class function ShowMessage(_DialogType: TMsgDlgType; const _Message: string;
       const _Buttons: array of TDialogButtonEnum; _Owner: TWinControl = nil;
-      const _OptionDesc: string = ''): integer; overload;
+      const _OptionDesc: string = ''; _FocusButton: Integer = -1): integer; overload;
     ///<summary> Complex function to display a message.
     ///          This will display a dialog with the icon indicated by DialogType, the
     ///          Message given, containing the Buttons specified and optionally an
@@ -259,7 +269,7 @@
       const _Buttons: array of TDialogButtonEnum; const _CustomButtons: array of string;
       const _CustomResults: array of integer;
       _Owner: TWinControl = nil;
-      const _OptionDesc: string = ''): integer; overload;
+      const _OptionDesc: string = ''; _FocusButton: Integer = -1): integer; overload;
     ///<summary> Creates a Tf_dzDialog instance, shows it and returns it. The created
     ///          dialog instance must be freed by the caller. Nonmodal in this context
     ///          means that the call returns to the caller rather than waiting for the
@@ -308,7 +318,7 @@
 function _(const _s: string): string; inline;
 begin
   Result := dzDGetText(_s, 'dzlib');
-end;  
+end;
 
 function ModalResultToButton(_Result: integer): TDialogButtonEnum;
 var
@@ -325,7 +335,7 @@
 class function Tf_dzDialog.ShowMessage(_DialogType: TMsgDlgType;
   const _Message: string; const _Buttons: array of TDialogButtonEnum;
   const _CustomButtons: array of string; const _CustomResults: array of integer;
-  _Owner: TWinControl = nil;  const _OptionDesc: string=''): integer;
+  _Owner: TWinControl = nil; const _OptionDesc: string = ''; _FocusButton: Integer = -1): integer;
 var
   frm: Tf_dzDialog;
   i: Integer;
@@ -336,6 +346,7 @@
       TForm_CenterOn(frm, _Owner);
     frm.ShowDetailButton := false;
     frm.SetVisibleButtons(_Buttons);
+    frm.SetFocusButton(_FocusButton);
     Assert(Length(_CustomButtons) = Length(frm.CustomButtonCaptions));
     for i := Low(_CustomButtons) to High(_CustomButtons) do
       frm.CustomButtonCaptions[i] := _CustomButtons[i];
@@ -352,7 +363,7 @@
 end;
 
 class function Tf_dzDialog.ShowMessage(_DialogType: TMsgDlgType; const _Message: string;
-  const _Buttons: array of TDialogButtonEnum; _Owner: TWinControl = nil; const _OptionDesc: string = ''): integer;
+  const _Buttons: array of TDialogButtonEnum; _Owner: TWinControl = nil; const _OptionDesc: string = ''; _FocusButton: Integer = -1): integer;
 var
   frm: Tf_dzDialog;
 begin
@@ -362,6 +373,7 @@
       TForm_CenterOn(frm, _Owner);
     frm.ShowDetailButton := false;
     frm.SetVisibleButtons(_Buttons);
+    frm.SetFocusButton(_FocusButton);
     frm.UserMessage := _Message;
     frm.OptionDescription := _OptionDesc;
     frm.DialogType := _DialogType;
@@ -381,12 +393,12 @@
   Result := Tf_dzDialog.Create(_Parent);
   Result.ShowDetailButton := false;
   Result.SetVisibleButtons(_Buttons);
-    Assert(Length(_CustomButtons) = Length(Result.CustomButtonCaptions));
-    for i := Low(_CustomButtons) to High(_CustomButtons) do
-      Result.CustomButtonCaptions[i] := _CustomButtons[i];
-    Assert(Length(_CustomResults) = Length(Result.CustomModalResults));
-    for i := Low(_CustomResults) to High(_CustomResults) do
-      Result.CustomModalResults[i] := _CustomResults[i];
+  Assert(Length(_CustomButtons) = Length(Result.CustomButtonCaptions));
+  for i := Low(_CustomButtons) to High(_CustomButtons) do
+    Result.CustomButtonCaptions[i] := _CustomButtons[i];
+  Assert(Length(_CustomResults) = Length(Result.CustomModalResults));
+  for i := Low(_CustomResults) to High(_CustomResults) do
+    Result.CustomModalResults[i] := _CustomResults[i];
   Result.UserMessage := _Message;
   Result.OptionDescription := _OptionDesc;
   Result.DialogType := _DialogType;
@@ -399,7 +411,9 @@
 var
   frm: Tf_dzDialog;
   sl: TStringList;
+{$IFNDEF no_jcl}
   StackList: TJclStackInfoList;
+{$ENDIF}
 begin
   frm := Tf_dzDialog.Create(_Parent);
   try
@@ -407,7 +421,9 @@
       frm.ExceptionClass := _e.ClassName;
       // frm.ExcptionAddress := ExceptAddr;
       frm.ExceptionMessage := _e.Message;
-      frm.ExceptionProcedure := Format('[%p]', [ExceptAddr]);
+      frm.ExceptionExtendedMessage := _e.Message;
+      frm.ExceptionProcedure := format('[%p]', [ExceptAddr]);
+{$IFNDEF no_jcl}
       frm.ExceptionProcedure := GetLocationInfoStr(ExceptAddr);
       sl := TStringList.Create;
       try
@@ -419,6 +435,7 @@
       finally
         sl.Free;
       end;
+{$ENDIF}
     end else
       frm.ShowDetailButton := false;
     frm.SetVisibleButtons(_Buttons);
@@ -490,6 +507,7 @@
 constructor Tf_dzDialog.Create(_Owner: TComponent);
 begin
   inherited;
+  FFocusButton := 0;
   FDialogType := mtError;
   FShowDetailButton := true;
   FDontShowAgainText := _('Do not show again.');
@@ -569,6 +587,7 @@
   IconID: PChar;
   btn: TButton;
   CustomCount: integer;
+  FocusButton: TButton;
 begin
   inherited;
   EnableMenuItem(GetSystemMenu(Handle, LongBool(false)), SC_MAXIMIZE, MF_BYCOMMAND or MF_GRAYED);
@@ -680,6 +699,7 @@
   end;
   X := (ClientWidth - ButtonGroupWidth - ButtonSpacing) {div 2};
   CustomCount := 0;
+  FocusButton := nil;
   for i := Low(FVisibleButtons) to High(FVisibleButtons) do begin
     b := FVisibleButtons[i];
     btn := TButton.Create(self);
@@ -705,7 +725,11 @@
     btn.Anchors := [akTop, akRight];
     btn.OnClick := ButtonClick;
     Inc(X, ButtonWidth + ButtonSpacing);
+    if i = FFocusButton then
+      FocusButton := btn;
   end;
+  if Assigned(FocusButton) then
+    FocusButton.SetFocus;
 
   if FShowDontShowAgain then begin
     chk_DontAskAgain := TCheckBox.Create(self);
@@ -782,6 +806,11 @@
   FShowDontShowAgain := FDontShowAgainText <> '';
 end;
 
+procedure Tf_dzDialog.SetFocusButton(_ButtonIndex: Integer);
+begin
+  FFocusButton := _ButtonIndex;
+end;
+
 procedure Tf_dzDialog.SetVisibleButtons(const _Buttons: array of TDialogButtonEnum);
 var
   i: integer;
@@ -835,8 +864,10 @@
   end;
 end;
 
+{$IFDEF use_jcl}
 initialization
   JclStartExceptionTracking;
   Include(JclStackTrackingOptions, stRawMode);
+{$ENDIF}
 end.
 



From twm at mail.berlios.de  Fri Sep 25 17:17:23 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:17:23 +0200
Subject: [Dzchart-svncheckins] r354 - utilities/dzLib/trunk/forms
Message-ID: <200909251517.n8PFHNOl018050@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:17:21 +0200 (Fri, 25 Sep 2009)
New Revision: 354

Modified:
   utilities/dzLib/trunk/forms/w_dzWizardForm.pas
   utilities/dzLib/trunk/forms/wf_dzWizardFrame.pas
Log:
* new property Pages
* pressing Cancel now calls the CancelPressed and Cancelling methods in all pages
* The buttons to enable are now determined dynamically by calling the ButtonAllowed method in all pages

Modified: utilities/dzLib/trunk/forms/w_dzWizardForm.pas
===================================================================
--- utilities/dzLib/trunk/forms/w_dzWizardForm.pas	2009-09-25 15:13:08 UTC (rev 353)
+++ utilities/dzLib/trunk/forms/w_dzWizardForm.pas	2009-09-25 15:17:21 UTC (rev 354)
@@ -34,9 +34,6 @@
 
   TOnFinished = procedure(_Sender: TObject; var _CanClose: boolean) of object;
 
-  TWizardButtons = (wbPrev, wbNext, wbCancel);
-  TWizardButtonSet = set of TWizardButtons;
-
   Tf_dzWizardForm = class(TForm)
     p_Client: TPanel;
     p_Buttons: TPanel;
@@ -118,6 +115,7 @@
     function GoBack: integer; virtual;
     function GetEnabledButtons: TWizardButtonSet;
     procedure SetEnabledButtons(const _Buttons: TWizardButtonSet; _Enabled: boolean);
+    procedure UpdateButtonState;
     property Pages: TPageList read FPages;
     property Picture: TPicture read GetPicture write SetPicture;
     property CurrentPageNo: integer read FCurrentPageNo write SetCurrentPageNo;
@@ -135,13 +133,14 @@
     FNextId: integer;
     FList: TList;
     FWizard: Tf_dzWizardForm;
-    function GetPage(_Idx: integer): pointer;
+    function GetPages(_Idx: integer): Tfr_dzWizardFrame;
     function PageById(_PageId: integer): Tfr_dzWizardFrame;
   public
     constructor Create(_Wizard: Tf_dzWizardForm);
     destructor Destroy; override;
     function AddPage(_Frame: Tfr_dzWizardFrame; const _Description: string; _Data: pointer = nil): integer;
     function PageCount: integer;
+    property Pages[_Idx: integer]: Tfr_dzWizardFrame read GetPages; default;
   end;
 
 implementation
@@ -205,7 +204,7 @@
   Result := nil;
 end;
 
-function TPageList.GetPage(_Idx: integer): pointer;
+function TPageList.GetPages(_Idx: integer): Tfr_dzWizardFrame;
 begin
   Result := FList[_Idx];
 end;
@@ -392,6 +391,7 @@
   if Assigned(FCurrentPage) then
     FCurrentPage.PageDeactivate;
   FCurrentPage := _NextPage;
+  CurrentPageNo := FPages.FList.IndexOf(_NextPage);
   FCurrentPage.PageActivate;
   s := _NextPage.Description;
   if s = '' then
@@ -405,7 +405,6 @@
     l_Description.Caption := s;
     p_Description.Visible := true;
   end;
-  CurrentPageNo := FPages.FList.IndexOf(_NextPage);
 end;
 
 procedure Tf_dzWizardForm.b_CancelClick(Sender: TObject);
@@ -426,8 +425,15 @@
 end;
 
 function Tf_dzWizardForm.DoOnCancel: boolean;
+var
+  i: Integer;
 begin
   Result := true;
+  for i := 0 to FPages.PageCount - 1 do
+    FPages[i].CancelPressed(Result);
+  if Result then
+    for i := 0 to FPages.PageCount - 1 do
+      FPages[i].Cancelling;
 end;
 
 procedure Tf_dzWizardForm.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
@@ -466,6 +472,34 @@
   b_Prev.Caption := _Caption;
 end;
 
+procedure Tf_dzWizardForm.UpdateButtonState;
+var
+  Buttons: TWizardButtonSet;
+
+  procedure CheckButton(_Button: TWizardButtons; _Default: boolean);
+  var
+    Allowed: boolean;
+  begin
+    Allowed := _Default;
+    FCurrentPage.ButtonAllowed(_Button, Allowed);
+    if Allowed then
+      Include(Buttons, _Button)
+    else
+      Exclude(Buttons, _Button);
+  end;
+
+begin
+  Buttons := GetEnabledButtons;
+  if Assigned(FCurrentPage) then begin
+    if FCurrentPageNo > 0 then
+      CheckButton(wbPrev, true);
+    CheckButton(wbNext, true);
+    CheckButton(wbCancel, true);
+  end;
+  SetEnabledButtons(Buttons, true);
+  SetEnabledButtons([wbPrev, wbNext, wbCancel] - Buttons, false);
+end;
+
 function Tf_dzWizardForm.GetEnabledButtons: TWizardButtonSet;
 begin
   Result := [];

Modified: utilities/dzLib/trunk/forms/wf_dzWizardFrame.pas
===================================================================
--- utilities/dzLib/trunk/forms/wf_dzWizardFrame.pas	2009-09-25 15:13:08 UTC (rev 353)
+++ utilities/dzLib/trunk/forms/wf_dzWizardFrame.pas	2009-09-25 15:17:21 UTC (rev 354)
@@ -27,6 +27,9 @@
     _OldPageId, _NewPageId: integer;
     _OldPageData, _NewPageData: Pointer) of object;
 
+  TWizardButtons = (wbPrev, wbNext, wbCancel);
+  TWizardButtonSet = set of TWizardButtons;
+
   Tfr_dzWizardFrame = class(TFrame)
   private
     FPageId: integer;
@@ -38,12 +41,20 @@
   protected
     function GetNextPageId: integer; virtual;
     procedure SetNextPageId(const _Value: integer); virtual;
+    procedure doUpdateButtonState;
   public
     constructor Create(_Owner: TComponent); override;
+    procedure ButtonAllowed(_Button: TWizardButtons; var _Allowed: boolean); virtual;
     procedure PageActivate; virtual;
     procedure PageDeactivate; virtual;
     function Exiting(_Direction: TPrevNext; var _NewPageId: integer; _NewPage: Tfr_dzWizardFrame): boolean; virtual;
     procedure Entered(_Direction: TPrevNext; _OldPageId: integer; _OldPage: Tfr_dzWizardFrame); virtual;
+    ///<summary> Called for all pages when the user presses the Cancel button, set Allow to false to prevent
+    ///          the wizard from closing </summary>
+    procedure CancelPressed(var _Allow: boolean); virtual;
+    ///<summary> Called for all pages when calls to CancelPressed all returned true, just before closing
+    ///          the wizard </summary>
+    procedure Cancelling; virtual;
     property PageId: integer read FPageId write FPageId;
     property NextPageId: integer read GetNextPageId write SetNextPageId;
     property Description: string read FDescription write FDescription;
@@ -56,6 +67,9 @@
 
 {$R *.dfm}
 
+uses
+  w_dzWizardForm;
+
 { Tfr_dzWizardFrame }
 
 constructor Tfr_dzWizardFrame.Create(_Owner: TComponent);
@@ -65,18 +79,38 @@
   FNextPageId := -1;
 end;
 
+procedure Tfr_dzWizardFrame.Cancelling;
+begin
+  // do nothing
+end;
+
+procedure Tfr_dzWizardFrame.CancelPressed(var _Allow: boolean);
+begin
+  // do nothing
+end;
+
+procedure Tfr_dzWizardFrame.doUpdateButtonState;
+begin
+  (Owner as Tf_dzWizardForm).UpdateButtonState;
+end;
+
+procedure Tfr_dzWizardFrame.ButtonAllowed(_Button: TWizardButtons; var _Allowed: boolean);
+begin
+  // do nothing
+end;
+
 procedure Tfr_dzWizardFrame.Entered(_Direction: TPrevNext; _OldPageId: integer; _OldPage: Tfr_dzWizardFrame);
 begin
   if Assigned(FAfterEnter) then
-    FAfterEnter(Self, _Direction, _OldPageId, PageId, _OldPage, Self);
+    FAfterEnter(Self, _Direction, _OldPageId, PageId, _OldPage.Data, Data);
 end;
 
 function Tfr_dzWizardFrame.Exiting(_Direction: TPrevNext;
   var _NewPageId: integer; _NewPage: Tfr_dzWizardFrame): boolean;
 begin
-  Result := true;
+  Result := True;
   if Assigned(FBeforeExit) then
-    FBeforeExit(Self, _Direction, PageId, _NewPageId, Self, _NewPage, Result);
+    FBeforeExit(Self, _Direction, PageId, _NewPageId, Data, _NewPage.Data, Result);
 end;
 
 function Tfr_dzWizardFrame.GetNextPageId: integer;
@@ -88,6 +122,7 @@
 begin
   Align := alClient;
   Visible := true;
+  doUpdateButtonState;
 end;
 
 procedure Tfr_dzWizardFrame.PageDeactivate;



From twm at mail.berlios.de  Fri Sep 25 17:19:59 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:19:59 +0200
Subject: [Dzchart-svncheckins] r355 - utilities/dzLib/trunk/lockfree
Message-ID: <200909251519.n8PFJxGR018390@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:19:57 +0200 (Fri, 25 Sep 2009)
New Revision: 355

Added:
   utilities/dzLib/trunk/lockfree/u_dzInterlocked.pas
Log:
functions for interlocked AND and OR operations on 32 bit values


Added: utilities/dzLib/trunk/lockfree/u_dzInterlocked.pas
===================================================================
--- utilities/dzLib/trunk/lockfree/u_dzInterlocked.pas	2009-09-25 15:17:21 UTC (rev 354)
+++ utilities/dzLib/trunk/lockfree/u_dzInterlocked.pas	2009-09-25 15:19:57 UTC (rev 355)
@@ -0,0 +1,90 @@
+unit u_dzInterlocked;
+
+interface
+
+uses
+  Windows;
+
+///<summary> Tries to interlocked mask the Destination with an AND and an OR mask.
+///          @returns true if the operation succeeded </summary>
+function TryInterlockedMask(var _Destination: LongWord; _AndMask, _OrMask: LongWord): boolean;
+
+///<summary> Calls TryInterlockedMask until it succeeds, sleeps for
+///          1 millisecond every time it fails. </summary>
+procedure InterlockedMaskSleep(var _Destination: LongWord; _AndMask, _OrMask: LongWord); inline;
+///<summary> Interlocked ANDs the Destination MASK, waits until the operation succeeded, sleeps for
+///          1 millisecond every time it fails. </summary>
+procedure InterlockedAndSleep(var _Destination: LongWord; _Mask: LongWord); inline;
+///<summary> Interlocked ORs the Destination MASK, waits until the operation succeeded, sleeps for
+///          1 millisecond every time it fails. </summary>
+procedure InterlockedOrSleep(var _Destination: LongWord; _Mask: LongWord); inline;
+
+///<summary> Calls TryInterlockedMask until it succeeds </summary>
+procedure InterlockedMaskSpin(var _Destination: LongWord; _AndMask, _OrMask: LongWord); inline;
+///<summary> Interlocked ANDs the Destination MASK, waits until the operation succeeded. </summary>
+procedure InterlockedAndSpin(var _Destination: LongWord; _Mask: LongWord); inline;
+///<summary> Interlocked ORs the Destination MASK, waits until the operation succeeded. </summary>
+procedure InterlockedOrSpin(var _Destination: LongWord; _Mask: LongWord); inline;
+
+implementation
+
+// InterlockedCompareExchange implements the following as an atomar operation:
+// function InterlockedCompareExchange(var _Destination: integer; _NewValue, _OldValue: integer);
+// begin
+//   Result := _Destination;
+//   if _Destination = OldValue then
+//     _Destination := NewValue;
+// end;
+// redeclared to take LongWord parameters
+
+function InterlockedCompareExchange(var _Destination: LongWord; _NewValue, _OldValue: LongWord): LongWord; cdecl;
+  external kernel32 name 'InterlockedCompareExchange';
+
+function TryInterlockedMask(var _Destination: LongWord; _AndMask, _OrMask: LongWord): boolean;
+var
+  OldValue: LongWord;
+  NewValue: LongWord;
+  CurValue: LongWord;
+begin
+  OldValue := _Destination;
+  NewValue := OldValue and _AndMask or _OrMask;
+  CurValue := InterlockedCompareExchange(_Destination, NewValue, OldValue);
+  Result := (OldValue = CurValue);
+end;
+
+procedure InterlockedMaskSleep(var _Destination: LongWord; _AndMask, _OrMask: LongWord); inline;
+begin
+  while not TryInterlockedMask(_Destination, _AndMask, _OrMask) do
+    Sleep(1);
+end;
+
+procedure InterlockedAndSleep(var _Destination: LongWord; _Mask: LongWord); inline;
+begin
+  InterlockedMaskSleep(_Destination, _Mask, 0);
+end;
+
+procedure InterlockedOrSleep(var _Destination: LongWord; _Mask: LongWord); inline;
+begin
+  InterlockedMaskSleep(_Destination, $FFFFFFFF, _Mask);
+end;
+
+procedure InterlockedMaskSpin(var _Destination: LongWord; _AndMask, _OrMask: LongWord); inline;
+begin
+  while not TryInterlockedMask(_Destination, _AndMask, _OrMask) do
+    ; // wait busily we don't this thread to give up its whole timeslice just because another thread,
+      // which is running on a different CPU just changed the value.
+      // Since the other thread should be already done, it is very likely that the second call will succeed.
+end;
+
+procedure InterlockedAndSpin(var _Destination: LongWord; _Mask: LongWord); inline;
+begin
+  InterlockedMaskSpin(_Destination, _Mask, 0);
+end;
+
+procedure InterlockedOrSpin(var _Destination: LongWord; _Mask: LongWord); inline;
+begin
+  InterlockedMaskSpin(_Destination, $FFFFFFFF, _Mask);
+end;
+
+end.
+



From twm at mail.berlios.de  Fri Sep 25 17:23:56 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:23:56 +0200
Subject: [Dzchart-svncheckins] r356 - utilities/dzLib/trunk/dbcreator
Message-ID: <200909251523.n8PFNusk018872@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:23:55 +0200 (Fri, 25 Sep 2009)
New Revision: 356

Modified:
   utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateAccess.pas
Log:
* Support for GUID fields
* constants DbLevelAccess97 and DbLevelAccess2000
* makes sure that field names don't get longer than 50 chars
* Bugfix: Tables were not inserted in topologial order

Modified: utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateAccess.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateAccess.pas	2009-09-25 15:19:57 UTC (rev 355)
+++ utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateAccess.pas	2009-09-25 15:23:55 UTC (rev 356)
@@ -28,6 +28,10 @@
     destructor Destroy; override;
   end;
 
+const
+  DbLevelAccess97 = 4;
+  DbLevelAccess2000 = 5;
+
 type
   TAccessDbCreator = class(TInterfacedObject, IdzDbCreator)
   private
@@ -52,6 +56,7 @@
   protected // implements IdzDbCreator
     procedure WriteDbDesc(const _DbDescription: IdzDbDescription; const _Version: IdzDbVersionNTypeAncestor);
   public
+     ///<summary> Level: 4 = Access 97, 5 = Access 2000 </summary>
     constructor Create(const _Filename: string; _Level: integer;
       const _DbPassword: string = ''; _AutoAdddzSystemTable: boolean = false);
     destructor Destroy; override;
@@ -76,7 +81,7 @@
 
 const
   DATA_TYPE_MAPPING: TDataTypeMapping = (
-    adInteger, adDouble, adVarWChar, adLongVarWChar, adDate);
+    adInteger, adDouble, adVarWChar, adLongVarWChar, adDate, adGUID);
   SORT_ORDER_MAPPING: TSortOrderMapping = (adSortAscending, adSortDescending);
 
 const
@@ -221,7 +226,10 @@
       ForTabName := Format('%s%s', [FPrefix, ForTable.Name]);
       ForColName := Format('%s%s', [FPrefix, ForTable.PrimaryKey.Column[0].Name]);
       dzAssert(Column.ForeignKeyColumn.DataType = Column.DataType, 'data type of foreign key and primary key of referenced table do not match');
-      KeyName := Format('FK_%s%s_%s_%s', [FPrefix, _Table.Name, Column.Name, ForColName]);
+      KeyName := Format('%s%s_%s_%s', [FPrefix, _Table.Name, Column.Name, ForColName]);
+      if Length(KeyName) > 50 - 4 then
+        KeyName := TailStr(KeyName, 50 - 4);
+      KeyName := 'FK_' + KeyName;
 
       ComKey.Name := KeyName;
       ComKey.Type_ := adKeyForeign;
@@ -389,8 +397,10 @@
             Row := _Table.Rows[RowIdx];
             for FieldIdx := 0 to Row.Count - 1 do begin
               if Row.IsNull(FieldIdx) then
-                tbl.Fields[FieldIdx].Value := null
-              else
+                // in theory it should be possible to set the field to NULL, but apparently
+                // Access distinguishes between NULL and not assigned
+//                tbl.Fields[FieldIdx].Value := null
+              else if not _Table.Columns[FieldIdx].AutoInc then
                 tbl.Fields[FieldIdx].Value := Row.Value[FieldIdx];
             end;
             tbl.Post;
@@ -457,7 +467,7 @@
   finally
     for i := 0 to _DbDescription.TableCount - 1 do begin
       Table := _DbDescription.Tables[i];
-        // free COM Object
+      // free COM Object
       TInterfaceContainer(Table.Data).Free;
       Table.Data := nil;
     end;
@@ -471,7 +481,7 @@
   Sleep(1000);
 
   for i := 0 to _DbDescription.TableCount - 1 do begin
-    Table := _DbDescription.Tables[i];
+    Table := _DbDescription.TopologicalSortedTables[i];
     InsertTableData(_DbDescription, Table);
   end;
 



From twm at mail.berlios.de  Fri Sep 25 17:24:36 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:24:36 +0200
Subject: [Dzchart-svncheckins] r357 - utilities/dzLib/trunk/dbcreator
Message-ID: <200909251524.n8PFOa6u018984@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:24:35 +0200 (Fri, 25 Sep 2009)
New Revision: 357

Modified:
   utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateMsSql.pas
   utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateOracle.pas
Log:
Support for GUID-Fields

Modified: utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateMsSql.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateMsSql.pas	2009-09-25 15:23:55 UTC (rev 356)
+++ utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateMsSql.pas	2009-09-25 15:24:35 UTC (rev 357)
@@ -28,7 +28,7 @@
 
 const
   DATA_TYPE_MAPPING: TDataTypeMapping = (
-    'int', 'float', 'nvarchar', 'ntext', 'datetime');
+    'int', 'float', 'nvarchar', 'ntext', 'datetime', 'uniqueidentifier');
   NULL_ALLOWED_MAPPING: TNullAllowedMapping = (
     'NOT NULL', 'NULL');
   DATA_TYPES_WITH_SIZE = [dtText];

Modified: utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateOracle.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateOracle.pas	2009-09-25 15:23:55 UTC (rev 356)
+++ utilities/dzLib/trunk/dbcreator/u_dzDbCreatorCreateOracle.pas	2009-09-25 15:24:35 UTC (rev 357)
@@ -44,7 +44,8 @@
     'FLOAT', {dtDouble}
     'VARCHAR2', {dtText}
     'LONG', {dtMemo}
-    'DATE'); {dtDate}
+    'DATE', {dtDate}
+    'GUID'); {dtGuid} { TODO -otwm -ccheck : does Oracle actually support this type?? }
 
   NULL_ALLOWED_MAPPING: TNullAllowedMapping = (
     'NOT NULL', 'NULL');



From twm at mail.berlios.de  Fri Sep 25 17:27:19 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:27:19 +0200
Subject: [Dzchart-svncheckins] r358 - utilities/dzLib/trunk/dbcreator
Message-ID: <200909251527.n8PFRJ6s019404@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:27:17 +0200 (Fri, 25 Sep 2009)
New Revision: 358

Modified:
   utilities/dzLib/trunk/dbcreator/u_dzDbCreatorDescription.pas
Log:
* Support for GUID-Fields
* overloaded I/TdzDbIndexDescription.AppendColumn that takes a IdzColumnDescription parameter
* added assertions for foreign key checks


Modified: utilities/dzLib/trunk/dbcreator/u_dzDbCreatorDescription.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzDbCreatorDescription.pas	2009-09-25 15:24:35 UTC (rev 357)
+++ utilities/dzLib/trunk/dbcreator/u_dzDbCreatorDescription.pas	2009-09-25 15:27:17 UTC (rev 358)
@@ -23,7 +23,7 @@
 
   TNullAllowed = (naNotNull, naNull);
   TSortOrder = (soAscending, soDescending);
-  TFieldDataType = (dtLongInt, dtDouble, dtText, dtMemo, dtDate);
+  TFieldDataType = (dtLongInt, dtDouble, dtText, dtMemo, dtDate, dtGUID);
 
 const
   CHKSUM_FIELD = 'chksum';
@@ -171,7 +171,8 @@
     function GetColumns(_Idx: integer): IdzDbColumnDescription;
     function GetColumnsSortorder(_Idx: integer): TSortOrder;
     procedure AlterColumnSortOrder(_ColumnName: string; _SortOrder: TSortOrder);
-    procedure AppendColumn(_ColumnName: string; _SortOrder: TSortOrder = soAscending);
+    procedure AppendColumn(_ColumnName: string; _SortOrder: TSortOrder = soAscending); overload;
+    procedure AppendColumn(_Column: IdzDbColumnDescription; _SortOrder: TSortOrder = soAscending); overload;
     function GetName: string;
     procedure SetName(const _Name: string);
 
@@ -206,7 +207,8 @@
     function GetRefTable: string;
 
     function GetColumns(_Idx: integer): IdzDbColumnDescription; virtual;
-    procedure AppendColumn(_ColumnName: string; _SortOrder: TSortOrder = soAscending); virtual;
+    procedure AppendColumn(_ColumnName: string; _SortOrder: TSortOrder = soAscending); overload;
+    procedure AppendColumn(_Column: IdzDbColumnDescription; _SortOrder: TSortOrder = soAscending); overload;
     procedure AlterColumnSortOrder(_ColumnName: string; _SortOrder: TSortOrder); virtual;
   public
     constructor Create(const _Table: IdzDbTableDescription; const _Name: string;
@@ -791,6 +793,7 @@
     dtText: Result := 'Text';
     dtMemo: Result := 'Memo';
     dtDate: Result := 'Date';
+    dtGuid: Result := 'GUID';
   else
     raise EConvertError.Create(_('Invalid TFieldDataType value'));
   end;
@@ -808,6 +811,8 @@
     Result := dtMemo
   else if AnsiSameText(_s, 'Date') then
     Result := dtDate
+  else if AnsiSameText(_s, 'GUID') then
+    Result := dtGuid
   else
     raise EConvertError.CreateFmt(_('%s is not a valid TFieldDataType name'), [_s]);
 end;
@@ -881,6 +886,9 @@
 procedure TdzDbColumnDescription.SetForeignKey(const _ForeignKeyColumn: IdzDbColumnDescription;
   const _ForeignKeyTable: IdzDbTableDescription);
 begin
+  Assert(Assigned(_ForeignKeyColumn), 'ForeignKeyColumn must not be NIL');
+  Assert(Assigned(_ForeignKeyTable), 'ForeignKeyTable must not be NIL');
+
   FIsForeignKey := true;
   FForeignKeyTable := _ForeignKeyTable;
   FForeignKeyColumn := _ForeignKeyColumn;
@@ -1623,13 +1631,30 @@
   Column: IdzDbColumnDescription;
 begin
   Column := FTable.ColumnByName(_ColumnName);
-
   if not Assigned(Column) then
-    raise EdzDbNoSuchColumn.CreateFmt(_('Table already has a column with name "%s"'), [_ColumnName]);
-
+    raise EdzDbNoSuchColumn.CreateFmt(_('Table has no column with name "%s"'), [_ColumnName]);
   FColumns.Add(TdzDbColNSortorder.Create(Column, _SortOrder));
 end;
 
+procedure TdzDbIndexDescription.AppendColumn(_Column: IdzDbColumnDescription; _SortOrder: TSortOrder);
+begin
+  Assert(Assigned(_Column), 'Column must not be NIL');
+
+
+  // workaround
+  // Wenn die Spalte einem Index hinzugef?gt wird
+  // der einen Primary Key beschreibt, dann muss
+  // die Spalte ebenfalls als PrimaryKey markiert werden
+  if self.FIsPrimaryKey then
+    _Column.SetIndexType(itPrimaryKey)
+  else if self.FIsForeignKey and (not _Column.IsPrimaryKey) then
+    _Column.SetIndexType(itForeignKey)
+  else if self.FIsUniq and (not _Column.IsPrimaryKey) and (not _Column.IsUniqueIndex) then
+    _Column.SetIndexType(itUnique);
+
+  FColumns.Add(TdzDbColNSortorder.Create(_Column, _SortOrder));
+end;
+
 constructor TdzDbIndexDescription.Create(const _Table: IdzDbTableDescription;
   const _Name: string; const _IsPrimaryKey, _IsUniq, _IsForeign: boolean);
 begin
@@ -1726,7 +1751,7 @@
 begin
   inherited Create;
   FColumn := _Column;
-  FSortOrder := _SortOrder
+  FSortOrder := _SortOrder;
 end;
 
 { TdzDbVersionNTypeAncestor }



From twm at mail.berlios.de  Fri Sep 25 17:27:37 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:27:37 +0200
Subject: [Dzchart-svncheckins] r359 - utilities/dzLib/trunk/dbcreator
Message-ID: <200909251527.n8PFRbrE019433@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:27:35 +0200 (Fri, 25 Sep 2009)
New Revision: 359

Modified:
   utilities/dzLib/trunk/dbcreator/u_dzDbCreatorReadAccessDb.pas
Log:
Support for GUID-Fields

Modified: utilities/dzLib/trunk/dbcreator/u_dzDbCreatorReadAccessDb.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzDbCreatorReadAccessDb.pas	2009-09-25 15:27:17 UTC (rev 358)
+++ utilities/dzLib/trunk/dbcreator/u_dzDbCreatorReadAccessDb.pas	2009-09-25 15:27:35 UTC (rev 359)
@@ -114,6 +114,7 @@
     adDate: Result := dtDate;
     adChar, adVarChar, adWChar, adVarWChar: Result := dtText;
     adLongVarChar, adLongVarWChar: Result := dtMemo;
+    adGUID: Result := dtGUID;
   else
     raise exception.CreateFmt('unsupported type %s', [DataTypeToName(_DataType)]);
   end;



From twm at mail.berlios.de  Fri Sep 25 17:28:31 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:28:31 +0200
Subject: [Dzchart-svncheckins] r360 - utilities/dzLib/trunk/dbcreator
Message-ID: <200909251528.n8PFSVe2019532@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:28:29 +0200 (Fri, 25 Sep 2009)
New Revision: 360

Modified:
   utilities/dzLib/trunk/dbcreator/u_dzNameValueList.pas
   utilities/dzLib/trunk/dbcreator/u_dzScriptPositionList.pas
   utilities/dzLib/trunk/dbcreator/u_dzSqlScriptWriter.pas
Log:
adapted to changes in dzTemplates

Modified: utilities/dzLib/trunk/dbcreator/u_dzNameValueList.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzNameValueList.pas	2009-09-25 15:27:35 UTC (rev 359)
+++ utilities/dzLib/trunk/dbcreator/u_dzNameValueList.pas	2009-09-25 15:28:29 UTC (rev 360)
@@ -25,8 +25,6 @@
 {$DEFINE __DZ_SORTED_OBJECT_LIST_TEMPLATE__}
 type
   _LIST_ANCESTOR_ = TObject;
-  _LIST_CONTAINER_ = TList;
-  _LIST_CONTAINER_ITEM_TYPE_ = pointer;
   _ITEM_TYPE_ = TdzNameValueObj;
   _KEY_TYPE_ = string;
 {$INCLUDE 't_dzSortedObjectListTemplate.tpl'}

Modified: utilities/dzLib/trunk/dbcreator/u_dzScriptPositionList.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzScriptPositionList.pas	2009-09-25 15:27:35 UTC (rev 359)
+++ utilities/dzLib/trunk/dbcreator/u_dzScriptPositionList.pas	2009-09-25 15:28:29 UTC (rev 360)
@@ -9,6 +9,7 @@
 type
   // Note: The order of these constants is important, because the objects can be dependent on each other
   TScriptPosition = (
+    spUseDatabase,
     spDropReferences,
     spDropPrimaryKeys,
     spDropIndices,
@@ -44,8 +45,6 @@
 {$DEFINE __DZ_SORTED_OBJECT_LIST_TEMPLATE__}
 type
   _LIST_ANCESTOR_ = TObject;
-  _LIST_CONTAINER_ = TList;
-  _LIST_CONTAINER_ITEM_TYPE_ = pointer;
   _ITEM_TYPE_ = TScriptPositionDesc;
   _KEY_TYPE_ = TScriptPosition;
 {$INCLUDE 't_dzSortedObjectListTemplate.tpl'}

Modified: utilities/dzLib/trunk/dbcreator/u_dzSqlScriptWriter.pas
===================================================================
--- utilities/dzLib/trunk/dbcreator/u_dzSqlScriptWriter.pas	2009-09-25 15:27:35 UTC (rev 359)
+++ utilities/dzLib/trunk/dbcreator/u_dzSqlScriptWriter.pas	2009-09-25 15:28:29 UTC (rev 360)
@@ -148,21 +148,21 @@
 
   // die Reihenfolge der Sections hier entspricht der im Script
   FScriptSections.Append(SCRIPT_NAME_DROPTABLES);
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spDropSequences, SCRIPT_NAME_DROPTABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spDropPrimaryKeys, SCRIPT_NAME_DROPTABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spDropIndices, SCRIPT_NAME_DROPTABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spDropReferences, SCRIPT_NAME_DROPTABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spDropTables, SCRIPT_NAME_DROPTABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spDropSequences, SCRIPT_NAME_DROPTABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spDropPrimaryKeys, SCRIPT_NAME_DROPTABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spDropIndices, SCRIPT_NAME_DROPTABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spDropReferences, SCRIPT_NAME_DROPTABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spDropTables, SCRIPT_NAME_DROPTABLES));
 
   FScriptSections.Append(SCRIPT_NAME_CREATETABLES);
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spCreateSequences, SCRIPT_NAME_CREATETABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spCreateTables, SCRIPT_NAME_CREATETABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spCreateIndices, SCRIPT_NAME_CREATETABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spCreatePrimaryKeys, SCRIPT_NAME_CREATETABLES));
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spCreateReferences, SCRIPT_NAME_CREATETABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spCreateSequences, SCRIPT_NAME_CREATETABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spCreateTables, SCRIPT_NAME_CREATETABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spCreateIndices, SCRIPT_NAME_CREATETABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spCreatePrimaryKeys, SCRIPT_NAME_CREATETABLES));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spCreateReferences, SCRIPT_NAME_CREATETABLES));
 
   FScriptSections.Append(SCRIPT_NAME_INSERTDATA);
-  FScriptPositions.Insert(TScriptPositionDesc.Create(spInsertData, SCRIPT_NAME_INSERTDATA));
+  FScriptPositions.Add(TScriptPositionDesc.Create(spInsertData, SCRIPT_NAME_INSERTDATA));
 end;
 
 destructor TdzSqlScriptWriter.Destroy;
@@ -295,7 +295,7 @@
 
 procedure TdzSqlScriptWriter.AddSetting(const _Name, _Value: string);
 begin
-  FConfigSettings.Insert(TdzConfigSetting.Create(_Name, _Value));
+  FConfigSettings.Add(TdzConfigSetting.Create(_Name, _Value));
 end;
 
 procedure TdzSqlScriptWriter.Clear;



From twm at mail.berlios.de  Fri Sep 25 17:29:49 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:29:49 +0200
Subject: [Dzchart-svncheckins] r361 -
	utilities/dzLib/trunk/tools/DbCreator/src
Message-ID: <200909251529.n8PFTneq019775@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:29:47 +0200 (Fri, 25 Sep 2009)
New Revision: 361

Modified:
   utilities/dzLib/trunk/tools/DbCreator/src/w_Options.dfm
   utilities/dzLib/trunk/tools/DbCreator/src/w_Options.pas
   utilities/dzLib/trunk/tools/DbCreator/src/w_dbCreatorWizard.pas
Log:
removed support for buggy old Validat checksums since I no longer work for iCD there is no point in maintaining this crap

Modified: utilities/dzLib/trunk/tools/DbCreator/src/w_Options.dfm
===================================================================
--- utilities/dzLib/trunk/tools/DbCreator/src/w_Options.dfm	2009-09-25 15:28:29 UTC (rev 360)
+++ utilities/dzLib/trunk/tools/DbCreator/src/w_Options.dfm	2009-09-25 15:29:47 UTC (rev 361)
@@ -31,7 +31,7 @@
     Left = 0
     Top = 24
     Width = 273
-    Height = 81
+    Height = 49
     Caption = 'Checksum options'
     TabOrder = 1
     object Label2: TLabel
@@ -50,14 +50,6 @@
       TabOrder = 0
       OnClick = chk_AddChecksumClick
     end
-    object chk_BuggyChecksum: TCheckBox
-      Left = 8
-      Top = 40
-      Width = 257
-      Height = 17
-      Caption = 'use original Validat checksums (with bug)'
-      TabOrder = 2
-    end
     object chk_RemoveChksum: TCheckBox
       Left = 136
       Top = 16
@@ -70,7 +62,7 @@
   end
   object grp_GraphViz: TGroupBox
     Left = 0
-    Top = 112
+    Top = 88
     Width = 273
     Height = 81
     Caption = 'GraphViz options'
@@ -94,7 +86,7 @@
   end
   object grp_HtmlOptions: TGroupBox
     Left = 0
-    Top = 264
+    Top = 256
     Width = 273
     Height = 105
     Caption = 'HTML Options'
@@ -119,7 +111,7 @@
   end
   object rg_AccessOptions: TRadioGroup
     Left = 0
-    Top = 200
+    Top = 184
     Width = 273
     Height = 57
     Caption = 'MS Access Options'
@@ -137,7 +129,6 @@
       'ed_Prefix.Text'
       'chk_AddChecksum.Checked'
       'chk_RemoveChksum.Checked'
-      'chk_BuggyChecksum.Checked'
       'rg_AccessOptions.ItemIndex')
     StoredValues = <>
     Left = 200

Modified: utilities/dzLib/trunk/tools/DbCreator/src/w_Options.pas
===================================================================
--- utilities/dzLib/trunk/tools/DbCreator/src/w_Options.pas	2009-09-25 15:28:29 UTC (rev 360)
+++ utilities/dzLib/trunk/tools/DbCreator/src/w_Options.pas	2009-09-25 15:29:47 UTC (rev 361)
@@ -25,7 +25,6 @@
     ed_Prefix: TEdit;
     grp_Checksum: TGroupBox;
     chk_AddChecksum: TCheckBox;
-    chk_BuggyChecksum: TCheckBox;
     TheFormStorage: TJvFormStorage;
     chk_RemoveChksum: TCheckBox;
     Label2: TLabel;

Modified: utilities/dzLib/trunk/tools/DbCreator/src/w_dbCreatorWizard.pas
===================================================================
--- utilities/dzLib/trunk/tools/DbCreator/src/w_dbCreatorWizard.pas	2009-09-25 15:28:29 UTC (rev 360)
+++ utilities/dzLib/trunk/tools/DbCreator/src/w_dbCreatorWizard.pas	2009-09-25 15:29:47 UTC (rev 361)
@@ -29,7 +29,7 @@
   ECreateDelphiCode = class(Exception);
 
 type
-  Tf_dbCreatorWizard = class(Tf_HkWizard)
+  Tf_dbCreatorWizard = class(Tf_dzWizard)
     chk_Console: TCheckBox;
     TheAppRegistryStorage: TJvAppRegistryStorage;
     procedure chk_ConsoleClick(Sender: TObject);
@@ -581,10 +581,7 @@
       end;
     end;
 
-    if FOptions.chk_BuggyChecksum.Checked then
-      ImplementationSection.Add('  Result := TV2kUtils.V2kCrcl(s);')
-    else
-      ImplementationSection.Add('  Result := TV2kUtils.Crc32l(Trim(s));');
+    ImplementationSection.Add('  Result := TV2kUtils.Crc32l(Trim(s));');
     ImplementationSection.Add('end;');
     ImplementationSection.Add('');
   end;



From twm at mail.berlios.de  Fri Sep 25 17:30:22 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:30:22 +0200
Subject: [Dzchart-svncheckins] r362 -
	utilities/dzLib/trunk/Packages/Delphi2007
Message-ID: <200909251530.n8PFUM1x019931@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:30:21 +0200 (Fri, 25 Sep 2009)
New Revision: 362

Modified:
   utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dpk
   utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dproj
Log:
added ClassUtils

Modified: utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dpk
===================================================================
--- utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dpk	2009-09-25 15:29:47 UTC (rev 361)
+++ utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dpk	2009-09-25 15:30:21 UTC (rev 362)
@@ -44,6 +44,7 @@
   u_dzVclUtils in '..\..\src\u_dzVclUtils.pas',
   u_dzConvertUtils in '..\..\src\u_dzConvertUtils.pas',
   u_dzStringUtils in '..\..\src\u_dzStringUtils.pas',
-  u_dzTranslator in '..\..\src\u_dzTranslator.pas';
+  u_dzTranslator in '..\..\src\u_dzTranslator.pas',
+  u_dzClassUtils in '..\..\src\u_dzClassUtils.pas';
 
 end.

Modified: utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dproj
===================================================================
--- utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dproj	2009-09-25 15:29:47 UTC (rev 361)
+++ utilities/dzLib/trunk/Packages/Delphi2007/dzComponentsR.dproj	2009-09-25 15:30:21 UTC (rev 362)
@@ -122,6 +122,7 @@
     <DCCReference Include="..\..\components\c_dzVirtualStringGrid.pas" />
     <DCCReference Include="..\..\src\dbrtl.dcp" />
     <DCCReference Include="..\..\src\rtl.dcp" />
+    <DCCReference Include="..\..\src\u_dzClassUtils.pas" />
     <DCCReference Include="..\..\src\u_dzConvertUtils.pas" />
     <DCCReference Include="..\..\src\u_dzStringUtils.pas" />
     <DCCReference Include="..\..\src\u_dzTranslator.pas" />



From twm at mail.berlios.de  Fri Sep 25 17:30:54 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:30:54 +0200
Subject: [Dzchart-svncheckins] r363 - utilities/dzLib/trunk/translations/de
Message-ID: <200909251530.n8PFUsw5020043@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:30:53 +0200 (Fri, 25 Sep 2009)
New Revision: 363

Modified:
   utilities/dzLib/trunk/translations/de/dzlib.po
Log:
more translations

Modified: utilities/dzLib/trunk/translations/de/dzlib.po
===================================================================
--- utilities/dzLib/trunk/translations/de/dzlib.po	2009-09-25 15:30:21 UTC (rev 362)
+++ utilities/dzLib/trunk/translations/de/dzlib.po	2009-09-25 15:30:53 UTC (rev 363)
@@ -6,9 +6,9 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: dzLib 1.0\n"
-"POT-Creation-Date: 2008-09-05 09:45\n"
-"PO-Revision-Date: 2008-09-05 09:50-0800\n"
-"Last-Translator: Thomas Mueller <dzlib at dummzeuch.de>\n"
+"POT-Creation-Date: 2009-08-04 13:39\n"
+"PO-Revision-Date: 2009-08-04 13:41+0100\n"
+"Last-Translator: \n"
 "Language-Team: Thomas Mueller <dzlib at dummzeuch.de>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -17,79 +17,84 @@
 "X-Poedit-Language: German\n"
 "X-Poedit-Country: GERMANY\n"
 
-#: u_dzClassUtils.pas:308
+#: u_dzClassUtils.pas:365
 msgid "no matching object found"
 msgstr "kein passendes Objekt gefunden"
 
-#: u_dzConvertUtils.pas:367
+#: u_dzConvertUtils.pas:397
 msgid "Digit out of range %s"
 msgstr "Ung?ltige Ziffer %s"
 
-#: u_dzConvertUtils.pas:380
+#: u_dzConvertUtils.pas:410
 msgid "Digit #%d (%s) out of range"
 msgstr "Ung?ltige Ziffer #%d (%s)"
 
-#: u_dzConvertUtils.pas:582
+#: u_dzConvertUtils.pas:612
 msgid "\"%s\" is not a valid integer value: %s"
 msgstr "\"%s\" ist kein g?ltiger Integerwert: %s"
 
-#: u_dzConvertUtils.pas:600
+#: u_dzConvertUtils.pas:630
 msgid "\"%s\" is not a valid Int64 value: %s"
 msgstr "\"%s\" ist kein g?ltiger Int64 Wert: %s"
 
-#: u_dzConvertUtils.pas:671
+#: u_dzConvertUtils.pas:701
 msgid "\"%s\" is not a valid floating point value: %s"
 msgstr "\"%s\" ist kein g?ltiger Flie?kommawert: %s"
 
-#: u_dzConvertUtils.pas:677
+#: u_dzConvertUtils.pas:707
 msgid "%.2f EiB"
 msgstr "%.2f EiB"
 
-#: u_dzConvertUtils.pas:679
+#: u_dzConvertUtils.pas:709
 msgid "%.2f PiB"
 msgstr "%.2f PiB"
 
-#: u_dzConvertUtils.pas:681
+#: u_dzConvertUtils.pas:711
 msgid "%.2f TiB"
 msgstr "%.2f TiB"
 
-#: u_dzConvertUtils.pas:683
+#: u_dzConvertUtils.pas:713
 msgid "%.2f GiB"
 msgstr "%.2f GiB"
 
-#: u_dzConvertUtils.pas:685
+#: u_dzConvertUtils.pas:715
 msgid "%.2f MiB"
 msgstr "%.2f MiB"
 
-#: u_dzConvertUtils.pas:687
+#: u_dzConvertUtils.pas:717
 msgid "%.2f KiB"
 msgstr "%.2f KiB"
 
-#: u_dzConvertUtils.pas:689
+#: u_dzConvertUtils.pas:719
 msgid "%d Bytes"
 msgstr "%d Bytes"
 
 #. Days and hours, ignore minutes and seconds
-#: u_dzConvertUtils.pas:696
+#: u_dzConvertUtils.pas:726
 msgid "%dd %dh"
 msgstr "%dd %dh"
 
 #. Hours and minutes, ignore seconds
-#: u_dzConvertUtils.pas:699
+#: u_dzConvertUtils.pas:729
 msgid "%dh %dm"
 msgstr "%dh %dm"
 
 #. Minutes and seconds
-#: u_dzConvertUtils.pas:702
+#: u_dzConvertUtils.pas:732
 msgid "%dm %ds"
 msgstr "%dm %ds"
 
 #. Seconds only
-#: u_dzConvertUtils.pas:705
+#: u_dzConvertUtils.pas:735
 msgid "%ds"
 msgstr "%ds"
 
-#: u_dzDatasetHelpers.pas:335
+#: u_dzConvertUtils.pas:767
+msgid "Length of byte array (%d) does not match size of a LongWord (%d)"
+msgstr "L?nge des Byte-Arrays (%d) stimmt nicht mit der Gr??e eines Longwords (%d) ?berein"
+
+#. Do not use ParamByName -> only works if param is unique
+#: u_dzDatasetHelpers.pas:462
 msgid "SetParamByName is not supported for a %s (only TQuery and TAdoDataset descendants)."
 msgstr "SetParamByName wird f?r %s nicht unterst?tzt (nur TQuery- und TAdoDataset-Abk?mmlinge)"
 
@@ -263,79 +268,79 @@
 msgstr "Kann Dateinamen nicht ?ndern wenn Datei ge?ffnet ist."
 
 #. GetLastError must be called before _(), otherwise the error code gets lost
-#: u_dzFileUtils.pas:834
+#: u_dzFileUtils.pas:854
 msgid "TFileSystem.GetTempPath: %1:s (code: %0:d) calling Windows.GetTempPath"
 msgstr "TFileSystem.GetTempPath: %1:s (code: %0:d) beim Aufruf von Windows.GetTempPath"
 
 #. GetLastError must be called before _(), otherwise the error code gets lost
-#: u_dzFileUtils.pas:842
+#: u_dzFileUtils.pas:862
 msgid "TFileSystem.GetTempPath: %1:s (code: %0:d) calling Windows.GetTempPath (2nd)"
 msgstr "TFileSystem.GetTempPath: %1:s (code: %0:d) beim Aufruf von Windows.GetTempPath (zweiter)"
 
 #. duplicate % so they get passed through the format function
 #. duplicate % so they get passed through the format function
-#: u_dzFileUtils.pas:859
+#: u_dzFileUtils.pas:879
 msgid "Error %%1:s (%%0:d) creating directory \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim Erstellen des Verzeichnisses \"%s\""
 
-#: u_dzFileUtils.pas:883
+#: u_dzFileUtils.pas:903
 msgid "Could not find a unique directory name based on \"%s\""
 msgstr "Konnte keinen eindeutigen Verzeichnisnamen basierend auf \"%s\" finden."
 
 #. GetLastError must be called before _(), otherwise the error code gets lost
-#: u_dzFileUtils.pas:901
+#: u_dzFileUtils.pas:921
 msgid "TFileSystem.GetTempFilename: %1:s (Code: %0:d) calling Windows.GetTempFileName"
 msgstr "TFileSystem.GetTempFilename: %1:s (Code: %0:d) beim Aufruf von Windows.GetTempFileName"
 
-#: u_dzFileUtils.pas:928
+#: u_dzFileUtils.pas:948
 msgid "File not found: \"%s\""
 msgstr "Datei nicht gefunden: \"%s\""
 
-#: u_dzFileUtils.pas:979
+#: u_dzFileUtils.pas:999
 msgid "TFileSystem.GetShortPathname: %1:s (Code: %0:d) calling Windows.GetShortPathname"
 msgstr "TFileSystem.GetShortPathname: %1:s (Code: %0:d) beim Aufruf von Windows.GetShortPathname"
 
-#: u_dzFileUtils.pas:981
+#: u_dzFileUtils.pas:1001
 msgid "Short pathname is longer than MAX_PATH (%d) characters"
 msgstr "Kurzer Pfad ist l?nger als MAX_PATH (%d) Zeichen"
 
 #. duplicate % so they get passed through the format function
-#: u_dzFileUtils.pas:993
+#: u_dzFileUtils.pas:1013
 msgid "Error %%1:s (%%0:d) while trying to move \"%s\" to \"%s\"."
 msgstr "Fehler %%1:s (%%0:d) beim Verschieben von \"%s\" nach \"%s\"."
 
 #. duplicate % so they get passed through the format function
-#: u_dzFileUtils.pas:1011
+#: u_dzFileUtils.pas:1031
 msgid "Error %%1:s (%%0:d) while changing the readonly flag of \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim ?ndern des Schreibschutz-Flags von \"%s\""
 
 #. duplicate % so they get passed through the format function
 #. duplicate % so they get passed through the format function
 #. duplicate % so they get passed through the format function
-#: u_dzFileUtils.pas:1031
+#: u_dzFileUtils.pas:1051
 msgid "Error %%1:s (%%0:d) while trying to copy \"%s\" to \"%s\"."
 msgstr "Fehler %%1:s (%%0:d) beim Kopieren von \"%s\" nach \"%s\"."
 
 #. duplicate % so they get passed through the format function
-#: u_dzFileUtils.pas:1241
+#: u_dzFileUtils.pas:1261
 msgid "Error %%1:s (%%0:d) deleting file \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim L?schen der Datei \"%s\""
 
 #. ForceDirectories can raise EInOutError if the directory path contains empty parts
-#: u_dzFileUtils.pas:1302
+#: u_dzFileUtils.pas:1337
 msgid "Error creating directory \"%s\": %s (%s)"
 msgstr "Fehler beim Erstellen des Verzeichnisses \"%s\": %s (%s)"
 
 #. duplicate % so they get passed through the format function
-#: u_dzFileUtils.pas:1329
+#: u_dzFileUtils.pas:1364
 msgid "Error %%1:s (%%0:d) deleting directory \"%s\""
 msgstr "Fehler %%1:s (%%0:d) beim L?schen des Verzeichnisses \"%s\""
 
-#: u_dzFileUtils.pas:1347
+#: u_dzFileUtils.pas:1382
 msgid "\"%s\" does not exist or is not a directory"
 msgstr "\"%s\" existiert nicht oder ist kein Verzeichnis"
 
-#: u_dzFileUtils.pas:1564
+#: u_dzFileUtils.pas:1610
 msgid "Combination of ResultContainsNumber and KeepOriginal is not allowed"
 msgstr "Kombination von ResultContainsNumber und KeepOriginal ist nicht erlaubt"
 
@@ -353,16 +358,16 @@
 msgid "unknown OS error"
 msgstr "Unbekannter Betriebssystemfehler"
 
-#: u_dzOsUtils.pas:130
+#: u_dzOsUtils.pas:134
 msgid "%s (code %d) calling Windows.GetUsername"
 msgstr "%s (Code %d) beim Aufruf von Windows.GetUsername"
 
 #. 16 KB should be enough for everybody... ;-)
-#: u_dzOsUtils.pas:150
+#: u_dzOsUtils.pas:154
 msgid "Error %1:s (%0:d) calling Windows.ExpandEnvironmentStrings"
 msgstr "Fehler %%1:s (%%0:d) beim Aufruf von Windows.ExpandEnvironmentStrings"
 
-#: u_dzOsUtils.pas:308
+#: u_dzOsUtils.pas:312
 msgid "No version information available for %s"
 msgstr "Keine Versionsinfirmationen fuer %s verf?gbar"
 
@@ -374,15 +379,15 @@
 msgid "Index %d out of bounds."
 msgstr "Index %d nicht im g?ltigen Bereich."
 
-#: u_dzStringUtils.pas:415
+#: u_dzStringUtils.pas:425
 msgid "nthWord: 0th word not available"
 msgstr "nthWord: 0tes Wort ist nicht verf?gbar"
 
-#: u_dzStringUtils.pas:883
+#: u_dzStringUtils.pas:913
 msgid "Cannot center string that is larger than the maximum length."
 msgstr "Kann keinen String zentrieren, der l?nger als die maximale L?nge ist."
 
-#: u_dzStringUtils.pas:972
+#: u_dzStringUtils.pas:1002
 msgid "Strings do not have a 0th character."
 msgstr "Strings haben kein 0tes Zeichen."
 
@@ -400,55 +405,59 @@
 #. do not translate
 #. do not translate
 #. do not translate
-#: u_dzVariantUtils.pas:284
-#: u_dzVariantUtils.pas:339
-#: u_dzVariantUtils.pas:426
-#: u_dzVariantUtils.pas:442
-#: u_dzVariantUtils.pas:488
+#: u_dzVariantUtils.pas:292
+#: u_dzVariantUtils.pas:347
+#: u_dzVariantUtils.pas:434
+#: u_dzVariantUtils.pas:450
+#: u_dzVariantUtils.pas:502
 msgid "Variant is Null, should be %s: %s"
 msgstr "Variant ist Null, sollte %s sein: %s"
 
-#: u_dzVariantUtils.pas:286
-#: u_dzVariantUtils.pas:341
-#: u_dzVariantUtils.pas:428
-#: u_dzVariantUtils.pas:444
-#: u_dzVariantUtils.pas:490
+#: u_dzVariantUtils.pas:294
+#: u_dzVariantUtils.pas:349
+#: u_dzVariantUtils.pas:436
+#: u_dzVariantUtils.pas:452
+#: u_dzVariantUtils.pas:504
 msgid "Variant is Empty, should be %s: %s"
 msgstr "Variant ist leer, sollte %s sein: %s"
 
-#: u_dzVariantUtils.pas:291
-#: u_dzVariantUtils.pas:346
-#: u_dzVariantUtils.pas:433
-#: u_dzVariantUtils.pas:449
-#: u_dzVariantUtils.pas:495
+#: u_dzVariantUtils.pas:299
+#: u_dzVariantUtils.pas:354
+#: u_dzVariantUtils.pas:441
+#: u_dzVariantUtils.pas:457
+#: u_dzVariantUtils.pas:509
 msgid "Variant can not be converted to %s: %s"
 msgstr "Variant kann nicht nach %s konvertiert werden: %s"
 
 #. do not translate
 #. do not translate
 #. do not translate
-#: u_dzVariantUtils.pas:397
-#: u_dzVariantUtils.pas:473
+#: u_dzVariantUtils.pas:405
+#: u_dzVariantUtils.pas:487
 msgid "Variant can not be converted to %s"
 msgstr "Variant kann nicht nach %s konvertiert werden"
 
-#: u_dzVclUtils.pas:685
+#: u_dzVclUtils.pas:586
+msgid "Glyph string contained invalid character at position %d."
+msgstr "Der Glyph-Text beinhaltet ein ung?ltiges Zeichen an Position %d."
+
+#: u_dzVclUtils.pas:812
 msgid "\"%s\" is not a valid floating point value."
 msgstr "\"%s\" ist kein g?ltiger Flie?kommawert."
 
-#: u_dzVclUtils.pas:700
+#: u_dzVclUtils.pas:827
 msgid "\"%s\" is not a valid integer value."
 msgstr "\"%s\" ist kein g?ltiger Integerwert."
 
-#: u_dzVclUtils.pas:1090
+#: u_dzVclUtils.pas:1263
 msgid "No item selected in combobox"
 msgstr "Kein Eintrag der Combobox ausgew?hlt"
 
-#: u_dzVclUtils.pas:1109
+#: u_dzVclUtils.pas:1282
 msgid "No item selected in listbox"
 msgstr "Kein Eintrag der Listbox ausgew?hlt"
 
-#: u_dzVclUtils.pas:1541
+#: u_dzVclUtils.pas:1809
 msgid "JPEG Files"
 msgstr "JPEG Dateien"
 
@@ -470,33 +479,33 @@
 #. f_dzWizard..p_Buttons..b_Next..Caption
 #. f_dzWizardForm..p_Buttons..b_Next..Caption
 #: w_dzWizard.dfm:1210
-#: w_dzWizardForm.pas:227
+#: w_dzWizardForm.pas:226
 msgid "&Next >"
 msgstr "&Weiter >"
 
 #. f_dzWizard..p_Buttons..b_Cancel..Caption
 #. f_dzWizardForm..p_Buttons..b_Cancel..Caption
 #: w_dzWizard.dfm:1223
-#: w_dzWizardForm.pas:226
+#: w_dzWizardForm.pas:225
 msgid "Cancel"
 msgstr "Abbrechen"
 
 #. f_dzWizard..p_Buttons..b_Prev..Caption
 #. f_dzWizardForm..p_Buttons..b_Prev..Caption
 #: w_dzWizard.dfm:1233
-#: w_dzWizardForm.pas:225
+#: w_dzWizardForm.pas:224
 msgid "< &Previous"
 msgstr "< &Zur?ck"
 
-#: w_dzDialog.pas:322
+#: w_dzDialog.pas:328
 msgid "Invalid modal result %d."
 msgstr "Ung?ltiger modaler R?ckgabewert %d."
 
-#: w_dzDialog.pas:495
+#: w_dzDialog.pas:505
 msgid "Do not show again."
 msgstr "Nicht nochmal anzeigen."
 
-#: w_dzDialog.pas:576
+#: w_dzDialog.pas:587
 msgid ""
 "An error occurred:\n"
 "%s"
@@ -505,15 +514,15 @@
 "%s"
 
 #. 400;
-#: w_dzDialog.pas:600
+#: w_dzDialog.pas:611
 msgid "Additional information:"
 msgstr "Erweiterte Informationen:"
 
-#: w_dzDialog.pas:620
+#: w_dzDialog.pas:631
 msgid "&Details >>"
 msgstr "&Details >>"
 
-#: w_dzDialog.pas:775
+#: w_dzDialog.pas:791
 msgid "&Details <<"
 msgstr "&Details <<"
 
@@ -543,7 +552,7 @@
 
 #: w_dzWizard.pas:342
 msgid "&Finish"
-msgstr "&Beenden"
+msgstr "&Fertigstellen"
 
 #: w_dzWizard.pas:478
 msgid "Already on first page."



From twm at mail.berlios.de  Fri Sep 25 17:31:55 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:31:55 +0200
Subject: [Dzchart-svncheckins] r364 - in utilities/dzLib/trunk: .
	IniFileFormatter tools tools/IniFileFormatter
	tools/IniFileFormatter/src
Message-ID: <200909251531.n8PFVtGB020210@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:31:45 +0200 (Fri, 25 Sep 2009)
New Revision: 364

Added:
   utilities/dzLib/trunk/IniFileFormatter/
   utilities/dzLib/trunk/IniFileFormatter/u_dzIniEntryList.pas
   utilities/dzLib/trunk/IniFileFormatter/u_dzIniFileFormatter.pas
   utilities/dzLib/trunk/IniFileFormatter/u_dzIniSections.pas
   utilities/dzLib/trunk/tools/IniFileFormatter/
   utilities/dzLib/trunk/tools/IniFileFormatter/SortTemplate.ini
   utilities/dzLib/trunk/tools/IniFileFormatter/TestIniFile.ini
   utilities/dzLib/trunk/tools/IniFileFormatter/dcu/
   utilities/dzLib/trunk/tools/IniFileFormatter/src/
   utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dpr
   utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dproj
   utilities/dzLib/trunk/tools/IniFileFormatter/src/u_IniFileFormatterMain.pas
   utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.dfm
   utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.pas
Log:
tool and library for formatting and sorting .INI files for easier comparison

Added: utilities/dzLib/trunk/IniFileFormatter/u_dzIniEntryList.pas
===================================================================
--- utilities/dzLib/trunk/IniFileFormatter/u_dzIniEntryList.pas	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/IniFileFormatter/u_dzIniEntryList.pas	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,59 @@
+unit u_dzIniEntryList;
+
+interface
+
+uses
+  SysUtils,
+  Classes,
+  u_dzQuicksort;
+
+type
+  TIniEntryAbstract = class
+  private
+    FLine: string;
+    FComment: string;
+  public
+    constructor Create(const _Line: string);
+    function NameOnly: string; virtual; abstract;
+    property Line: string read FLine;
+    property Comment: string read FComment write FComment;
+  end;
+
+type
+  ICompareIniEntries = interface ['{B60AFA09-F11C-422F-9BE1-9205018F4183}']
+    function Compare(_Idx1, _Idx2: integer): integer;
+  end;
+
+{$DEFINE __DZ_OBJECT_LIST_TEMPLATE__}
+type
+  _LIST_ANCESTOR_ = TObject;
+  _ITEM_TYPE_ = TIniEntryAbstract;
+{$INCLUDE 't_dzObjectListTemplate.tpl'}
+
+type
+  {: List for storing TIniItem items }
+  TIniEntryList = class(_DZ_OBJECT_LIST_TEMPLATE_)
+    procedure Sort(_DataHandler: IQSDataHandler);
+  end;
+
+implementation
+
+{$INCLUDE 't_dzObjectListTemplate.tpl'}
+
+{ TIniEntryAbstract }
+
+constructor TIniEntryAbstract.Create(const _Line: string);
+begin
+  inherited Create;
+  FLine := _Line;
+end;
+
+{ TIniEntryList }
+
+procedure TIniEntryList.Sort(_DataHandler: IQSDataHandler);
+begin
+  QuickSort(0, Count - 1, _DataHandler);
+end;
+
+end.
+

Added: utilities/dzLib/trunk/IniFileFormatter/u_dzIniFileFormatter.pas
===================================================================
--- utilities/dzLib/trunk/IniFileFormatter/u_dzIniFileFormatter.pas	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/IniFileFormatter/u_dzIniFileFormatter.pas	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,231 @@
+unit u_dzIniFileFormatter;
+
+interface
+
+uses
+  SysUtils,
+  Classes,
+  u_dzIniSections,
+  u_dzIniEntryList;
+
+type
+  TIniFileFormatter = class
+  private
+    FSections: TIniEntryList;
+  public
+    constructor Create;
+    destructor Destroy; override;
+    procedure LoadFrom(const _Filename: string);
+    procedure Assign(_Lines: TStrings);
+    procedure AssignSectionsTo(_Names: TStrings);
+    procedure AssignItemsTo(const _Section: string; _Names: TStrings);
+    procedure SortSections(_Template: TStrings = nil);
+    procedure SortItems(const _Section: string; _Template: TStrings = nil);
+    procedure AssignTo(_Lines: TStrings);
+    procedure SaveTo(const _Filename: string);
+  end;
+
+implementation
+
+uses
+  u_dzQuicksort;
+
+type
+  TComparer = class(TInterfacedObject, IQSDataHandler)
+  private
+    FList: TIniEntryList;
+    FTemplate: TStrings;
+  private
+    function Compare(_Idx1, _Idx2: integer): integer;
+    procedure Swap(_Idx1, _Idx2: integer);
+  public
+    constructor Create(_List: TIniEntryList; _Template: TStrings = nil);
+    destructor Destroy; override;
+  end;
+
+{ TComparer }
+
+constructor TComparer.Create(_List: TIniEntryList; _Template: TStrings = nil);
+var
+  i: Integer;
+begin
+  Assert(Assigned(_List));
+
+  inherited Create;
+  FList := _List;
+  FTemplate := TStringList.Create;
+  if Assigned(_Template) then begin
+    for i := 0 to _Template.Count - 1 do
+      FTemplate.Add(LowerCase(_Template[i]));
+  end;
+end;
+
+destructor TComparer.Destroy;
+begin
+  FreeAndNil(FTemplate);
+  inherited;
+end;
+
+procedure TComparer.Swap(_Idx1, _Idx2: integer);
+begin
+  FList.Exchange(_Idx1, _Idx2);
+end;
+
+function TComparer.Compare(_Idx1, _Idx2: integer): integer;
+var
+  Key1: string;
+  Key2: string;
+  Idx1: integer;
+  Idx2: integer;
+begin
+  Key1 := LowerCase(FList[_Idx1].NameOnly);
+  Idx1 := FTemplate.IndexOf(Key1);
+
+  Key2 := LowerCase(FList[_Idx2].NameOnly);
+  Idx2 := FTemplate.IndexOf(Key2);
+
+  if (Idx1 = -1) and (Idx2 <> -1) then
+    Result := 1
+  else if (Idx1 <> -1) and (Idx2 = -1) then
+    Result := -1
+  else begin
+    Result := Idx1 - Idx2;
+    if Result = 0 then
+      Result := CompareStr(Key1, Key2);
+  end;
+end;
+
+{ TIniFileSorter }
+
+constructor TIniFileFormatter.Create;
+begin
+  inherited Create;
+  FSections := TIniEntryList.Create;
+end;
+
+destructor TIniFileFormatter.Destroy;
+begin
+  FreeAndNil(FSections);
+  inherited;
+end;
+
+procedure TIniFileFormatter.LoadFrom(const _Filename: string);
+var
+  Lines: TStringList;
+begin
+  Lines := TStringList.Create;
+  try
+    Lines.LoadFromFile(_Filename);
+    Assign(Lines);
+
+  finally
+    FreeAndNil(Lines);
+  end;
+end;
+
+procedure TIniFileFormatter.Assign(_Lines: TStrings);
+var
+  Comment: TStringList;
+  Section: TIniSection;
+  Item: TIniEntryAbstract;
+  s: string;
+begin
+  FSections.Clear;
+
+  Section := nil;
+  Comment := TStringList.Create;
+  for s in _Lines do begin
+    if Copy(s, 1, 1) = '[' then begin
+      Section := TIniSection.Create(s);
+      Section.Comment := Trim(Comment.Text);
+      Comment.Clear;
+      FSections.Add(Section);
+    end else begin
+      if (Copy(s, 1, 2) = '//') or (Copy(s, 1, 1) = ';')
+        or (Copy(s, 1, 1) = '#') or (Section = nil) then begin
+        Comment.Add(s);
+      end else if (s <> '') then begin
+        Item := TIniItem.Create(s);
+        Item.Comment := Trim(Comment.Text);
+        Comment.Clear;
+        Section.Items.Add(Item);
+      end;
+    end;
+  end;
+end;
+
+procedure TIniFileFormatter.SortSections(_Template: TStrings = nil);
+begin
+  FSections.Sort(TComparer.Create(FSections, _Template));
+end;
+
+procedure TIniFileFormatter.SortItems(const _Section: string; _Template: TStrings = nil);
+var
+  Entry: TIniEntryAbstract;
+  Section: TIniSection;
+begin
+  for Entry in FSections do begin
+    Section := Entry as TIniSection;
+    if SameText(Section.NameOnly, _Section) then
+      Section.Items.Sort(TComparer.Create(Section.Items, _Template));
+  end;
+end;
+
+procedure TIniFileFormatter.AssignSectionsTo(_Names: TStrings);
+var
+  Section: TIniEntryAbstract;
+begin
+  _Names.Clear;
+  for Section in FSections do begin
+    _Names.Add(Section.NameOnly)
+  end;
+end;
+
+procedure TIniFileFormatter.AssignItemsTo(const _Section: string; _Names: TStrings);
+var
+  Section: TIniEntryAbstract;
+  Item: TIniEntryAbstract;
+begin
+  _Names.Clear;
+  for Section in FSections do begin
+    if SameText(Section.NameOnly, _Section) then
+      for Item in (Section as TIniSection).Items do begin
+        _Names.Add(Item.NameOnly);
+      end;
+  end;
+end;
+
+procedure TIniFileFormatter.AssignTo(_Lines: TStrings);
+var
+  Section: TIniEntryAbstract;
+  Item: TIniEntryAbstract;
+begin
+  _Lines.Clear;
+  for Section in FSections do begin
+    if Section.Comment <> '' then
+      _Lines.Add(Section.Comment);
+    _Lines.Add(Section.Line);
+    for Item in (Section as TIniSection).Items do begin
+      if Item.Comment <> '' then
+        _Lines.Add(Item.Comment);
+      _Lines.Add(Item.Line);
+    end;
+    _Lines.Add('');
+  end;
+end;
+
+procedure TIniFileFormatter.SaveTo(const _Filename: string);
+var
+  sl: TStringList;
+begin
+  sl := TStringList.Create;
+  try
+    AssignTo(sl);
+    sl.SaveToFile(_Filename);
+  finally
+    FreeAndNil(sl);
+  end;
+end;
+
+end.
+

Added: utilities/dzLib/trunk/IniFileFormatter/u_dzIniSections.pas
===================================================================
--- utilities/dzLib/trunk/IniFileFormatter/u_dzIniSections.pas	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/IniFileFormatter/u_dzIniSections.pas	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,75 @@
+unit u_dzIniSections;
+
+interface
+
+uses
+  SysUtils,
+  Classes,
+  u_dzIniEntryList;
+
+type
+  TIniItem = class(TIniEntryAbstract)
+  public
+    constructor Create(const _Line: string);
+    function NameOnly: string; override;
+  end;
+
+type
+  TIniSection = class(TIniEntryAbstract)
+  private
+    FItems: TIniEntryList;
+  public
+    constructor Create(const _Name: string);
+    destructor Destroy; override;
+    function NameOnly: string; override;
+    property Items: TIniEntryList read FItems;
+  end;
+
+implementation
+
+uses
+  u_dzQuicksort;
+
+{ TIniItem }
+
+constructor TIniItem.Create(const _Line: string);
+begin
+  Assert(Pos('=', _Line) > 0, 'String does not contain "="');
+
+  inherited Create(_Line);
+end;
+
+function TIniItem.NameOnly: string;
+var
+  p: integer;
+begin
+  Result := Line;
+  p := Pos('=', Result);
+  Result := Copy(Result, 1, p - 1);
+end;
+
+{ TIniSection }
+
+constructor TIniSection.Create(const _Name: string);
+begin
+  Assert(Copy(_Name, 1, 1) = '[', 'String "' + _Name + '" does not start with "["');
+  Assert(Copy(_Name, Length(_Name), 1) = ']', 'String "' + _Name + '" does not end in "]"');
+
+  inherited Create(_Name);
+  FItems := TIniEntryList.Create;
+end;
+
+destructor TIniSection.Destroy;
+begin
+  FreeAndNil(FItems);
+  inherited;
+end;
+
+function TIniSection.NameOnly: string;
+begin
+  Result := Line;
+  Result := Copy(Result, 2, Length(Result) - 2);
+end;
+
+end.
+

Added: utilities/dzLib/trunk/tools/IniFileFormatter/SortTemplate.ini
===================================================================
--- utilities/dzLib/trunk/tools/IniFileFormatter/SortTemplate.ini	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/tools/IniFileFormatter/SortTemplate.ini	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,18 @@
+#comment for section2
+[section2]
+
+item2=zwei
+// comment for section2.item1
+item1=eins
+
+
+#comment for section1
+[section1]
+
+
+
+// comment1 for section1.item1
+// comment2 for section1.item1
+item1=1
+// comment for section1.item2
+item2=1

Added: utilities/dzLib/trunk/tools/IniFileFormatter/TestIniFile.ini
===================================================================
--- utilities/dzLib/trunk/tools/IniFileFormatter/TestIniFile.ini	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/tools/IniFileFormatter/TestIniFile.ini	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,18 @@
+#comment for section2
+[section2]
+// comment for section2.item1
+item1=eins
+
+item2=zwei
+
+
+#comment for section1
+[section1]
+
+// comment for section1.item2
+item2=1
+
+
+// comment1 for section1.item1
+// comment2 for section1.item1
+item1=1

Added: utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dpr
===================================================================
--- utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dpr	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dpr	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,27 @@
+program IniFileFormatter;
+
+uses
+  Forms,
+  w_IniFileFormatter in 'w_IniFileFormatter.pas' {f_IniFileFormatter},
+  u_dzIniFileFormatter in '..\..\..\IniFileFormatter\u_dzIniFileFormatter.pas',
+  u_dzIniSections in '..\..\..\IniFileFormatter\u_dzIniSections.pas',
+  u_dzIniEntryList in '..\..\..\IniFileFormatter\u_dzIniEntryList.pas',
+  u_IniFileFormatterMain in 'u_IniFileFormatterMain.pas',
+  u_dzDefaultMain in '..\..\..\..\dzcmdlineparser\src\u_dzDefaultMain.pas',
+  u_dzGetOpt in '..\..\..\..\dzcmdlineparser\src\u_dzGetOpt.pas',
+  u_dzOptionDescList in '..\..\..\..\dzcmdlineparser\src\u_dzOptionDescList.pas',
+  u_dzOptionFoundList in '..\..\..\..\dzcmdlineparser\src\u_dzOptionFoundList.pas',
+  u_dzOptionNameList in '..\..\..\..\dzcmdlineparser\src\u_dzOptionNameList.pas',
+  u_dzParamDescList in '..\..\..\..\dzcmdlineparser\src\u_dzParamDescList.pas',
+  u_dzParamFoundList in '..\..\..\..\dzcmdlineparser\src\u_dzParamFoundList.pas',
+  w_dzDialog in '..\..\..\forms\w_dzDialog.pas' {f_dzDialog};
+
+{$R *.res}
+
+begin
+  Application.Initialize;
+  Application.Title := 'Ini File Formatter';
+  MainClass := TIniFileFormatterMain;
+  System.ExitCode := Main;
+end.
+

Added: utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dproj
===================================================================
--- utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dproj	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/tools/IniFileFormatter/src/IniFileFormatter.dproj	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,129 @@
+?	<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+		<PropertyGroup>
+			<ProjectGuid>{CC82D07A-2848-46C4-AF4C-2250312D9AB3}</ProjectGuid>
+			<ProjectVersion>12.0</ProjectVersion>
+			<MainSource>IniFileFormatter.dpr</MainSource>
+			<Config Condition="'$(Config)'==''">Debug</Config>
+			<DCC_DCCCompiler>DCC32</DCC_DCCCompiler>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
+			<Base>true</Base>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_1)'!=''">
+			<Cfg_1>true</Cfg_1>
+			<CfgParent>Base</CfgParent>
+			<Base>true</Base>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_2)'!=''">
+			<Cfg_2>true</Cfg_2>
+			<CfgParent>Base</CfgParent>
+			<Base>true</Base>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Base)'!=''">
+			<DCC_UNIT_PLATFORM>false</DCC_UNIT_PLATFORM>
+			<DCC_SYMBOL_PLATFORM>false</DCC_SYMBOL_PLATFORM>
+			<DCC_Define>no_translation;$(DCC_Define)</DCC_Define>
+			<DCC_DebugDCUs>true</DCC_DebugDCUs>
+			<DCC_DcuOutput>..\dcu</DCC_DcuOutput>
+			<DCC_ExeOutput>..</DCC_ExeOutput>
+			<DCC_UnitSearchPath>..\..\..\..\dztemplates\Units;..\..\..\..\dztemplates\templates;..\..\..\jedi_inc;..\..\..\src;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
+			<DCC_DependencyCheckOutputName>..\IniFileFormatter.exe</DCC_DependencyCheckOutputName>
+			<DCC_ImageBase>00400000</DCC_ImageBase>
+			<DCC_UnitAlias>WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;$(DCC_UnitAlias)</DCC_UnitAlias>
+			<DCC_Platform>x86</DCC_Platform>
+			<DCC_E>false</DCC_E>
+			<DCC_N>false</DCC_N>
+			<DCC_S>false</DCC_S>
+			<DCC_F>false</DCC_F>
+			<DCC_K>false</DCC_K>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Cfg_1)'!=''">
+			<DCC_LocalDebugSymbols>false</DCC_LocalDebugSymbols>
+			<DCC_Define>RELEASE;$(DCC_Define)</DCC_Define>
+			<DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
+			<DCC_DebugInformation>false</DCC_DebugInformation>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Cfg_2)'!=''">
+			<DCC_Optimize>false</DCC_Optimize>
+			<DCC_Define>DEBUG;$(DCC_Define)</DCC_Define>
+		</PropertyGroup>
+		<ItemGroup>
+			<DelphiCompile Include="IniFileFormatter.dpr">
+				<MainSource>MainSource</MainSource>
+			</DelphiCompile>
+			<DCCReference Include="w_IniFileFormatter.pas">
+				<Form>f_IniFileFormatter</Form>
+			</DCCReference>
+			<DCCReference Include="..\..\..\IniFileFormatter\u_dzIniFileFormatter.pas"/>
+			<DCCReference Include="..\..\..\IniFileFormatter\u_dzIniSections.pas"/>
+			<DCCReference Include="..\..\..\IniFileFormatter\u_dzIniEntryList.pas"/>
+			<DCCReference Include="u_IniFileFormatterMain.pas"/>
+			<DCCReference Include="..\..\..\..\dzcmdlineparser\src\u_dzDefaultMain.pas"/>
+			<DCCReference Include="..\..\..\..\dzcmdlineparser\src\u_dzGetOpt.pas"/>
+			<DCCReference Include="..\..\..\..\dzcmdlineparser\src\u_dzOptionDescList.pas"/>
+			<DCCReference Include="..\..\..\..\dzcmdlineparser\src\u_dzOptionFoundList.pas"/>
+			<DCCReference Include="..\..\..\..\dzcmdlineparser\src\u_dzOptionNameList.pas"/>
+			<DCCReference Include="..\..\..\..\dzcmdlineparser\src\u_dzParamDescList.pas"/>
+			<DCCReference Include="..\..\..\..\dzcmdlineparser\src\u_dzParamFoundList.pas"/>
+			<DCCReference Include="..\..\..\forms\w_dzDialog.pas">
+				<Form>f_dzDialog</Form>
+			</DCCReference>
+			<BuildConfiguration Include="Base">
+				<Key>Base</Key>
+			</BuildConfiguration>
+			<BuildConfiguration Include="Debug">
+				<Key>Cfg_2</Key>
+				<CfgParent>Base</CfgParent>
+			</BuildConfiguration>
+			<BuildConfiguration Include="Release">
+				<Key>Cfg_1</Key>
+				<CfgParent>Base</CfgParent>
+			</BuildConfiguration>
+		</ItemGroup>
+		<Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Delphi.Targets')"/>
+		<ProjectExtensions>
+			<Borland.Personality>Delphi.Personality.12</Borland.Personality>
+			<Borland.ProjectType/>
+			<BorlandProject>
+				<Delphi.Personality>
+					<Source>
+						<Source Name="MainSource">IniFileFormatter.dpr</Source>
+					</Source>
+					<Parameters>
+						<Parameters Name="UseLauncher">False</Parameters>
+						<Parameters Name="LoadAllSymbols">True</Parameters>
+						<Parameters Name="LoadUnspecifiedSymbols">False</Parameters>
+						<Parameters Name="RunParams">--help</Parameters>
+					</Parameters>
+					<VersionInfo>
+						<VersionInfo Name="IncludeVerInfo">False</VersionInfo>
+						<VersionInfo Name="AutoIncBuild">False</VersionInfo>
+						<VersionInfo Name="MajorVer">1</VersionInfo>
+						<VersionInfo Name="MinorVer">0</VersionInfo>
+						<VersionInfo Name="Release">0</VersionInfo>
+						<VersionInfo Name="Build">0</VersionInfo>
+						<VersionInfo Name="Debug">False</VersionInfo>
+						<VersionInfo Name="PreRelease">False</VersionInfo>
+						<VersionInfo Name="Special">False</VersionInfo>
+						<VersionInfo Name="Private">False</VersionInfo>
+						<VersionInfo Name="DLL">False</VersionInfo>
+						<VersionInfo Name="Locale">1031</VersionInfo>
+						<VersionInfo Name="CodePage">1252</VersionInfo>
+					</VersionInfo>
+					<VersionInfoKeys>
+						<VersionInfoKeys Name="CompanyName"/>
+						<VersionInfoKeys Name="FileDescription"/>
+						<VersionInfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys>
+						<VersionInfoKeys Name="InternalName"/>
+						<VersionInfoKeys Name="LegalCopyright"/>
+						<VersionInfoKeys Name="LegalTrademarks"/>
+						<VersionInfoKeys Name="OriginalFilename"/>
+						<VersionInfoKeys Name="ProductName"/>
+						<VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys>
+						<VersionInfoKeys Name="Comments"/>
+					</VersionInfoKeys>
+				</Delphi.Personality>
+			</BorlandProject>
+			<ProjectFileVersion>12</ProjectFileVersion>
+		</ProjectExtensions>
+	</Project>

Added: utilities/dzLib/trunk/tools/IniFileFormatter/src/u_IniFileFormatterMain.pas
===================================================================
--- utilities/dzLib/trunk/tools/IniFileFormatter/src/u_IniFileFormatterMain.pas	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/tools/IniFileFormatter/src/u_IniFileFormatterMain.pas	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,85 @@
+unit u_IniFileFormatterMain;
+
+interface
+
+uses
+  SysUtils,
+  u_dzDefaultMain;
+
+type
+  TIniFileFormatterMain = class(TDefaultMain)
+  protected
+    procedure InitCmdLineParser; override;
+    function doExecute: integer; override;
+  end;
+
+implementation
+
+uses
+  Forms,
+  u_dzTranslator,
+  w_IniFileFormatter;
+
+{ TIniFileFormatterMain }
+
+procedure TIniFileFormatterMain.InitCmdLineParser;
+begin
+  inherited;
+  FGetOpt.RegisterOption('SortSections', _(
+    'Sort sections. Possible values: no, alpha, template'), true);
+  FGetOpt.RegisterOption('SortItems', _(
+    'Sort items. Possible values: no, alpha, template'), true);
+  FGetOpt.RegisterOption('template', _('Template file for sorting by template')
+    , true);
+  FGetOpt.RegisterParam('SrcFile', _('Source INI file to read and format'), 0, 1);
+  FGetOpt.RegisterParam('DestFile', _('Destination INI file to write, if given, the program exits automatically'), 0, 1);
+end;
+
+function TIniFileFormatterMain.doExecute: integer;
+var
+  SrcFile: string;
+  frm: Tf_IniFileFormatter;
+  SortSections: string;
+  SortItems: string;
+  Template: string;
+  DestFile: string;
+begin
+  Application.CreateForm(Tf_IniFileFormatter, frm);
+
+  if FGetOpt.ParamPassed('SrcFile', SrcFile) then
+    frm.SetSrcFile(SrcFile);
+
+  if FGetOpt.OptionPassed('template', Template) then begin
+    frm.SetTemplate(Template);
+  end;
+
+  SortSections := '';
+  if FGetOpt.OptionPassed('SortSections', SortSections) then begin
+    if SameText(SortSections, 'no') then
+      frm.SetSortSections(0)
+    else if SameText(SortSections, 'template') then
+      frm.SetSortSections(2)
+    else if not SameText(SortSections, 'alpha') then
+      raise Exception.CreateFmt(_('Invalid value "%s" for option SortSections, must be one of "no", "alpha" or "template"'), [SortSections]);
+  end;
+
+  SortItems := '';
+  if FGetOpt.OptionPassed('SortItems', SortItems) then begin
+    if SameText(SortItems, 'no') then
+      frm.SetSortItems(0)
+    else if SameText(SortItems, 'template') then
+      frm.SetSortItems(2)
+    else if not SameText(SortItems, 'alpha') then
+      raise Exception.CreateFmt(_('Invalid value "%s" for option SortSections, must be one of "no", "alpha" or "template"'), [SortItems]);
+  end;
+
+  if FGetOpt.ParamPassed('DestFile', DestFile) then begin
+    frm.Execute(DestFile);
+  end else begin
+    Application.Run;
+  end;
+  Result := 0;
+end;
+
+end.
+

Added: utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.dfm
===================================================================
--- utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.dfm	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.dfm	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,212 @@
+object f_IniFileFormatter: Tf_IniFileFormatter
+  Left = 0
+  Top = 0
+  Caption = 'INI File Formatter'
+  ClientHeight = 569
+  ClientWidth = 601
+  Color = clBtnFace
+  Font.Charset = DEFAULT_CHARSET
+  Font.Color = clWindowText
+  Font.Height = -11
+  Font.Name = 'Tahoma'
+  Font.Style = []
+  OldCreateOrder = False
+  Position = poScreenCenter
+  OnResize = FormResize
+  DesignSize = (
+    601
+    569)
+  PixelsPerInch = 96
+  TextHeight = 13
+  object l_Filename: TLabel
+    Left = 8
+    Top = 8
+    Width = 42
+    Height = 13
+    Caption = 'Filename'
+  end
+  object l_Original: TLabel
+    Left = 8
+    Top = 208
+    Width = 36
+    Height = 13
+    Caption = 'Original'
+  end
+  object l_Preview: TLabel
+    Left = 304
+    Top = 208
+    Width = 38
+    Height = 13
+    Caption = 'Preview'
+  end
+  object l_Template: TLabel
+    Left = 8
+    Top = 160
+    Width = 63
+    Height = 13
+    Caption = 'Template File'
+  end
+  object ed_Filename: TEdit
+    Left = 8
+    Top = 24
+    Width = 553
+    Height = 21
+    Anchors = [akLeft, akTop, akRight]
+    TabOrder = 0
+  end
+  object b_Filename: TButton
+    Left = 568
+    Top = 22
+    Width = 25
+    Height = 25
+    Anchors = [akTop, akRight]
+    Caption = '...'
+    TabOrder = 1
+    OnClick = b_FilenameClick
+  end
+  object m_Original: TMemo
+    Left = 8
+    Top = 224
+    Width = 289
+    Height = 297
+    Anchors = [akLeft, akTop, akBottom]
+    ReadOnly = True
+    ScrollBars = ssBoth
+    TabOrder = 4
+  end
+  object m_Preview: TMemo
+    Left = 304
+    Top = 224
+    Width = 289
+    Height = 297
+    Anchors = [akLeft, akTop, akBottom]
+    ReadOnly = True
+    ScrollBars = ssBoth
+    TabOrder = 5
+  end
+  object gb_SortSections: TGroupBox
+    Left = 8
+    Top = 48
+    Width = 185
+    Height = 105
+    Caption = 'Sort Sections'
+    TabOrder = 2
+    object rb_SectionsUnsorted: TRadioButton
+      Left = 8
+      Top = 24
+      Width = 169
+      Height = 17
+      Caption = 'Unsorted'
+      TabOrder = 0
+      OnClick = SettingsChanged
+    end
+    object rb_SectionsAlpha: TRadioButton
+      Left = 8
+      Top = 48
+      Width = 169
+      Height = 17
+      Caption = 'Alphabetically'
+      Checked = True
+      TabOrder = 1
+      TabStop = True
+      OnClick = SettingsChanged
+    end
+    object rb_SectionsByTemplate: TRadioButton
+      Left = 8
+      Top = 72
+      Width = 169
+      Height = 17
+      Caption = 'By Template'
+      TabOrder = 2
+      OnClick = SettingsChanged
+    end
+  end
+  object gb_SortItems: TGroupBox
+    Left = 208
+    Top = 48
+    Width = 185
+    Height = 105
+    Caption = 'Sort Items'
+    TabOrder = 3
+    object rb_ItemsUnsorted: TRadioButton
+      Left = 8
+      Top = 24
+      Width = 169
+      Height = 17
+      Caption = 'Unsorted'
+      TabOrder = 0
+      OnClick = SettingsChanged
+    end
+    object rb_ItemsAlpha: TRadioButton
+      Left = 8
+      Top = 48
+      Width = 169
+      Height = 17
+      Caption = 'Alphabetically'
+      Checked = True
+      TabOrder = 1
+      TabStop = True
+      OnClick = SettingsChanged
+    end
+    object rb_ItemsByTemplate: TRadioButton
+      Left = 8
+      Top = 72
+      Width = 169
+      Height = 17
+      Caption = 'By Template'
+      TabOrder = 2
+      OnClick = SettingsChanged
+    end
+  end
+  object b_Close: TButton
+    Left = 520
+    Top = 536
+    Width = 75
+    Height = 25
+    Anchors = [akRight, akBottom]
+    Cancel = True
+    Caption = 'Close'
+    TabOrder = 7
+    OnClick = b_CloseClick
+  end
+  object b_SaveAs: TButton
+    Left = 438
+    Top = 536
+    Width = 75
+    Height = 25
+    Anchors = [akRight, akBottom]
+    Caption = 'Save As ...'
+    TabOrder = 6
+    OnClick = b_SaveAsClick
+  end
+  object ed_Template: TEdit
+    Left = 8
+    Top = 176
+    Width = 553
+    Height = 21
+    Anchors = [akLeft, akTop, akRight]
+    TabOrder = 8
+  end
+  object b_Template: TButton
+    Left = 568
+    Top = 174
+    Width = 25
+    Height = 25
+    Anchors = [akTop, akRight]
+    Caption = '...'
+    TabOrder = 9
+    OnClick = b_TemplateClick
+  end
+  object od_Filename: TOpenDialog
+    Filter = 'All files (*.*)|*.*'
+    Title = 'Select file'
+    Left = 152
+  end
+  object sd_Filename: TSaveDialog
+    DefaultExt = '.ini'
+    Filter = 'All files (*.*)|*.*'
+    Title = 'Save File As'
+    Left = 368
+    Top = 520
+  end
+end

Added: utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.pas
===================================================================
--- utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.pas	2009-09-25 15:30:53 UTC (rev 363)
+++ utilities/dzLib/trunk/tools/IniFileFormatter/src/w_IniFileFormatter.pas	2009-09-25 15:31:45 UTC (rev 364)
@@ -0,0 +1,234 @@
+unit w_IniFileFormatter;
+
+interface
+
+uses
+  Windows,
+  Messages,
+  SysUtils,
+  Variants,
+  Classes,
+  Graphics,
+  Controls,
+  Forms,
+  Dialogs,
+  StdCtrls;
+
+type
+  Tf_IniFileFormatter = class(TForm)
+    l_Filename: TLabel;
+    ed_Filename: TEdit;
+    od_Filename: TOpenDialog;
+    b_Filename: TButton;
+    l_Original: TLabel;
+    m_Original: TMemo;
+    l_Preview: TLabel;
+    m_Preview: TMemo;
+    gb_SortSections: TGroupBox;
+    rb_SectionsUnsorted: TRadioButton;
+    rb_SectionsAlpha: TRadioButton;
+    rb_SectionsByTemplate: TRadioButton;
+    gb_SortItems: TGroupBox;
+    rb_ItemsUnsorted: TRadioButton;
+    rb_ItemsAlpha: TRadioButton;
+    rb_ItemsByTemplate: TRadioButton;
+    b_Close: TButton;
+    b_SaveAs: TButton;
+    sd_Filename: TSaveDialog;
+    l_Template: TLabel;
+    ed_Template: TEdit;
+    b_Template: TButton;
+
+    procedure b_FilenameClick(Sender: TObject);
+    procedure FormResize(Sender: TObject);
+    procedure SettingsChanged(Sender: TObject);
+    procedure b_CloseClick(Sender: TObject);
+    procedure b_SaveAsClick(Sender: TObject);
+    procedure b_TemplateClick(Sender: TObject);
+  private
+    procedure LoadAndSort(const _Filename: string);
+    function FormatIni: boolean;
+  public
+    procedure SetSrcFile(const _Value: string);
+    procedure SetSortSections(_Idx: integer);
+    procedure SetSortItems(_Idx: integer);
+    procedure SetTemplate(const _Value: string);
+    function Execute(const _Value: string): boolean;
+  end;
+
+implementation
+
+{$R *.dfm}
+
+uses
+  u_dzIniFileFormatter,
+  u_dzIniSections;
+
+procedure Tf_IniFileFormatter.b_CloseClick(Sender: TObject);
+begin
+  Close;
+end;
+
+procedure Tf_IniFileFormatter.b_FilenameClick(Sender: TObject);
+begin
+  od_Filename.FileName := ed_Filename.Text;
+  if od_Filename.Execute then begin
+    ed_Filename.Text := od_Filename.FileName;
+    LoadAndSort(ed_Filename.Text);
+  end;
+end;
+
+procedure Tf_IniFileFormatter.b_TemplateClick(Sender: TObject);
+begin
+  od_Filename.FileName := ed_Template.Text;
+  if od_Filename.Execute then begin
+    ed_Template.Text := od_Filename.FileName;
+  end;
+  FormatIni;
+end;
+
+procedure Tf_IniFileFormatter.b_SaveAsClick(Sender: TObject);
+begin
+  sd_Filename.FileName := ed_Filename.Text;
+  if sd_Filename.Execute then
+    m_Preview.Lines.SaveToFile(sd_Filename.FileName);
+end;
+
+function Tf_IniFileFormatter.Execute(const _Value: string): boolean;
+begin
+  Result := FormatIni;
+  if Result then
+    m_Preview.Lines.SaveToFile(_Value);
+end;
+
+procedure Tf_IniFileFormatter.SetSortItems(_Idx: integer);
+begin
+  case _Idx of
+    0: rb_ItemsUnsorted.Checked := true;
+    2: rb_ItemsByTemplate.Checked := true;
+  // else: alpha-sort
+  end;
+end;
+
+procedure Tf_IniFileFormatter.SetSortSections(_Idx: integer);
+begin
+  case _Idx of
+    0: rb_SectionsUnsorted.Checked := true;
+    2: rb_SectionsByTemplate.Checked := true;
+  // else: alpha-sort
+  end;
+end;
+
+procedure Tf_IniFileFormatter.SetSrcFile(const _Value: string);
+begin
+  ed_Filename.Text := _Value;
+  m_Original.Lines.LoadFromFile(_Value);
+end;
+
+procedure Tf_IniFileFormatter.SetTemplate(const _Value: string);
+begin
+  ed_Template.Text := _Value;
+end;
+
+procedure Tf_IniFileFormatter.SettingsChanged(Sender: TObject);
+begin
+  FormatIni;
+end;
+
+procedure Tf_IniFileFormatter.FormResize(Sender: TObject);
+var
+  w: Integer;
+  l: Integer;
+begin
+  w := (ClientWidth - m_Original.Left * 3) div 2;
+  m_Original.Width := w;
+  m_Preview.Width := w;
+  l := m_Original.Left * 2 + w;
+  m_Preview.Left := l;
+  l_Preview.Left := l;
+end;
+
+procedure Tf_IniFileFormatter.LoadAndSort(const _Filename: string);
+begin
+  m_Original.Lines.LoadFromFile(_Filename);
+  FormatIni;
+end;
+
+function Tf_IniFileFormatter.FormatIni: boolean;
+var
+  b: boolean;
+  Formatter: TIniFileFormatter;
+  Template: TIniFileFormatter;
+  SortTemplate: TStringList;
+  Sections: TStringList;
+  s: string;
+begin
+  Result := false;
+
+  Template := nil;
+
+  b := rb_SectionsByTemplate.Checked or rb_ItemsByTemplate.Checked;
+  if b then begin
+    if (ed_Template.Text = '') then begin
+      m_Preview.Lines.Clear;
+      exit;
+    end;
+    Template := TIniFileFormatter.Create;
+    try
+      Template.LoadFrom(ed_Template.Text);
+    except
+      FreeAndNil(Template);
+      raise;
+    end;
+  end;
+
+  Formatter := TIniFileFormatter.Create;
+  try
+    Formatter.Assign(m_Original.Lines);
+
+    if rb_SectionsAlpha.Checked then begin
+      Formatter.SortSections(nil);
+    end else if rb_SectionsByTemplate.Checked then begin
+      Assert(Assigned(Template));
+      SortTemplate := TStringList.Create;
+      try
+        Template.AssignSectionsTo(SortTemplate);
+        Formatter.SortSections(SortTemplate);
+      finally
+        FreeAndNil(SortTemplate);
+      end;
+    end;
+
+    Sections := TStringList.Create;
+    try
+      Formatter.AssignSectionsTo(Sections);
+      if rb_ItemsAlpha.Checked then begin
+        for s in Sections do begin
+          Formatter.SortItems(s, nil);
+        end;
+      end else if rb_ItemsByTemplate.Checked then begin
+        Assert(Assigned(Template));
+        for s in Sections do begin
+          SortTemplate := TStringList.Create;
+          try
+            Template.AssignItemsTo(s, SortTemplate);
+            Formatter.SortItems(s, SortTemplate);
+          finally
+            FreeAndNil(SortTemplate);
+          end;
+        end;
+      end;
+    finally
+      FreeAndNil(Sections);
+    end;
+
+    Formatter.AssignTo(m_Preview.Lines);
+  finally
+    FreeAndNil(Formatter);
+    FreeAndNil(Template);
+  end;
+  Result := true;
+end;
+
+end.
+



From twm at mail.berlios.de  Fri Sep 25 17:37:43 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:37:43 +0200
Subject: [Dzchart-svncheckins] r365 - utilities/dzLib/trunk/src
Message-ID: <200909251537.n8PFbhxq021050@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:37:39 +0200 (Fri, 25 Sep 2009)
New Revision: 365

Added:
   utilities/dzLib/trunk/src/u_dzDbUtils.pas
   utilities/dzLib/trunk/src/u_dzGuidUtils.pas
   utilities/dzLib/trunk/src/u_dzJvclUtils.pas
   utilities/dzLib/trunk/src/u_dzStatistics.pas
Log:
* new unit u_dzDbUtils with database utility functions (tested only for DBase)
 - TTable_DeleteTable
 - TTable_DeleteAllIndices
 - TTable_AddFieldDef
* new unit u_dzGuidUtils with:
 - TNullableGuid class
 - TryStr2Guid function
 - TryVar2Guid function
* new unit u_dzJvclUtils with utility functions for JVCL controls:
 - TJvSpinEdit_SetValueNoChange
* new unit u_dzStatistics with
 - TMovingAverage class


Added: utilities/dzLib/trunk/src/u_dzDbUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzDbUtils.pas	2009-09-25 15:31:45 UTC (rev 364)
+++ utilities/dzLib/trunk/src/u_dzDbUtils.pas	2009-09-25 15:37:39 UTC (rev 365)
@@ -0,0 +1,61 @@
+unit u_dzDbUtils;
+
+interface
+
+uses
+  SysUtils,
+  Classes,
+  DBTables,
+  DB;
+
+///<summary> Deletes the table file if it exists, only tested for dbase tables
+///          @returns true, if successfull, false otherwise </summary>
+function TTable_DeleteTable(_tbl: TTable): boolean;
+
+///<summary> Deletes all table indices, only tested for dbase tables </summary>
+procedure TTable_DeleteAllIndices(_tbl: TTable);
+
+///<summary> Adds a field definition to a table </summary>
+procedure TTable_AddFieldDef(_tbl: TTable; const _Name: string; _DataType: TFieldType; _Precision, _Size: integer); inline;
+
+implementation
+
+function TTable_DeleteTable(_tbl: TTable): boolean;
+begin
+  Result := FileExists(IncludeTrailingPathDelimiter(_tbl.DatabaseName) + _tbl.TableName);
+  if Result then
+    _tbl.DeleteTable;
+end;
+
+procedure TTable_DeleteAllIndices(_tbl: TTable);
+var
+  i: Integer;
+  sl: TStringList;
+begin
+  if _tbl.TableName = '' then
+    exit;
+  if _tbl.Active then _tbl.Active := False;
+  _tbl.IndexName := '';
+  sl := TStringList.Create;
+  try
+    _tbl.GetIndexNames(sl);
+    for i := 0 to sl.Count - 1 do
+      _tbl.DeleteIndex(sl[i]);
+  finally
+    sl.Free;
+  end;
+end;
+
+procedure TTable_AddFieldDef(_tbl: TTable; const _Name: string; _DataType: TFieldType; _Precision, _Size: integer);
+var
+  fd: TFieldDef;
+begin
+  fd := _tbl.FieldDefs.AddFieldDef;
+  fd.Name := _Name;
+  fd.DataType := _DataType;
+  fd.Precision := _Precision;
+  fd.Size := _Size;
+end;
+
+end.
+

Added: utilities/dzLib/trunk/src/u_dzGuidUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzGuidUtils.pas	2009-09-25 15:31:45 UTC (rev 364)
+++ utilities/dzLib/trunk/src/u_dzGuidUtils.pas	2009-09-25 15:37:39 UTC (rev 365)
@@ -0,0 +1,157 @@
+unit u_dzGuidUtils;
+
+interface
+
+uses
+  SysUtils;
+
+type
+  TNullableGuid = record
+  private
+    FValue: TGuid;
+    FIsValid: IInterface;
+  public
+    ///<summary> Generates a new GUID using WinAPI calls </summary>
+    procedure GenerateNew;
+    ///<summary> convert to a variant for using for database fields / parameters) </summary>
+    function ToVariant: Variant;
+    ///<summary> convert from a variant for assigning a database field </summary>
+    function AssignVariant(_v: Variant): boolean;
+    ///<summary> explicit cast to string "string(GUID)" converts to standard string form </summary>
+    class operator Explicit(_a: TNullableGuid): string;
+    ///<summary> compares two NullableGuids, returns true, if the are equal, raises exception if one
+    ///          is not valid </summary>
+    class operator Equal(_a, _b: TNullableGuid): boolean;
+    ///<summary> compares two NullableGuids, returns truw if they are different or at least one is invalid </summary>
+    class operator NotEqual(_a, _b: TNullableGuid): boolean;
+    ///<summary> implicit conversion from TGUID </summary>
+    class operator Implicit(_a: TGUID): TNullableGuid;
+    ///<summary> returns the GUID, if valid, raises an exception otherwise </summary>
+    function Value: TGuid;
+    ///<summary> returns true, if valid, false otherwise </summary>
+    function IsValid: boolean;
+  end;
+
+///<summary> Tries to convert a string to a GUID, returns true if successfull </summary>
+function TryStr2GUID(const _s: string; out _GUID: TGUID): boolean;
+///<summary> Tries to convert a variant to a GUID, returns true if successfull </summary>
+function TryVar2GUID(const _v: variant; out _GUID: TGUID): boolean;
+
+implementation
+
+uses
+  u_dzVariantUtils,
+  ActiveX;
+
+// this is a fake interfaced object that only exists as the VMT
+// It can still be used to trick the compiler into believing an interface pointer is assigned
+
+function NopAddref(inst: Pointer): Integer; stdcall;
+begin
+  Result := -1;
+end;
+
+function NopRelease(inst: Pointer): Integer; stdcall;
+begin
+  Result := -1;
+end;
+
+function NopQueryInterface(inst: Pointer; const IID: TGUID; out Obj): HResult; stdcall;
+begin
+  Result := E_NOINTERFACE;
+end;
+
+const
+  FlagInterfaceVTable: array[0..2] of Pointer =
+    (
+    @NopQueryInterface,
+    @NopAddref,
+    @NopRelease
+    );
+const
+  FlagInterfaceInstance: Pointer = @FlagInterfaceVTable;
+
+function GetNullableTypesFlagInterface: IInterface;
+begin
+  Result := IInterface(@FlagInterfaceInstance);
+end;
+
+{ TGuidEx }
+
+function TryStr2GUID(const _s: string; out _GUID: TGUID): boolean;
+begin
+  Result := Succeeded(CLSIDFromString(PWideChar(WideString(_s)), _GUID));
+end;
+
+function TryVar2GUID(const _v: variant; out _GUID: TGUID): boolean;
+var
+  s: string;
+begin
+  Result := TryVar2Str(_v, s);
+  if Result then
+    Result := TryStr2GUID(s, _GUID);
+end;
+
+function TNullableGuid.AssignVariant(_v: Variant): boolean;
+begin
+  Result := TryVar2GUID(_v, FValue);
+  if Result then
+    FIsValid := GetNullableTypesFlagInterface
+  else
+    FIsValid := nil;
+end;
+
+function TNullableGuid.ToVariant: Variant;
+begin
+  Result := string(Self);
+end;
+
+function TNullableGuid.Value: TGuid;
+begin
+  if not Assigned(FIsValid) then
+    raise Exception.Create('TNullableGuid is not valid');
+  Result := FValue;
+end;
+
+class operator TNullableGuid.Equal(_a, _b: TNullableGuid): boolean;
+begin
+  Result := IsEqualGUID(_a.Value, _b.Value);
+end;
+
+class operator TNullableGuid.NotEqual(_a, _b: TNullableGuid): boolean;
+begin
+  if _a.IsValid and _b.IsValid then
+    Result := not IsEqualGUID(_a.Value, _b.Value)
+  else
+    Result := _a.IsValid or _b.IsValid;
+end;
+
+class operator TNullableGuid.Explicit(_a: TNullableGuid): string;
+begin
+  if _a.IsValid then
+    Result := GUIDToString(_a.FValue)
+  else
+    Result := '';
+end;
+
+procedure TNullableGuid.GenerateNew;
+begin
+  if Succeeded(CreateGUID(FValue)) then
+    FIsValid := GetNullableTypesFlagInterface
+  else
+    FIsValid := nil;
+end;
+
+class operator TNullableGuid.Implicit(_a: TGUID): TNullableGuid;
+begin
+  Result.FValue := _a;
+  Result.FIsValid := GetNullableTypesFlagInterface;
+end;
+
+function TNullableGuid.IsValid: boolean;
+begin
+  Result := Assigned(FIsValid);
+end;
+
+end.
+

Added: utilities/dzLib/trunk/src/u_dzJvclUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzJvclUtils.pas	2009-09-25 15:31:45 UTC (rev 364)
+++ utilities/dzLib/trunk/src/u_dzJvclUtils.pas	2009-09-25 15:37:39 UTC (rev 365)
@@ -0,0 +1,28 @@
+unit u_dzJvclUtils;
+
+interface
+
+uses
+  JvSpin;
+
+procedure TJvSpinEdit_SetValueNoChange(_sed: TJvSpinEdit; _Value: extended);
+
+implementation
+
+uses
+  Classes;
+
+procedure TJvSpinEdit_SetValueNoChange(_sed: TJvSpinEdit; _Value: extended);
+var
+  Event: TNotifyEvent;
+begin
+  Event := _sed.OnChange;
+  _sed.OnChange := nil;
+  try
+    _sed.Value := _Value;
+  finally
+    _sed.OnChange := Event;
+  end;
+end;
+
+end.

Added: utilities/dzLib/trunk/src/u_dzStatistics.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzStatistics.pas	2009-09-25 15:31:45 UTC (rev 364)
+++ utilities/dzLib/trunk/src/u_dzStatistics.pas	2009-09-25 15:37:39 UTC (rev 365)
@@ -0,0 +1,73 @@
+///<summary> statistical tools </summary>
+unit u_dzStatistics;
+
+interface
+
+uses
+  SysUtils,
+  u_dzTranslator,
+  u_dzRingBuffer;
+
+type
+  TMovingAverage = class
+  private
+    FCount: integer;
+    FSum: extended;
+    FMaxCount: integer;
+    FQueue: TdzRingQueue;
+  public
+    constructor Create(_MaxCount: integer);
+    destructor Destroy; override;
+    procedure Add(_Value: Extended);
+    function GetAverage: extended;
+    property Count: integer read FCount;
+  end;
+
+implementation
+
+
+function _(const _s: string): string; inline;
+begin
+  Result := dzDGetText(_s, 'dzlib');
+end;
+
+{ TMovingAverage }
+
+constructor TMovingAverage.Create(_MaxCount: integer);
+begin
+  inherited Create;
+  FSum := 0;
+  FCount := 0;
+  FMaxCount := _MaxCount;
+  FQueue := TdzRingQueue.Create(SizeOf(Extended), FMaxCount);
+end;
+
+destructor TMovingAverage.Destroy;
+begin
+  FreeAndNil(FQueue);
+  inherited;
+end;
+
+procedure TMovingAverage.Add(_Value: Extended);
+var
+  ValueToRemove: extended;
+begin
+  if FCount >= FMaxCount then begin
+    FQueue.ExtractFront(ValueToRemove);
+    FSum := FSum - ValueToRemove;
+  end else
+    Inc(FCount);
+  FQueue.InsertEnd(_Value);
+  FSum := FSum + _Value;
+end;
+
+function TMovingAverage.GetAverage: extended;
+begin
+  if FCount > 0 then
+    Result := FSum / FCount
+  else
+    raise Exception.Create(_('Cannot calculate moving average on zero elements'));
+end;
+
+end.
+



From twm at mail.berlios.de  Fri Sep 25 17:45:23 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 17:45:23 +0200
Subject: [Dzchart-svncheckins] r366 - in utilities/dzCmdLineParser/trunk: .
	src translations/de
Message-ID: <200909251545.n8PFjN7Y022733@sheep.berlios.de>

Author: twm
Date: 2009-09-25 17:45:20 +0200 (Fri, 25 Sep 2009)
New Revision: 366

Modified:
   utilities/dzCmdLineParser/trunk/UpdateTranslations.cmd
   utilities/dzCmdLineParser/trunk/src/u_dzCmdLineParser.pas
   utilities/dzCmdLineParser/trunk/src/u_dzDefaultMain.pas
   utilities/dzCmdLineParser/trunk/src/u_dzGetOpt.pas
   utilities/dzCmdLineParser/trunk/src/u_dzOptionDescList.pas
   utilities/dzCmdLineParser/trunk/translations/de/dzCmdLineParser.po
Log:
* translation now uses inlined _() functions that call dzDGetText for domain dzCmdLineParser rather than resource strings
* support for simple logging during startup
* Delphi 2009/2010 compatible
* support for hidden options, that is options that are allowed but will not be in the generated help


Modified: utilities/dzCmdLineParser/trunk/UpdateTranslations.cmd
===================================================================
--- utilities/dzCmdLineParser/trunk/UpdateTranslations.cmd	2009-09-25 15:37:39 UTC (rev 365)
+++ utilities/dzCmdLineParser/trunk/UpdateTranslations.cmd	2009-09-25 15:45:20 UTC (rev 366)
@@ -5,7 +5,7 @@
 set BASE=.
 
 @rem extract from subdirectories src and forms
-dxgettext --delphi -r -b %BASE%\src -o %BASE%\
+dxgettext --delphi -r -b %BASE%\src -b %BASE%\forms -o %BASE%
 
 @rem remove strings given in ignore.po
 msgremove %BASE%\default.po -i %BASE%\ignore.po -o %BASE%\filtered.po
@@ -13,4 +13,7 @@
 @rem merge German translations
 msgmerge --no-wrap --update %BASE%\translations\de\dzCmdLineParser.po %BASE%\filtered.po
 
+ at rem merge Eerman translations
+msgmerge --no-wrap --update %BASE%\translations\en\dzCmdLineParser.po %BASE%\filtered.po
+
 pause

Modified: utilities/dzCmdLineParser/trunk/src/u_dzCmdLineParser.pas
===================================================================
--- utilities/dzCmdLineParser/trunk/src/u_dzCmdLineParser.pas	2009-09-25 15:37:39 UTC (rev 365)
+++ utilities/dzCmdLineParser/trunk/src/u_dzCmdLineParser.pas	2009-09-25 15:45:20 UTC (rev 366)
@@ -12,8 +12,10 @@
 
 uses
   SysUtils,
-  Classes;
+  Classes,
+  u_dzTranslator;
 
+
 type
   EStateEngineError = class(exception);
 
@@ -77,6 +79,11 @@
   u_dzStringUtils,
   u_dzCmdLineParserStates;
 
+function _(const _s: string): string; inline;
+begin
+  Result := dzDGetText(_s, 'dzCmdLineParser');
+end;
+
 type
   IEngineContextEx = interface ['{CD19DB13-F344-4E1A-B97F-D235B445B463}']
     procedure GetOptions(_Options: TStrings);

Modified: utilities/dzCmdLineParser/trunk/src/u_dzDefaultMain.pas
===================================================================
--- utilities/dzCmdLineParser/trunk/src/u_dzDefaultMain.pas	2009-09-25 15:37:39 UTC (rev 365)
+++ utilities/dzCmdLineParser/trunk/src/u_dzDefaultMain.pas	2009-09-25 15:45:20 UTC (rev 366)
@@ -34,7 +34,7 @@
     {: Created in InitCmdLineParser, allows reading the parameters }
     FGetOpt: TGetOpt;
     {: Initializes FGetOptr with a Parser, should be overridden, but make
-       sure you call inherited }
+       sure you call inherited if you want to have the --help option }
     procedure InitCmdLineParser; virtual;
     {: Shows a short help generated by the TGetOpt and exits the program by calling
        SysUtils.Abort.
@@ -52,19 +52,21 @@
        @returns the exit code for the program }
     function doExecute: integer; virtual;
   public
-    {: Creates a TDefaultMain instance, sets the exit code to 1 (=error) and
-       initializes logging }
+    {: Creates a TDefaultMain instance and sets the exit code to 1 (=error)
+       also, does a very simple parsing of the commandline to determine whether
+       the --StartupLog option was given and initializes logging, if it was }
     constructor Create; virtual;
     {: Frees a TDefaultMain instance and writes the progrem end into the log }
     destructor Destroy; override;
-    {: This method should be called after the instance of TDefaultMain has been
-       created. It initialzies the commandline parser, executes it on the given
+    {: Call this method after the instance of TDefaultMain has been created.
+       It initializes the commandline parser, executes it on the given
        commandline and calls doExecute within a try..except block.
        If doExecute raises an exception it will write an error message to the
-       console and set the exit code to 1 (=error). If doExecute exits normally
-       it uses the result as exit code.
+       console or show an error dialog and set the exit code to 1 (=error).
+       If doExecute exits normally it uses the result as exit code.
        @returns the exit code for the program }
     function Execute: integer;
+    ///<summary> Returns the programm name that was used to start this application
     property ProgName: string read GetProgName;
     property ExeName: string read GetExeName;
   end;
@@ -93,17 +95,33 @@
   u_dzLogging,
   w_dzDialog;
 
-resourcestring
-  RS_Error_S = 'Error: %s';
-  RS_Synopsis_S_S = 'Synopsis: %s %s';
-  RS_Parameters = 'Parameters:';
-  RS_Options = 'Options:';
+function _(const _s: string): string; inline;
+begin
+  Result := dzDGetText(_s, 'dzCmdLineParser');
+end;
 
 constructor TDefaultMain.Create;
+const
+  STARTUP_LOG = '--startuplog=';
+var
+  s: string;
+  p: integer;
 begin
   inherited;
   // default: error
   FExitCode := 1;
+
+  s := GetCommandLine;
+  s := LowerCase(s);
+  p := Pos(STARTUP_LOG, s);
+  if p > 0 then begin
+    s := Copy(s, p + Length(STARTUP_LOG));
+    p := Pos(' ', s);
+    if p > 0 then
+      s := Copy(s, 1, p - 1);
+    SetGlobalLogger(TFileLogger.Create(s));
+  end;
+  FGetOpt := TGetOpt.Create();
 end;
 
 destructor TDefaultMain.Destroy;
@@ -115,7 +133,7 @@
 
 function TDefaultMain.doExecute: integer;
 begin
-  MessageDlg('This program does nothing yet.', mtInformation, [mbOK], 0);
+  MessageDlg(_('This program does nothing yet.'), mtInformation, [mbOK], 0);
   Result := 0;
 end;
 
@@ -124,14 +142,14 @@
   s: string;
 begin
   if _Error <> '' then begin
-    s := Format(RS_Error_S + #13#10#13#10, [_Error]);
+    s := Format(_('Error: %s') + #13#10#13#10, [_Error]);
     LogError(_Error);
   end;
   MessageDlg(s + Format(
-    RS_Synopsis_S_S + #13#10#13#10 +
-    RS_Parameters + #13#10 +
+    _('Synopsis: %s %s') + #13#10#13#10 +
+    _('Parameters:') + #13#10 +
     '%s'#13#10#13#10 +
-    RS_Options + #13#10 +
+    _('Options:') + #13#10 +
     '%s',
     [FGetOpt.ProgName, FGetOpt.GetCmdLineDesc, FGetOpt.GetParamHelp, FGetOpt.GetOptionHelp]),
     mtError, [mbOK], 0);
@@ -141,8 +159,8 @@
 
 procedure TDefaultMain.InitCmdLineParser;
 begin
-  FGetOpt := TGetOpt.Create();
   FGetOpt.RegisterHelpOptions;
+  FGetOpt.RegisterOption('StartupLog', _('Write a startup log to the given file.'), true);
 end;
 
 procedure TDefaultMain.ParseCmdLine;
@@ -171,7 +189,7 @@
       // we do not want to show an error if the code called Abort because this
       // is supposed to be a silent exception. So we log it and terminate with
       // an exit code of 1
-      LogError(e.Message + '(' + e.ClassName +')');
+      LogError(e.Message + '(' + e.ClassName + ')');
       FExitCode := 1;
     end;
     on e: Exception do begin
@@ -180,7 +198,7 @@
       if IsConsole then
         WriteLn(s)
       else
-       Tf_dzDialog.ShowException(e);
+        Tf_dzDialog.ShowException(e);
       FExitCode := 1;
     end;
   end;
@@ -192,9 +210,9 @@
   ModuleName: AnsiString;
 begin
   SetLength(ModuleName, 255);
-  GetModuleFileNameA(MainInstance, PChar(ModuleName), Length(ModuleName));
-  OemToAnsi(PChar(ModuleName), PChar(ModuleName));
-  Result := Pchar(ModuleName);
+  GetModuleFileNameA(MainInstance, PAnsiChar(ModuleName), Length(ModuleName));
+  OemToAnsi(PAnsiChar(ModuleName), PAnsiChar(ModuleName));
+  Result := PAnsiChar(ModuleName);
 end;
 
 function TDefaultMain.GetProgName: string;
@@ -212,7 +230,7 @@
     try
       Result := MainObj.Execute;
     finally
-      MainObj.Free;
+      FreeAndNil(MainObj);
     end;
   except
     // Exception handling is done within the MainObj. If something gets here

Modified: utilities/dzCmdLineParser/trunk/src/u_dzGetOpt.pas
===================================================================
--- utilities/dzCmdLineParser/trunk/src/u_dzGetOpt.pas	2009-09-25 15:37:39 UTC (rev 365)
+++ utilities/dzCmdLineParser/trunk/src/u_dzGetOpt.pas	2009-09-25 15:45:20 UTC (rev 366)
@@ -45,16 +45,20 @@
     ///                       names are not, that is --help and --HELP are the same.
     ///          @param Description is a string describing the option for the usage string
     ///          @param HasValue is a boolean which tells the parser whether to expect
-    ///                          a parameter for this option. </summary>
+    ///                          a parameter for this option.
+    ///   Note: One character option names are case sensitive, that is -o and -O
+    ///         are not the same, but longer option names are not, that is
+    ///         --help and --HELP are the same. </summary>
     procedure RegisterOption(const _Names: array of string; const _Description: string; _HasValue: boolean = false); overload;
     procedure RegisterOption(const _Name, _Description: string; _HasValue: boolean = false); overload;
+    procedure RegisterHiddenOption(const _Name: string; _HasValue: boolean = false);
     ///<summary> registers the standard options --help, -?, -h and -H for displaying help </summary>
     procedure RegisterHelpOptions;
     ///<summary> registers a commandline parameter
     ///          @param Name is the name of the parameter as displayed in the usage string.
     ///          @param Description is the description of the parameter for the usage.
     ///          @param MinCount is the minimum number of parameters to expect
-    ///          @param MaxCount is the maximum number of parameters to expect
+    ///          @param MaxCount is the maximum number of parameters to expect, -1 for infinite
     ///          Note: only the last parameter should really have MinCount and MaxCount <> 1 </summary>
     procedure RegisterParam(const _Name, _Description: string; _MinCount: integer = 1; _MaxCount: integer = 1);
     ///<summary> parses the commandline
@@ -138,11 +142,11 @@
 
 destructor TGetOpt.Destroy;
 begin
-  FOptionDescList.Free;
-  FOptionNameList.Free;
-  FOptionsFoundList.Free;
-  FParamDescList.Free;
-  FParamsFoundList.Free;
+  FreeAndNil(FOptionDescList);
+  FreeAndNil(FOptionNameList);
+  FreeAndNil(FOptionsFoundList);
+  FreeAndNil(FParamDescList);
+  FreeAndNil(FParamsFoundList);
   inherited;
 end;
 
@@ -152,7 +156,7 @@
   ParamDesc: TParamDesc;
   s: string;
 begin
-  if FOptionDescList.Count <> 0 then
+  if FOptionDescList.NonHiddenCount <> 0 then
     Result := _('[options]')
   else
     Result := '';
@@ -174,9 +178,12 @@
   Result := '';
   for i := 0 to FOptionDescList.Count - 1 do begin
     OptionDesc := FOptionDescList[i];
-    if Result <> '' then
-      Result := Result + #13#10;
-    Result := Result + OptionDesc.GetDescription(_Indent);
+    if not OptionDesc.isHidden then begin
+
+      if Result <> '' then
+        Result := Result + #13#10;
+      Result := Result + OptionDesc.GetDescription(_Indent);
+    end;
   end;
 end;
 
@@ -194,7 +201,12 @@
 end;
 
 function TGetOpt.HelpOptionFound: boolean;
+var
+  Idx: integer;
 begin
+  Result := False;
+  if not FOptionNameList.Find(PChar('help'), Idx) then
+    exit;
   Result := OptionPassed('help', nil) <> 0;
 end;
 
@@ -232,15 +244,15 @@
 
 function TGetOpt.OptionPassed(const _Name: string; var _Value: string): boolean;
 var
-  st: TStringList;
+  sl: TStringList;
 begin
-  st := TStringList.Create;
+  sl := TStringList.Create;
   try
-    Result := OptionPassed(_Name, st) = 1;
+    Result := OptionPassed(_Name, sl) = 1;
     if Result then
-      _Value := st[0];
+      _Value := sl[0];
   finally
-    st.Free;
+    FreeAndNil(sl);
   end;
 end;
 
@@ -263,15 +275,15 @@
 
 function TGetOpt.ParamPassed(const _ParamName: string; var _Value: string): boolean;
 var
-  st: TStringList;
+  sl: TStringList;
 begin
-  st := TStringList.Create;
+  sl := TStringList.Create;
   try
-    Result := ParamPassed(_ParamName, st) = 1;
+    Result := ParamPassed(_ParamName, sl) = 1;
     if Result then
-      _Value := st[0];
+      _Value := sl[0];
   finally
-    st.Free;
+    FreeAndNil(sl);
   end;
 end;
 
@@ -338,8 +350,8 @@
     Params.Delete(0);
     EvaluateCmdLine(Options, Params);
   finally
-    Options.Free;
-    Params.Free;
+    FreeAndNil(Options);
+    FreeAndNil(Params);
   end;
 end;
 
@@ -355,8 +367,8 @@
     TCmdLineParser.Execute(_CmdLine, Options, Params);
     EvaluateCmdLine(Options, Params);
   finally
-    Params.Free;
-    Options.Free;
+    FreeAndNil(Params);
+    FreeAndNil(Options);
   end;
 end;
 
@@ -382,6 +394,15 @@
     FOptionNameList.Add(TOptionName.Create(_Names[i], Desc));
 end;
 
+procedure TGetOpt.RegisterHiddenOption(const _Name: string; _HasValue: boolean = false);
+var
+  Desc: TOptionDesc;
+begin
+  Desc := TOptionDesc.Create([_Name], '', _HasValue, true);
+  FOptionDescList.Add(Desc);
+  FOptionNameList.Add(TOptionName.Create(_Name, Desc));
+end;
+
 procedure TGetOpt.RegisterParam(const _Name, _Description: string;
   _MinCount, _MaxCount: integer);
 begin

Modified: utilities/dzCmdLineParser/trunk/src/u_dzOptionDescList.pas
===================================================================
--- utilities/dzCmdLineParser/trunk/src/u_dzOptionDescList.pas	2009-09-25 15:37:39 UTC (rev 365)
+++ utilities/dzCmdLineParser/trunk/src/u_dzOptionDescList.pas	2009-09-25 15:45:20 UTC (rev 366)
@@ -15,8 +15,9 @@
 type
   TOptionDesc = class
   private
+    FIsHidden: boolean;
     function CreateDescription(const _OptionName: string): string;
-    procedure AssertValidOptionName(_Name: string);
+    procedure AssertValidOptionName(_Name: ansistring);
   protected
     FPrimaryName: string;
     FDescription: string;
@@ -24,11 +25,12 @@
     FNames: TStringList;
   public
     constructor Create(const _Names: array of string; const _Description: string;
-      _HasValue: boolean = false);
+      _HasValue: boolean = false; _IsHidden: boolean = false);
     destructor Destroy; override;
     function GetDescription(_Indent: integer): string;
     property HasValue: boolean read FHasValue;
     property PrimaryName: string read FPrimaryName;
+    property isHidden: boolean read FIsHidden write FIsHidden;
   end;
 
 {$DEFINE __DZ_SORTED_OBJECT_LIST_TEMPLATE__}
@@ -47,6 +49,8 @@
     ///<summary> compare the keys of two items, must return a value
     ///          < 0 if Key1 < Key2, = 0 if Key1 = Key2 and > 0 if Key1 > Key2 </summary>
     function Compare(const _Key1, _Key2: string): integer; override;
+  public
+    function NonHiddenCount: integer;
   end;
 
 implementation
@@ -66,13 +70,23 @@
   Result := _Item.PrimaryName;
 end;
 
+function TOptionDescList.NonHiddenCount: integer;
+var
+  i: Integer;
+begin
+  result := 0;
+  for i := 0 to Count - 1 do
+    if not Items[i].isHidden then
+      Inc(Result);
+end;
+
 function TOptionDescList.Compare(const _Key1, _Key2: string): integer;
 begin
   Result := CompareText(_Key1, _Key2);
 end;
 
-constructor TOptionDesc.Create(const _Names: array of string;
-  const _Description: string; _HasValue: boolean = false);
+constructor TOptionDesc.Create(const _Names: array of string; const _Description: string;
+  _HasValue: boolean = false; _IsHidden: boolean = false);
 var
   i: integer;
   s: string;
@@ -80,35 +94,36 @@
   inherited Create;
   FDescription := _Description;
   FHasValue := _HasValue;
+  FIsHidden := _IsHidden;
   Assert(Length(_Names) > 0);
   FPrimaryName := _Names[0];
-  AssertValidOptionName(FPrimaryName);
+  AssertValidOptionName(AnsiString(FPrimaryName));
   FNames := TStringList.Create;
   for i := 0 to high(_Names) do begin
     s := _Names[i];
-    AssertValidOptionName(s);
+    AssertValidOptionName(AnsiString(s));
     fNames.Add(s);
   end;
 end;
 
 destructor TOptionDesc.Destroy;
 begin
-  FNames.Free;
+  FreeAndNil(FNames);
   inherited;
 end;
 
-procedure TOptionDesc.AssertValidOptionName(_Name: string);
+procedure TOptionDesc.AssertValidOptionName(_Name: ansistring);
 var
   i: integer;
 begin
   if _Name = '' then
     raise EOptionName.Create(_('Option name cannot be empty.'));
-  { TODO -otwm : Maybe '$', '#' and some other chars should be allowed }
+  { TODO -otwm : Maybe '$', '#' and some other special chars should be allowed }
   if not (_Name[1] in ['a'..'z', 'A'..'Z', '0'..'9', '?']) then
     raise EOptionName.Create(_('Option name must start with an alphanumeric character.'));
   for i := 2 to Length(_Name) do
     if not (_Name[i] in ['a'..'z', 'A'..'Z', '0'..'9', '-', '_']) then
-      raise EOptionName.CreateFmt(_('Option name contains invalid character "%s" (%d).'), [_Name[i], Ord(_Name[i])]);
+      raise EOptionName.CreateFmt(_('Option name contains invalid character "%s" at position %d.'), [_Name[i], Ord(_Name[i])]);
 end;
 
 function TOptionDesc.CreateDescription(const _OptionName: string): string;

Modified: utilities/dzCmdLineParser/trunk/translations/de/dzCmdLineParser.po
===================================================================
--- utilities/dzCmdLineParser/trunk/translations/de/dzCmdLineParser.po	2009-09-25 15:37:39 UTC (rev 365)
+++ utilities/dzCmdLineParser/trunk/translations/de/dzCmdLineParser.po	2009-09-25 15:45:20 UTC (rev 366)
@@ -6,9 +6,9 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: dzCmdLineParser 1.0\n"
-"POT-Creation-Date: 2008-09-05 06:07\n"
-"PO-Revision-Date: 2008-09-05 06:03-0800\n"
-"Last-Translator: Thomas Mueller <dzlib at dummzeuch.de>\n"
+"POT-Creation-Date: 2009-06-30 11:42\n"
+"PO-Revision-Date: 2009-06-30 11:46+0100\n"
+"Last-Translator: Thomas Mueller <info at schniering.com>\n"
 "Language-Team: twm <nospam at dummzeuch.de>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -17,74 +17,82 @@
 "X-Poedit-Language: German\n"
 "X-Poedit-Country: GERMANY\n"
 
-#: u_dzCmdLineParserStates.pas:197 
 u_dzCmdLineParserStates.pas:217
-#: u_dzCmdLineParserStates.pas:231 u_dzCmdLineParserStates.pas:254
-#: u_dzCmdLineParserStates.pas:270 u_dzCmdLineParserStates.pas:313
-#: u_dzCmdLineParserStates.pas:335 u_dzCmdLineParserStates.pas:377
+#: u_dzCmdLineParserStates.pas:197
+#: u_dzCmdLineParserStates.pas:231
+#: u_dzCmdLineParserStates.pas:254
+#: u_dzCmdLineParserStates.pas:270
+#: u_dzCmdLineParserStates.pas:313
+#: u_dzCmdLineParserStates.pas:335
+#: u_dzCmdLineParserStates.pas:377
 msgid "Invalid character \"%s\"."
 msgstr "Ung?ltiges Zeichen \"%s\""
 
-#. Programmer's name for it: RS_Error_S
-#: u_dzDefaultMain.pas:97 
+#: u_dzDefaultMain.pas:136
+msgid "This program does nothing yet."
+msgstr "Dieses Programm macht noch nichts."
+
+#: u_dzDefaultMain.pas:145
 msgid "Error: %s"
 msgstr "Fehler: %s"
 
-#. Programmer's name for it: RS_Synopsis_S_S
-#: u_dzDefaultMain.pas:98 
+#: u_dzDefaultMain.pas:149
 msgid "Synopsis: %s %s"
 msgstr "Aufruf: %s %s"
 
-#. Programmer's name for it: RS_Parameters
-#: u_dzDefaultMain.pas:99 
+#: u_dzDefaultMain.pas:150
 msgid "Parameters:"
 msgstr "Parameter:"
 
-#. Programmer's name for it: RS_Options
-#: u_dzDefaultMain.pas:100 
+#: u_dzDefaultMain.pas:152
 msgid "Options:"
 msgstr "Optionen:"
 
-#: u_dzGetOpt.pas:156 
+#: u_dzDefaultMain.pas:163
+msgid "Write a startup log to the given file."
+msgstr "Startup-Log in angegebene Datei schreiben."
+
+#: u_dzGetOpt.pas:160
 msgid "[options]"
 msgstr "[Optionen]"
 
-#: u_dzGetOpt.pas:215 
+#: u_dzGetOpt.pas:227
 msgid "%s is not a registered option."
 msgstr "%s ist keine registrierte Option"
 
-#: u_dzGetOpt.pas:294 
+#: u_dzGetOpt.pas:306
 msgid "There are too many parameters."
 msgstr "Zuviele Parameter"
 
-#: u_dzGetOpt.pas:304 
 u_dzGetOpt.pas:310
+#: u_dzGetOpt.pas:316
 msgid "There are not enough %s parameters (min: %d)"
 msgstr "Nicht gen?gend %s Parameter (min: %d)"
 
-#: u_dzGetOpt.pas:317 
+#: u_dzGetOpt.pas:329
 msgid "Option %s is unknown"
 msgstr "Option %s ist nciht bekannt"
 
-#: u_dzGetOpt.pas:321 
+#: u_dzGetOpt.pas:333
 msgid "Option %s requires a value."
 msgstr "Option %s ben?tigt einen Wert."
 
-#: u_dzGetOpt.pas:365 
+#: u_dzGetOpt.pas:377
 msgid "display parameter help"
 msgstr "Parameter Hilfe anzeigen"
 
-#: u_dzOptionDescList.pas:105 
+#: u_dzOptionDescList.pas:120
 msgid "Option name cannot be empty."
 msgstr "Optionsname kann nicht leer sein."
 
-#: u_dzOptionDescList.pas:108 
+#: u_dzOptionDescList.pas:123
 msgid "Option name must start with an alphanumeric character."
 msgstr "Optionsname muss mit einem alphanumerischen Zeichen beginnen."
 
-#: u_dzOptionDescList.pas:111 
-msgid "Option name contains invalid character \"%s\" (%d)."
-msgstr "Optionsname enth?lt ung?ltiges Zeichen \"%s\" (%d)"
+#: u_dzOptionDescList.pas:126
+msgid "Option name contains invalid character \"%s\" at position %d."
+msgstr "Optionsname enth?lt ung?ltiges Zeichen \"%s\" bei Position %d."
 
-#. should never happen
-#: u_dzOptionDescList.pas:121 
 u_dzOptionDescList.pas:126
+#. should never happen
+#: u_dzOptionDescList.pas:136
 msgid "value"
 msgstr "Wert"
+



From twm at mail.berlios.de  Fri Sep 25 20:42:04 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 20:42:04 +0200
Subject: [Dzchart-svncheckins] r367 - utilities/dzLib/trunk/src
Message-ID: <200909251842.n8PIg4wF025820@sheep.berlios.de>

Author: twm
Date: 2009-09-25 20:42:02 +0200 (Fri, 25 Sep 2009)
New Revision: 367

Modified:
   utilities/dzLib/trunk/src/u_dzStringUtils.pas
Log:
char -> ansichar (Delphi 2009 compatibility)

Modified: utilities/dzLib/trunk/src/u_dzStringUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzStringUtils.pas	2009-09-25 15:45:20 UTC (rev 366)
+++ utilities/dzLib/trunk/src/u_dzStringUtils.pas	2009-09-25 18:42:02 UTC (rev 367)
@@ -26,7 +26,7 @@
   ECharIndexOutOfRange = class(EStringfunc);
 
 type
-  TCharSet = set of char;
+  TCharSet = set of ansichar;
 
 const
   ///<summary> Characters that are usually used as word delimiters.



From twm at mail.berlios.de  Fri Sep 25 20:42:46 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 20:42:46 +0200
Subject: [Dzchart-svncheckins] r368 - utilities/dzLib/trunk/src
Message-ID: <200909251842.n8PIgkPX025860@sheep.berlios.de>

Author: twm
Date: 2009-09-25 20:42:45 +0200 (Fri, 25 Sep 2009)
New Revision: 368

Modified:
   utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas
Log:
CheckEquals for single, double and extended, calling Math.SameValue

Modified: utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas	2009-09-25 18:42:02 UTC (rev 367)
+++ utilities/dzLib/trunk/src/u_dzUnitTestUtils.pas	2009-09-25 18:42:45 UTC (rev 368)
@@ -18,6 +18,9 @@
   TdzTestCase = class(TTestcase)
   protected
   public
+    procedure CheckEquals(_Expected, _Actual: single; _Msg: string = ''); overload;
+    procedure CheckEquals(_Expected, _Actual: double; _Msg: string = ''); overload;
+    procedure CheckEquals(_Expected, _Actual: extended; _Msg: string = ''); overload;
     /// <summary>
     /// Checks whether the value is a variant of a floating point type (includes integer)
     /// </summary>
@@ -45,7 +48,7 @@
     /// <summary>
     /// Checks whether the value is a variant of a string type
     /// </summary>
-    procedure CheckVariantIsString(_Value: variant; _Msg: string='');
+    procedure CheckVariantIsString(_Value: variant; _Msg: string = '');
     /// <summary>
     /// Called by the CheckVAriantIsXxxx functions to show errors
     /// </summary>
@@ -83,6 +86,7 @@
 implementation
 
 uses
+  Math,
   Variants,
   DateUtils,
   u_dzVariantUtils;
@@ -107,6 +111,24 @@
     FailNotVarType('longword', VarTypeAsText(VarType(_Value)), _Msg, CallerAddr);
 end;
 
+procedure TdzTestCase.CheckEquals(_Expected, _Actual: single; _Msg: string);
+begin
+  if not Math.SameValue(_Expected, _Actual) then
+    FailNotEquals(FloatToStr(_Expected), FloatToStr(_Actual), _Msg, CallerAddr);
+end;
+
+procedure TdzTestCase.CheckEquals(_Expected, _Actual: double; _Msg: string);
+begin
+  if not Math.SameValue(_Expected, _Actual) then
+    FailNotEquals(FloatToStr(_Expected), FloatToStr(_Actual), _Msg, CallerAddr);
+end;
+
+procedure TdzTestCase.CheckEquals(_Expected, _Actual: extended; _Msg: string);
+begin
+  if not Math.SameValue(_Expected, _Actual) then
+    FailNotEquals(FloatToStr(_Expected), FloatToStr(_Actual), _Msg, CallerAddr);
+end;
+
 procedure TdzTestCase.CheckEqualsDate(_Expected, _Actual: TDateTime; const _Message: string);
 begin
   if not DateUtils.SameDate(_Expected, _Actual) then



From twm at mail.berlios.de  Fri Sep 25 20:43:21 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 20:43:21 +0200
Subject: [Dzchart-svncheckins] r369 - utilities/dzLib/trunk/src
Message-ID: <200909251843.n8PIhLc8025904@sheep.berlios.de>

Author: twm
Date: 2009-09-25 20:43:19 +0200 (Fri, 25 Sep 2009)
New Revision: 369

Modified:
   utilities/dzLib/trunk/src/u_dzVariantUtils.pas
Log:
new function TryVar2Single

Modified: utilities/dzLib/trunk/src/u_dzVariantUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzVariantUtils.pas	2009-09-25 18:42:45 UTC (rev 368)
+++ utilities/dzLib/trunk/src/u_dzVariantUtils.pas	2009-09-25 18:43:19 UTC (rev 369)
@@ -80,6 +80,15 @@
 ///                   NullValue if v can not be converted </summary>
 function Var2IntStr(const _v: variant; const _NullValue: string = '*NULL*'): string;
 
+///<summary> tries to convert a variant to a single
+///          If v is null or empty, it returns false.
+///          @param v Variant value to convert
+///          @param Value is the variant's single value, only valid if the function
+///                       returns true.
+///          @returns true, if the variant could be converted to single, false if not
+///          @raises EVariantConvertError if there is some other conversion error </summary>
+function TryVar2Single(const _v: variant; out _Value: single): boolean;
+
 ///<summary> tries to convert a variant to a double
 ///          If v is null or empty, it returns false.
 ///          @param v Variant value to convert
@@ -391,6 +400,20 @@
     end;
 end;
 
+function TryVar2Single(const _v: variant; out _Value: single): boolean;
+const
+  EXPECTED = 'single'; // do not translate
+begin
+  Result := not VarIsNull(_v) and not VarIsEmpty(_v);
+  if Result then
+    try
+      _Value := _v;
+    except
+      on e: EVariantError do
+        raise EVariantConvertError.CreateFmt(_('Variant can not be converted to %s'), [EXPECTED]);
+    end;
+end;
+
 function TryVar2Dbl(const _v: variant; out _Value: double): boolean;
 const
   EXPECTED = 'double'; // do not translate



From twm at mail.berlios.de  Fri Sep 25 20:45:32 2009
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Fri, 25 Sep 2009 20:45:32 +0200
Subject: [Dzchart-svncheckins] r370 - in utilities/dzLib/trunk: . src
	templates tests tests/NullableTypesTest
	tests/NullableTypesTest/dcu tests/NullableTypesTest/src
Message-ID: <200909251845.n8PIjWqH026133@sheep.berlios.de>

Author: twm
Date: 2009-09-25 20:45:27 +0200 (Fri, 25 Sep 2009)
New Revision: 370

Added:
   utilities/dzLib/trunk/src/u_dzNullableDouble.pas
   utilities/dzLib/trunk/src/u_dzNullableExtended.pas
   utilities/dzLib/trunk/src/u_dzNullableInt64.pas
   utilities/dzLib/trunk/src/u_dzNullableInteger.pas
   utilities/dzLib/trunk/src/u_dzNullableSingle.pas
   utilities/dzLib/trunk/src/u_dzNullableTypesUtils.pas
   utilities/dzLib/trunk/templates/
   utilities/dzLib/trunk/templates/t_NullableNumber.tpl
   utilities/dzLib/trunk/tests/NullableTypesTest/
   utilities/dzLib/trunk/tests/NullableTypesTest/dcu/
   utilities/dzLib/trunk/tests/NullableTypesTest/src/
   utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dpr
   utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dproj
   utilities/dzLib/trunk/tests/NullableTypesTest/src/u_NullableTypesTest.pas
Log:
* Nullable number template
* implementations for Integer, Int64, Single, Double and Extended
* unit tests (far from complete)

Added: utilities/dzLib/trunk/src/u_dzNullableDouble.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzNullableDouble.pas	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/src/u_dzNullableDouble.pas	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,25 @@
+unit u_dzNullableDouble;
+
+interface
+
+uses
+  Math,
+  Variants,
+  u_dzTranslator,
+  u_dzVariantUtils,
+  u_dzNullableTypesUtils;
+
+{$DEFINE __DZ_NULLABLE_NUMBER_TEMPLATE__}
+type
+  _NULLABLE_TYPE_BASE_ = Double;
+{$INCLUDE 't_NullableNumber.tpl'}
+
+type
+  TNullableDouble = _NULLABLE_NUMBER_;
+
+implementation
+
+{$INCLUDE 't_NullableNumber.tpl'}
+
+end.
+

Added: utilities/dzLib/trunk/src/u_dzNullableExtended.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzNullableExtended.pas	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/src/u_dzNullableExtended.pas	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,25 @@
+unit u_dzNullableExtended;
+
+interface
+
+uses
+  Math,
+  Variants,
+  u_dzTranslator,
+  u_dzVariantUtils,
+  u_dzNullableTypesUtils;
+
+{$DEFINE __DZ_NULLABLE_NUMBER_TEMPLATE__}
+type
+  _NULLABLE_TYPE_BASE_ = Extended;
+{$INCLUDE 't_NullableNumber.tpl'}
+
+type
+  TNullableExtended = _NULLABLE_NUMBER_;
+
+implementation
+
+{$INCLUDE 't_NullableNumber.tpl'}
+
+end.
+

Added: utilities/dzLib/trunk/src/u_dzNullableInt64.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzNullableInt64.pas	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/src/u_dzNullableInt64.pas	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,25 @@
+unit u_dzNullableInt64;
+
+interface
+
+uses
+  Math,
+  Variants,
+  u_dzTranslator,
+  u_dzVariantUtils,
+  u_dzNullableTypesUtils;
+
+{$DEFINE __DZ_NULLABLE_NUMBER_TEMPLATE__}
+type
+  _NULLABLE_TYPE_BASE_ = Int64;
+{$INCLUDE 't_NullableNumber.tpl'}
+
+type
+  TNullableInt64 = _NULLABLE_NUMBER_;
+
+implementation
+
+{$INCLUDE 't_NullableNumber.tpl'}
+
+end.
+

Added: utilities/dzLib/trunk/src/u_dzNullableInteger.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzNullableInteger.pas	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/src/u_dzNullableInteger.pas	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,25 @@
+unit u_dzNullableInteger;
+
+interface
+
+uses
+  Math,
+  Variants,
+  u_dzTranslator,
+  u_dzVariantUtils,
+  u_dzNullableTypesUtils;
+
+{$DEFINE __DZ_NULLABLE_NUMBER_TEMPLATE__}
+type
+  _NULLABLE_TYPE_BASE_ = integer;
+{$INCLUDE 't_NullableNumber.tpl'}
+
+type
+  TNullableInteger = _NULLABLE_NUMBER_;
+
+implementation
+
+{$INCLUDE 't_NullableNumber.tpl'}
+
+end.
+

Added: utilities/dzLib/trunk/src/u_dzNullableSingle.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzNullableSingle.pas	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/src/u_dzNullableSingle.pas	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,25 @@
+unit u_dzNullableSingle;
+
+interface
+
+uses
+  Math,
+  Variants,
+  u_dzTranslator,
+  u_dzVariantUtils,
+  u_dzNullableTypesUtils;
+
+{$DEFINE __DZ_NULLABLE_NUMBER_TEMPLATE__}
+type
+  _NULLABLE_TYPE_BASE_ = Single;
+{$INCLUDE 't_NullableNumber.tpl'}
+
+type
+  TNullableSingle = _NULLABLE_NUMBER_;
+
+implementation
+
+{$INCLUDE 't_NullableNumber.tpl'}
+
+end.
+

Added: utilities/dzLib/trunk/src/u_dzNullableTypesUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzNullableTypesUtils.pas	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/src/u_dzNullableTypesUtils.pas	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,203 @@
+unit u_dzNullableTypesUtils;
+
+interface
+
+uses
+  SysUtils;
+
+type
+  EInvalidValue = class(Exception);
+
+procedure StrToNumber(const _s: string; out _Value: integer); overload;
+procedure StrToNumber(const _s: string; out _Value: single); overload;
+procedure StrToNumber(const _s: string; out _Value: double); overload;
+procedure StrToNumber(const _s: string; out _Value: extended); overload;
+
+function TryStrToNumber(const _s: string; out _Value: integer): boolean; overload;
+function TryStrToNumber(const _s: string; out _Value: Int64): boolean; overload;
+function TryStrToNumber(const _s: string; out _Value: single): boolean; overload;
+function TryStrToNumber(const _s: string; out _Value: double): boolean; overload;
+function TryStrToNumber(const _s: string; out _Value: extended): boolean; overload;
+
+function NumberToStr(_Value: integer): string; overload;
+function NumberToStr(_Value: single): string; overload;
+function NumberToStr(_Value: double): string; overload;
+function NumberToStr(_Value: extended): string; overload;
+
+function TryVar2Number(const _v: variant; out _Value: integer): boolean; overload;
+function TryVar2Number(const _v: variant; out _Value: Int64): boolean; overload;
+function TryVar2Number(const _v: variant; out _Value: single): boolean; overload;
+function TryVar2Number(const _v: variant; out _Value: double): boolean; overload;
+function TryVar2Number(const _v: variant; out _Value: extended): boolean; overload;
+
+function GetNullableTypesFlagInterface: IInterface;
+
+procedure DivideNumbers(_a, _b: Integer; out _Value: Integer); overload;
+procedure DivideNumbers(_a, _b: Int64; out _Value: Int64); overload;
+procedure DivideNumbers(_a, _b: Single; out _Value: Single); overload;
+procedure DivideNumbers(_a, _b: Double; out _Value: Double); overload;
+procedure DivideNumbers(_a, _b: Extended; out _Value: Extended); overload;
+
+implementation
+
+uses
+  u_dzVariantUtils;
+
+// this is a fake interfaced object that only exists as the VMT
+// It can still be used to trick the compiler into believing an interface pointer is assigned
+
+function NopAddref(inst: Pointer): Integer; stdcall;
+begin
+  Result := -1;
+end;
+
+function NopRelease(inst: Pointer): Integer; stdcall;
+begin
+  Result := -1;
+end;
+
+function NopQueryInterface(inst: Pointer; const IID: TGUID; out Obj): HResult; stdcall;
+begin
+  Result := E_NOINTERFACE;
+end;
+
+const
+  FlagInterfaceVTable: array[0..2] of Pointer =
+    (
+    @NopQueryInterface,
+    @NopAddref,
+    @NopRelease
+    );
+const
+  FlagInterfaceInstance: Pointer = @FlagInterfaceVTable;
+
+function GetNullableTypesFlagInterface: IInterface;
+begin
+  Result := IInterface(@FlagInterfaceInstance);
+end;
+
+// StrToNumber
+
+procedure StrToNumber(const _s: string; out _Value: integer);
+begin
+  _Value := StrToInt(_s);
+end;
+
+procedure StrToNumber(const _s: string; out _Value: single);
+begin
+  _Value := StrToFloat(_s);
+end;
+
+procedure StrToNumber(const _s: string; out _Value: double);
+begin
+  _Value := StrToFloat(_s);
+end;
+
+procedure StrToNumber(const _s: string; out _Value: extended);
+begin
+  _Value := StrToFloat(_s);
+end;
+
+// TryStrToNumber
+
+function TryStrToNumber(const _s: string; out _Value: integer): boolean;
+begin
+  Result := TryStrToInt(_s, _Value);
+end;
+
+function TryStrToNumber(const _s: string; out _Value: Int64): boolean;
+begin
+  Result := TryStrToInt64(_s, _Value);
+end;
+
+function TryStrToNumber(const _s: string; out _Value: single): boolean;
+begin
+  Result := TryStrToFloat(_s, _Value);
+end;
+
+function TryStrToNumber(const _s: string; out _Value: double): boolean;
+begin
+  Result := TryStrToFloat(_s, _Value);
+end;
+
+function TryStrToNumber(const _s: string; out _Value: extended): boolean;
+begin
+  Result := TryStrToFloat(_s, _Value);
+end;
+
+// NumberToStr
+
+function NumberToStr(_Value: integer): string;
+begin
+  Result := IntToStr(_Value);
+end;
+
+function NumberToStr(_Value: single): string;
+begin
+  Result := FloatToStr(_Value);
+end;
+
+function NumberToStr(_Value: double): string;
+begin
+  Result := FloatToStr(_Value);
+end;
+
+function NumberToStr(_Value: extended): string;
+begin
+  Result := FloatToStr(_Value);
+end;
+
+// TryVar2Number
+
+function TryVar2Number(const _v: variant; out _Value: integer): boolean;
+begin
+  Result := TryVar2Int(_v, _Value);
+end;
+
+function TryVar2Number(const _v: variant; out _Value: Int64): boolean;
+begin
+  Result := TryVar2Int64(_v, _Value);
+end;
+
+function TryVar2Number(const _v: variant; out _Value: single): boolean;
+begin
+  Result := TryVar2Single(_v, _Value);
+end;
+
+function TryVar2Number(const _v: variant; out _Value: double): boolean;
+begin
+  Result := TryVar2Dbl(_v, _Value);
+end;
+
+function TryVar2Number(const _v: variant; out _Value: extended): boolean;
+begin
+  Result := TryVar2Ext(_v, _Value);
+end;
+
+procedure DivideNumbers(_a, _b: Integer; out _Value: Integer);
+begin
+  _Value := _a div _b;
+end;
+
+procedure DivideNumbers(_a, _b: Int64; out _Value: Int64);
+begin
+  _Value := _a div _b;
+end;
+
+procedure DivideNumbers(_a, _b: Single; out _Value: Single);
+begin
+  _Value := _a / _b;
+end;
+
+procedure DivideNumbers(_a, _b: Double; out _Value: Double);
+begin
+  _Value := _a / _b;
+end;
+
+procedure DivideNumbers(_a, _b: Extended; out _Value: Extended);
+begin
+  _Value := _a / _b;
+end;
+
+end.
+

Added: utilities/dzLib/trunk/templates/t_NullableNumber.tpl
===================================================================
--- utilities/dzLib/trunk/templates/t_NullableNumber.tpl	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/templates/t_NullableNumber.tpl	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,337 @@
+{$IFNDEF __DZ_NULLABLE_NUMBER_TEMPLATE__}
+unit t_NullableNumber;
+
+interface
+
+uses
+  SysUtils,
+  Variants,
+  u_dzNullableTypesUtils;
+
+/// These types must be declared for each class built on this template
+type
+  // can be integer, int64, single, double, extended and possibly some other
+  // numerical types (e.g. currency) which I have not(!) tested.
+  _NULLABLE_TYPE_BASE_ = int64;
+
+{$ENDIF __DZ_NULLABLE_NUMBER_TEMPLATE__}
+
+{$IFNDEF __DZ_NULLABLE_NUMBER_TEMPLATE_SECOND_PASS__}
+
+type
+  _NULLABLE_NUMBER_ = record
+  private
+    FIsValid: IInterface;
+    FValue: _NULLABLE_TYPE_BASE_;
+  public
+    procedure Invalidate;
+    function Value: _NULLABLE_TYPE_BASE_;
+    function IsValid: boolean; inline;
+    function GetValue(out _Value: _NULLABLE_TYPE_BASE_): boolean;
+    procedure AssignVariant(_a: Variant);
+    function ToVariant: Variant;
+    function Dump: string;
+    class operator Negative(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Positive(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Inc(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Dec(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Add(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Add(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+    class operator Add(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Subtract(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Subtract(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+    class operator Subtract(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Multiply(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Multiply(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+    class operator Multiply(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Divide(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Divide(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+    class operator Divide(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+    class operator Implicit(_Value: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+    class operator Implicit(_a: _NULLABLE_NUMBER_): _NULLABLE_TYPE_BASE_;
+    class operator Explicit(const _s: string): _NULLABLE_NUMBER_;
+    class operator Explicit(_a: _NULLABLE_NUMBER_): string;
+    class operator LessThan(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+    class operator LessThanOrEqual(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+    class operator GreaterThan(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+    class operator GreaterThanOrEqual(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+    class operator Equal(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+    class operator NotEqual(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+
+    /// <summary> invalid values are considered smaller than any valid values
+    /// and equal to each other </summary>
+    class function Compare(_a, _b: _NULLABLE_NUMBER_): integer; static;
+    class function Invalid: _NULLABLE_NUMBER_; static;
+    class function FromVariant(_a: Variant): _NULLABLE_NUMBER_; static;
+  end;
+
+{$ENDIF __DZ_NULLABLE_NUMBER_TEMPLATE_SECOND_PASS__}
+
+{$IFNDEF __DZ_NULLABLE_NUMBER_TEMPLATE__}
+{$DEFINE __DZ_NULLABLE_NUMBER_TEMPLATE_SECOND_PASS__}
+
+implementation
+
+uses
+  Math,
+  u_dzTranslator,
+  u_dzVariantUtils;
+
+{$ENDIF __DZ_NULLABLE_NUMBER_TEMPLATE__}
+
+{$IFDEF __DZ_NULLABLE_NUMBER_TEMPLATE_SECOND_PASS__}
+
+{ _NULLABLE_NUMBER_ }
+
+class operator _NULLABLE_NUMBER_.Negative(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  Result := -_a.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Positive(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  Result := _a.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Inc(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  Result := _a.Value + 1;
+end;
+
+class operator _NULLABLE_NUMBER_.Dec(_a: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  Result := _a.Value - 1;
+end;
+
+class operator _NULLABLE_NUMBER_.Add(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  if not _a.IsValid or not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot add two nullable values if one of them is not valid'));
+  Result := _a.Value + _b.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Add(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+begin
+  if not _a.IsValid then
+    raise EInvalidValue.Create(_('Cannot add to a nullable value if it is not valid'));
+  Result := _a.Value + _b;
+end;
+
+class operator _NULLABLE_NUMBER_.Add(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  if not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot add to a nullable value if it is not valid'));
+  Result := _a + _b.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Subtract(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  if not _a.IsValid or not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot subtract two nullable values if one of them is not valid'));
+  Result := _a.Value - _b.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Subtract(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+begin
+  if not _a.IsValid then
+    raise EInvalidValue.Create(_('Cannot subtract from a nullable value if it is not valid'));
+  Result := _a.Value - _b;
+end;
+
+class operator _NULLABLE_NUMBER_.Subtract(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  if not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot subtract from a value if it is not valid'));
+  Result := _a - _b.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Multiply(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  if not _a.IsValid or not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot multiply two nullable values if one of them is not valid'));
+  Result := _a.Value * _b.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Multiply(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+begin
+  if not _a.IsValid then
+    raise EInvalidValue.Create(_('Cannot multiply a nullable value if it is not valid'));
+  Result := _a.Value * _b;
+end;
+
+class operator _NULLABLE_NUMBER_.Multiply(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+begin
+  if not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot multiply a nullable value if it is not valid'));
+  Result := _a * _b.Value;
+end;
+
+class operator _NULLABLE_NUMBER_.Divide(_a, _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+var
+  Res: _NULLABLE_TYPE_BASE_;
+begin
+  if not _a.IsValid or not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot divide two nullable values if one of them is not valid'));
+  DivideNumbers(_a.Value, _b.Value, Res);
+  Result := Res;
+end;
+
+class operator _NULLABLE_NUMBER_.Divide(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+var
+  Res: _NULLABLE_TYPE_BASE_;
+begin
+  if not _a.IsValid then
+    raise EInvalidValue.Create(_('Cannot divide a nullable value if it is not valid'));
+  DivideNumbers(_a.Value, _b, Res);
+  Result := Res;
+end;
+
+class operator _NULLABLE_NUMBER_.Divide(_a: _NULLABLE_TYPE_BASE_; _b: _NULLABLE_NUMBER_): _NULLABLE_NUMBER_;
+var
+  Res: _NULLABLE_TYPE_BASE_;
+begin
+  if not _b.IsValid then
+    raise EInvalidValue.Create(_('Cannot divide by a nullable value if it is not valid'));
+  DivideNumbers(_a, _b, Res);
+  Result := Res;
+end;
+
+class operator _NULLABLE_NUMBER_.Explicit(const _s: string): _NULLABLE_NUMBER_;
+begin
+  if TryStrToNumber(_s, Result.FValue) then
+    Result.FIsValid := GetNullableTypesFlagInterface
+  else
+    Result.FIsValid := nil;
+end;
+
+class operator _NULLABLE_NUMBER_.Explicit(_a: _NULLABLE_NUMBER_): string;
+begin
+  if _a.IsValid then
+    Result := NumberToStr(_a.Value)
+  else
+    Result := '';
+end;
+
+class function _NULLABLE_NUMBER_.FromVariant(_a: Variant): _NULLABLE_NUMBER_;
+begin
+  Result.AssignVariant(_a);
+end;
+
+class operator _NULLABLE_NUMBER_.Implicit(_Value: _NULLABLE_TYPE_BASE_): _NULLABLE_NUMBER_;
+begin
+  Result.FValue := _Value;
+  Result.FIsValid := GetNullableTypesFlagInterface;
+end;
+
+class operator _NULLABLE_NUMBER_.Implicit(_a: _NULLABLE_NUMBER_): _NULLABLE_TYPE_BASE_;
+begin
+  Result := _a.Value;
+end;
+
+procedure _NULLABLE_NUMBER_.AssignVariant(_a: Variant);
+begin
+  if TryVar2Number(_a, FValue) then
+    FIsValid := GetNullableTypesFlagInterface
+  else
+    FIsValid := nil;
+end;
+
+class function _NULLABLE_NUMBER_.Compare(_a, _b: _NULLABLE_NUMBER_): integer;
+begin
+  if _a.IsValid then begin
+    if _b.IsValid then
+      Result := Math.CompareValue(_a.Value, _b.Value)
+    else
+      Result := 1;
+  end else if not _b.IsValid then
+    Result := 0
+  else
+    Result := -1;
+end;
+
+function _NULLABLE_NUMBER_.Dump: string;
+begin
+  if IsValid then
+    Result := NumberToStr(FValue)
+  else
+    Result := '<invalid>';
+end;
+
+function _NULLABLE_NUMBER_.ToVariant: Variant;
+begin
+  if IsValid then
+    Result := Value
+  else
+    Result := Variants.Null;
+end;
+
+function _NULLABLE_NUMBER_.GetValue(out _Value: _NULLABLE_TYPE_BASE_): boolean;
+begin
+  Result := IsValid;
+  if Result then
+    _Value := FValue;
+end;
+
+procedure _NULLABLE_NUMBER_.Invalidate;
+begin
+  FIsValid := nil;
+end;
+
+function _NULLABLE_NUMBER_.IsValid: boolean;
+begin
+  Result := FIsValid <> nil;
+end;
+
+class operator _NULLABLE_NUMBER_.LessThan(_a: _NULLABLE_NUMBER_;
+  _b: _NULLABLE_TYPE_BASE_): boolean;
+begin
+  Result := _a.Value < _b;
+end;
+
+class operator _NULLABLE_NUMBER_.LessThanOrEqual(_a: _NULLABLE_NUMBER_;
+  _b: _NULLABLE_TYPE_BASE_): boolean;
+begin
+  Result := _a.Value <= _b;
+end;
+
+class operator _NULLABLE_NUMBER_.GreaterThan(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+begin
+  Result := _a.Value > _b;
+end;
+
+class operator _NULLABLE_NUMBER_.GreaterThanOrEqual(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+begin
+  Result := _a.Value >= _b;
+end;
+
+class operator _NULLABLE_NUMBER_.Equal(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+begin
+  Result := _a.Value = _b;
+end;
+
+class operator _NULLABLE_NUMBER_.NotEqual(_a: _NULLABLE_NUMBER_; _b: _NULLABLE_TYPE_BASE_): boolean;
+begin
+  Result := _a.Value <> _b;
+end;
+
+class function _NULLABLE_NUMBER_.Invalid: _NULLABLE_NUMBER_;
+begin
+  Result.Invalidate;
+end;
+
+function _NULLABLE_NUMBER_.Value: _NULLABLE_TYPE_BASE_;
+begin
+  if not IsValid then
+    raise EInvalidValue.Create(_('NullableInteger value is invalid'));
+  Result := FValue;
+end;
+
+{$ENDIF __DZ_NULLABLE_NUMBER_TEMPLATE_SECOND_PASS__}
+
+{$DEFINE __DZ_NULLABLE_NUMBER_TEMPLATE_SECOND_PASS__}
+
+{$IFNDEF __DZ_NULLABLE_NUMBER_TEMPLATE__}
+{$WARNINGS OFF}
+end.
+{$ENDIF __DZ_NULLABLE_NUMBER_TEMPLATE__}
+


Property changes on: utilities/dzLib/trunk/tests/NullableTypesTest
___________________________________________________________________
Name: svn:ignore
   + dunit.ini
NullableTypesTest.exe



Property changes on: utilities/dzLib/trunk/tests/NullableTypesTest/dcu
___________________________________________________________________
Name: svn:ignore
   + *.dcu


Added: utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dpr
===================================================================
--- utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dpr	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dpr	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,39 @@
+program NullableTypesTest;
+{
+
+  Delphi DUnit Test Project
+  -------------------------
+  This project contains the DUnit test framework and the GUI/Console test runners.
+  Add "CONSOLE_TESTRUNNER" to the conditional defines entry in the project options 
+  to use the console test runner.  Otherwise the GUI test runner will be used by 
+  default.
+
+}
+
+{$IFDEF CONSOLE_TESTRUNNER}
+{$APPTYPE CONSOLE}
+{$ENDIF}
+
+uses
+  Forms,
+  TestFramework,
+  GUITestRunner,
+  TextTestRunner,
+  u_NullableTypesTest in 'u_NullableTypesTest.pas',
+  u_dzNullableTypesUtils in '..\..\..\src\u_dzNullableTypesUtils.pas',
+  u_dzNullableDouble in '..\..\..\src\u_dzNullableDouble.pas',
+  u_dzNullableInteger in '..\..\..\src\u_dzNullableInteger.pas',
+  u_dzNullableInt64 in '..\..\..\src\u_dzNullableInt64.pas',
+  u_dzNullableSingle in '..\..\..\src\u_dzNullableSingle.pas',
+  u_dzNullableExtended in '..\..\..\src\u_dzNullableExtended.pas';
+
+{$R *.RES}
+
+begin
+  Application.Initialize;
+  if IsConsole then
+    TextTestRunner.RunRegisteredTests
+  else
+    GUITestRunner.RunRegisteredTests;
+end.
+

Added: utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dproj
===================================================================
--- utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dproj	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/tests/NullableTypesTest/src/NullableTypesTest.dproj	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,130 @@
+?	<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+		<PropertyGroup>
+			<ProjectGuid>{9ce4adcd-780a-4577-b737-abbae0949aa4}</ProjectGuid>
+			<MainSource>NullableTypesTest.dpr</MainSource>
+			<Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+			<Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+			<DCC_DCCCompiler>DCC32</DCC_DCCCompiler>
+			<DCC_DependencyCheckOutputName>..\NullableTypesTest.exe</DCC_DependencyCheckOutputName>
+			<ProjectVersion>12.0</ProjectVersion>
+			<Config Condition="'$(Config)'==''">Debug</Config>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
+			<Base>true</Base>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_1)'!=''">
+			<Cfg_1>true</Cfg_1>
+			<CfgParent>Base</CfgParent>
+			<Base>true</Base>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_2)'!=''">
+			<Cfg_2>true</Cfg_2>
+			<CfgParent>Base</CfgParent>
+			<Base>true</Base>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Base)'!=''">
+			<DCC_UnitSearchPath>..\..\..\templates;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
+			<DCC_ExeOutput>..</DCC_ExeOutput>
+			<DCC_DependencyCheckOutputName>..\NullableTypesTest.exe</DCC_DependencyCheckOutputName>
+			<DCC_DcuOutput>..\dcu</DCC_DcuOutput>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Cfg_1)'!=''">
+			<Version>7.0</Version>
+			<DCC_DebugInformation>False</DCC_DebugInformation>
+			<DCC_LocalDebugSymbols>False</DCC_LocalDebugSymbols>
+			<DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
+			<DCC_Define>RELEASE;$(DCC_Define)</DCC_Define>
+		</PropertyGroup>
+		<PropertyGroup Condition="'$(Cfg_2)'!=''">
+			<Version>7.0</Version>
+			<DCC_Define>DEBUG;_CONSOLE_TESTRUNNER;no_translation;$(DCC_Define)</DCC_Define>
+			<DCC_UnitSearchPath>$(BDS)\Source\DUnit\src;..\..\..\src\common;..\..\..\..\dzlib\src;..\..\..\..\dzlib\jedi_inc;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
+			<DCC_ResourcePath>$(BDS)\Source\DUnit\src;..\..\..\src\common;..\..\..\..\dzlib\src;..\..\..\..\dzlib\jedi_inc;$(DCC_ResourcePath)</DCC_ResourcePath>
+			<DCC_ObjPath>$(BDS)\Source\DUnit\src;..\..\..\src\common;..\..\..\..\dzlib\src;..\..\..\..\dzlib\jedi_inc;$(DCC_ObjPath)</DCC_ObjPath>
+			<DCC_IncludePath>$(BDS)\Source\DUnit\src;..\..\..\src\common;..\..\..\..\dzlib\src;..\..\..\..\dzlib\jedi_inc;$(DCC_IncludePath)</DCC_IncludePath>
+			<DCC_ExeOutput>..</DCC_ExeOutput>
+			<DCC_DcuOutput>..\dcu</DCC_DcuOutput>
+			<DCC_ObjOutput>..\dcu</DCC_ObjOutput>
+			<DCC_HppOutput>..\dcu</DCC_HppOutput>
+		</PropertyGroup>
+		<ProjectExtensions>
+			<Borland.Personality>Delphi.Personality.12</Borland.Personality>
+			<Borland.ProjectType/>
+			<BorlandProject>
+				<Delphi.Personality>
+					<Parameters>
+						<Parameters Name="UseLauncher">False</Parameters>
+						<Parameters Name="LoadAllSymbols">True</Parameters>
+						<Parameters Name="LoadUnspecifiedSymbols">False</Parameters>
+					</Parameters>
+					<VersionInfo>
+						<VersionInfo Name="IncludeVerInfo">False</VersionInfo>
+						<VersionInfo Name="AutoIncBuild">False</VersionInfo>
+						<VersionInfo Name="MajorVer">1</VersionInfo>
+						<VersionInfo Name="MinorVer">0</VersionInfo>
+						<VersionInfo Name="Release">0</VersionInfo>
+						<VersionInfo Name="Build">0</VersionInfo>
+						<VersionInfo Name="Debug">False</VersionInfo>
+						<VersionInfo Name="PreRelease">False</VersionInfo>
+						<VersionInfo Name="Special">False</VersionInfo>
+						<VersionInfo Name="Private">False</VersionInfo>
+						<VersionInfo Name="DLL">False</VersionInfo>
+						<VersionInfo Name="Locale">1031</VersionInfo>
+						<VersionInfo Name="CodePage">1252</VersionInfo>
+					</VersionInfo>
+					<VersionInfoKeys>
+						<VersionInfoKeys Name="CompanyName"/>
+						<VersionInfoKeys Name="FileDescription"/>
+						<VersionInfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys>
+						<VersionInfoKeys Name="InternalName"/>
+						<VersionInfoKeys Name="LegalCopyright"/>
+						<VersionInfoKeys Name="LegalTrademarks"/>
+						<VersionInfoKeys Name="OriginalFilename"/>
+						<VersionInfoKeys Name="ProductName"/>
+						<VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys>
+						<VersionInfoKeys Name="Comments"/>
+					</VersionInfoKeys>
+					<Excluded_Packages>
+						<Excluded_Packages Name="$(BDS)\bin\dcloffice2k100.bpl">Microsoft Office 2000 Sample Automation Server Wrapper Components</Excluded_Packages>
+						<Excluded_Packages Name="$(BDS)\bin\dclofficexp100.bpl">Microsoft Office XP Sample Automation Server Wrapper Components</Excluded_Packages>
+						<Excluded_Packages Name="$(BDS)\bin\dcltee7100.bpl">TeeChart Components</Excluded_Packages>
+						<Excluded_Packages Name="D:\twm\source\ArgusVideo-ADAC\libs\mydac\bin\mydac100.bpl">MySQL Data Access Components</Excluded_Packages>
+						<Excluded_Packages Name="D:\twm\source\ArgusVideo-ADAC\libs\mydac\bin\dac100.bpl">Core Lab Data Access Components</Excluded_Packages>
+					</Excluded_Packages>
+					<Source>
+						<Source Name="MainSource">NullableTypesTest.dpr</Source>
+					</Source>
+				</Delphi.Personality>
+				<UnitTesting>
+					<TestFramework>DUnit / Delphi Win32</TestFramework>
+					<TestRunner>GUI</TestRunner>
+				</UnitTesting>
+			</BorlandProject>
+			<ProjectFileVersion>12</ProjectFileVersion>
+		</ProjectExtensions>
+		<ItemGroup>
+			<DelphiCompile Include="NullableTypesTest.dpr">
+				<MainSource>MainSource</MainSource>
+			</DelphiCompile>
+			<DCCReference Include="u_NullableTypesTest.pas"/>
+			<DCCReference Include="..\..\..\src\u_dzNullableTypesUtils.pas"/>
+			<DCCReference Include="..\..\..\src\u_dzNullableDouble.pas"/>
+			<DCCReference Include="..\..\..\src\u_dzNullableInteger.pas"/>
+			<DCCReference Include="..\..\..\src\u_dzNullableInt64.pas"/>
+			<DCCReference Include="..\..\..\src\u_dzNullableSingle.pas"/>
+			<DCCReference Include="..\..\..\src\u_dzNullableExtended.pas"/>
+			<None Include="..\..\..\templates\t_NullableNumber.tpl"/>
+			<BuildConfiguration Include="Base">
+				<Key>Base</Key>
+			</BuildConfiguration>
+			<BuildConfiguration Include="Debug">
+				<Key>Cfg_2</Key>
+				<CfgParent>Base</CfgParent>
+			</BuildConfiguration>
+			<BuildConfiguration Include="Release">
+				<Key>Cfg_1</Key>
+				<CfgParent>Base</CfgParent>
+			</BuildConfiguration>
+		</ItemGroup>
+		<Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Delphi.Targets')"/>
+	</Project>

Added: utilities/dzLib/trunk/tests/NullableTypesTest/src/u_NullableTypesTest.pas
===================================================================
--- utilities/dzLib/trunk/tests/NullableTypesTest/src/u_NullableTypesTest.pas	2009-09-25 18:43:19 UTC (rev 369)
+++ utilities/dzLib/trunk/tests/NullableTypesTest/src/u_NullableTypesTest.pas	2009-09-25 18:45:27 UTC (rev 370)
@@ -0,0 +1,395 @@
+unit u_NullableTypesTest;
+
+interface
+
+uses
+  TestFramework,
+  u_dzUnitTestUtils,
+  u_dzNullableInteger,
+  u_dzNullableInt64,
+  u_dzNullableSingle,
+  u_dzNullableDouble,
+  u_dzNullableExtended;
+
+type
+  TestTNullableTypes = class(TdzTestCase)
+  public
+  published
+    procedure TestNullableInteger;
+    procedure TestNullableInt64;
+    procedure TestNullableSingle;
+    procedure TestNullableExtended;
+  end;
+
+  TestNullableDouble = class(TdzTestCase)
+  private
+    One: TNullableDouble;
+    Two: TNullableDouble;
+    Res: TNullableDouble;
+  public
+    procedure SetUp; override;
+    procedure TearDown; override;
+  published
+    procedure TestAssign;
+    procedure TestAdd;
+    procedure TestSubtract;
+    procedure TestMultiply;
+    procedure TestDivide;
+    procedure TestIncDec;
+  end;
+
+implementation
+
+uses
+  SysUtils;
+
+{ TestTNullableTypes }
+
+//procedure TestTNullableTypes.TestNullableDate;
+//var
+//  dt: TDateTime;
+//  One, Two: TNullableDate;
+//begin
+//  dt := Date;
+//  CheckFalse(One.IsValid, 'Variable One should be invalid');
+//  One := dt;
+//  CheckTrue(One.IsValid, 'Variable One should be valid');
+//  CheckEqualsDate(dt, One);
+//  CheckFalse(Two.IsValid, 'Variable two should be invalid');
+//  Two := One;
+//  CheckTrue(Two.IsValid, 'Variable two should be valid');
+//  CheckEqualsDate(dt, Two);
+//end;
+
+procedure TestTNullableTypes.TestNullableInteger;
+var
+  One, Two: TNullableInteger;
+begin
+  CheckFalse(One.IsValid, 'Variable One should be invalid');
+  One := 1;
+  CheckTrue(One.IsValid, 'Variable One should be valid');
+  CheckEquals(1, One);
+  CheckFalse(Two.IsValid, 'Variable two should be invalid');
+  Two := One;
+  CheckTrue(Two.IsValid, 'Variable two should be valid');
+  CheckEquals(1, Two);
+  Two := One + 1;
+  CheckTrue(Two.IsValid, 'Variable two should be valid');
+  CheckEquals(2, Two);
+  Two.Invalidate;
+  CheckFalse(Two.IsValid, 'Variable two should be invalid again');
+end;
+
+procedure TestTNullableTypes.TestNullableInt64;
+var
+  One, Two: TNullableInt64;
+begin
+  CheckFalse(One.IsValid, 'Variable One should be invalid');
+  One := 1;
+  CheckTrue(One.IsValid, 'Variable One should be valid');
+  CheckEquals(1, One);
+  CheckFalse(Two.IsValid, 'Variable two should be invalid');
+  Two := One;
+  CheckTrue(Two.IsValid, 'Variable two should be valid');
+  CheckEquals(1, Two);
+  Two := One + 1;
+  CheckTrue(Two.IsValid, 'Variable two should be valid');
+  CheckEquals(2, Two);
+  Two.Invalidate;
+  CheckFalse(Two.IsValid, 'Variable two should be invalid again');
+end;
+
+procedure TestTNullableTypes.TestNullableSingle;
+var
+  s: single;
+  One: TNullableSingle;
+  Two: TNullableSingle;
+  Res: TNullableSingle;
+begin
+  CheckFalse(One.IsValid, 'Variable One should be invalid');
+
+  One := 1;
+  CheckTrue(One.IsValid, 'Variable One should be valid');
+  CheckEquals(1, One);
+
+  CheckFalse(Two.IsValid, 'Variable Two should be invalid');
+  Two := 2;
+  CheckTrue(Two.IsValid, 'Variable Two should be valid');
+  CheckEquals(2, Two);
+
+  Res := One;
+  CheckTrue(Res.IsValid, 'Variable Res should be valid');
+  CheckEquals(1, Res);
+
+  Res := One + 1;
+  CheckEquals(2, Res);
+
+  Res := 1 + One;
+  CheckEquals(2, Res);
+
+  Res := One - 1;
+  CheckEquals(0, Res);
+
+  Res := 1 - One;
+  CheckEquals(0, Res);
+
+  Res := One + Two;
+  CheckEquals(3, Res);
+
+  Res := Two - One;
+  CheckEquals(1, Res);
+
+  Res := One * 2;
+  CheckEquals(2, Res);
+
+  Res := 2 * One;
+  CheckEquals(2, Res);
+
+  Res := Two * One;
+  CheckEquals(2, Res);
+
+  Res := -One;
+  CheckEquals(-1, Res);
+
+  Res := +Two;
+  CheckEquals(2, Res);
+
+  Res := Two;
+  Inc(Res);
+  CheckEquals(3, Res);
+
+  Res := Two;
+  Inc(Res, 2);
+  CheckEquals(4, Res);
+
+  Res := Two;
+  Dec(Res);
+  CheckEquals(1, Res);
+
+  Res := Two;
+  Dec(Res, 2);
+  CheckEquals(0, Res);
+
+  Res := 1.1;
+  Inc(Res);
+  s := 1.1 + 1;
+  CheckEquals(s, Res);
+
+  Res := 1.1;
+  Dec(Res);
+  s := 1.1 - 1;
+  CheckEquals(s, Res);
+
+  Res.Invalidate;
+  CheckFalse(Res.IsValid, 'Variable Res should be invalid again');
+end;
+
+procedure TestTNullableTypes.TestNullableExtended;
+var
+  One: TNullableExtended;
+  Two: TNullableExtended;
+  Res: TNullableExtended;
+begin
+  CheckFalse(One.IsValid, 'Variable One should be invalid');
+
+  One := 1;
+  CheckTrue(One.IsValid, 'Variable One should be valid');
+  CheckEquals(1, One);
+
+  CheckFalse(Two.IsValid, 'Variable Two should be invalid');
+  Two := 2;
+  CheckTrue(Two.IsValid, 'Variable Two should be valid');
+  CheckEquals(2, Two);
+
+  Res := One;
+  CheckTrue(Res.IsValid, 'Variable Res should be valid');
+  CheckEquals(1, Res);
+
+  Res := One + 1;
+  CheckEquals(2, Res);
+
+  Res := 1 + One;
+  CheckEquals(2, Res);
+
+  Res := One - 1;
+  CheckEquals(0, Res);
+
+  Res := 1 - One;
+  CheckEquals(0, Res);
+
+  Res := One + Two;
+  CheckEquals(3, Res);
+
+  Res := Two - One;
+  CheckEquals(1, Res);
+
+  Res := One * 2;
+  CheckEquals(2, Res);
+
+  Res := 2 * One;
+  CheckEquals(2, Res);
+
+  Res := Two * One;
+  CheckEquals(2, Res);
+
+  Res := -One;
+  CheckEquals(-1, Res);
+
+  Res := +Two;
+  CheckEquals(2, Res);
+
+  Res := Two;
+  Inc(Res);
+  CheckEquals(3, Res);
+
+  Res := Two;
+  Inc(Res, 2);
+  CheckEquals(4, Res);
+
+  Res := Two;
+  Dec(Res);
+  CheckEquals(1, Res);
+
+  Res := Two;
+  Dec(Res, 2);
+  CheckEquals(0, Res);
+
+  Res := 1.1;
+  Inc(Res);
+  CheckEquals(2.1, Res);
+
+  Res := 1.1;
+  Dec(Res);
+  CheckEquals(0.1, Res);
+
+  Res.Invalidate;
+  CheckFalse(Res.IsValid, 'Variable Res should be invalid again');
+end;
+
+{ TestNullableDouble }
+
+procedure TestNullableDouble.Setup;
+begin
+  inherited;
+  One := 1;
+  Two := 2;
+  Res.Invalidate;
+end;
+
+procedure TestNullableDouble.TearDown;
+begin
+  inherited;
+  One.Invalidate;
+  Two.Invalidate;
+  Res.Invalidate;
+end;
+
+procedure TestNullableDouble.TestAssign;
+begin
+  CheckTrue(One.IsValid, 'Variable One should be valid');
+  CheckEquals(1, One);
+
+  CheckTrue(Two.IsValid, 'Variable Two should be valid');
+  CheckEquals(2, Two);
+
+  CheckFalse(Res.IsValid, 'Variable One should be invalid');
+
+  Res := One;
+  CheckTrue(Res.IsValid, 'Variable Res should be valid');
+  CheckEquals(1, Res);
+
+  Res := Two;
+  CheckTrue(Res.IsValid, 'Variable Res should be valid');
+  CheckEquals(2, Res);
+
+  Res := -One;
+  CheckEquals(-1, Res);
+
+  Res := +Two;
+  CheckEquals(2, Res);
+
+  Res.Invalidate;
+  CheckFalse(Res.IsValid, 'Variable One should be invalid again');
+end;
+
+procedure TestNullableDouble.TestAdd;
+begin
+  Res := One + 1;
+  CheckEquals(2, Res);
+
+  Res := 1 + One;
+  CheckEquals(2, Res);
+
+  Res := One + Two;
+  CheckEquals(3, Res);
+end;
+
+procedure TestNullableDouble.TestSubtract;
+begin
+  Res := One - 1;
+  CheckEquals(0, Res);
+
+  Res := 1 - One;
+  CheckEquals(0, Res);
+
+  Res := Two - One;
+  CheckEquals(1, Res);
+end;
+
+procedure TestNullableDouble.TestMultiply;
+begin
+  Res := One * 2;
+  CheckEquals(2, Res);
+
+  Res := 2 * One;
+  CheckEquals(2, Res);
+
+  Res := Two * One;
+  CheckEquals(2, Res);
+
+end;
+
+procedure TestNullableDouble.TestDivide;
+begin
+  Res := Two / 1;
+  CheckEquals(2, Res);
+
+  Res := One / 2;
+  CheckEquals(0.5, Res);
+
+  Res := One / Two;
+  CheckEquals(0.5, Res);
+end;
+
+procedure TestNullableDouble.TestIncDec;
+begin
+  Res := Two;
+  Inc(Res);
+  CheckEquals(3, Res);
+
+  Res := Two;
+  Inc(Res, 2);
+  CheckEquals(4, Res);
+
+  Res := Two;
+  Dec(Res);
+  CheckEquals(1, Res);
+
+  Res := Two;
+  Dec(Res, 2);
+  CheckEquals(0, Res);
+
+  Res := 1.1;
+  Inc(Res);
+  CheckEquals(2.1, Res);
+
+  Res := 1.1;
+  Dec(Res);
+  CheckEquals(0.1, Res);
+end;
+
+initialization
+  RegisterTest(TestTNullableTypes.Suite);
+  RegisterTest(TestNullableDouble.Suite);
+end.
+



