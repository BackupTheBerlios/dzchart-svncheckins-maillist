<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dzchart-svncheckins] r252 - utilities/dzLib/trunk/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dzchart-svncheckins/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:dzchart-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BDzchart-svncheckins%5D%20r252%20-%20utilities/dzLib/trunk/src&In-Reply-To=%3C200712161319.lBGDJLfl023954%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000120.html">
   <LINK REL="Next"  HREF="000122.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dzchart-svncheckins] r252 - utilities/dzLib/trunk/src</H1>
    <B>twm at mail.berlios.de</B> 
    <A HREF="mailto:dzchart-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BDzchart-svncheckins%5D%20r252%20-%20utilities/dzLib/trunk/src&In-Reply-To=%3C200712161319.lBGDJLfl023954%40sheep.berlios.de%3E"
       TITLE="[Dzchart-svncheckins] r252 - utilities/dzLib/trunk/src">twm at mail.berlios.de
       </A><BR>
    <I>Sun Dec 16 14:19:21 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000120.html">[Dzchart-svncheckins] r251 - utilities/dzLib/trunk/src
</A></li>
        <LI>Next message: <A HREF="000122.html">[Dzchart-svncheckins] r253 - in utilities/dzLib/trunk/tests: .	dzfileutils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#121">[ date ]</a>
              <a href="thread.html#121">[ thread ]</a>
              <a href="subject.html#121">[ subject ]</a>
              <a href="author.html#121">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: twm
Date: 2007-12-16 14:19:18 +0100 (Sun, 16 Dec 2007)
New Revision: 252

Modified:
   utilities/dzLib/trunk/src/u_dzFileUtils.pas
Log:
converted PasDoc comments to HelpInsight comments

Modified: utilities/dzLib/trunk/src/u_dzFileUtils.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-16 11:15:18 UTC (rev 251)
+++ utilities/dzLib/trunk/src/u_dzFileUtils.pas	2007-12-16 13:19:18 UTC (rev 252)
@@ -1,5 +1,7 @@
 {GXFormatter.config=twm}
-{! implements utility functions for file accesss }
+/// &lt;summary&gt;
+/// implements utility functions for file accesss
+/// &lt;/summary&gt;
 unit u_dzFileUtils;
 
 {$I jedi.inc}
@@ -14,7 +16,9 @@
 type
   EFileUtils = class(Exception);
   ECreateUniqueDir = class(EFileUtils);
-  {! raised by DelTree if the DirName parameter is not a valid directory name }
+  /// &lt;summary&gt;
+  /// raised by DelTree if the DirName parameter is not a valid directory name
+  /// &lt;/summary&gt;
   EDirNotFound = class(EFileUtils);
   EPathTooLong = class(EFileUtils);
   EInvalidPropertyCombination = class(EFileUtils);
@@ -40,86 +44,117 @@
   end;
 
 type
-  {! a simple wrapper around FindFirst/FindNext which allows to search for
-     specified attributes only (e.g. only directories), it automatically
-     ignores the special '.' and '..' directories. }
+  /// &lt;summary&gt;
+  /// a simple wrapper around FindFirst/FindNext which allows to search for
+  /// specified attributes only (e.g. only directories), it automatically
+  /// ignores the special '.' and '..' directories.
+  /// &lt;/summary&gt;
   TSimpleDirEnumerator = class
   protected
-    {! stores the search mask ('c:\windows\*.exe') }
+    /// stores the search mask ('c:\windows\*.exe')
     FMask: string;
-    {! set of attributes a file must match }
+    /// set of attributes a file must match
     FMustHaveAttr: TFileAttributeSet;
-    {! set of attributes a file may have }
+    /// set of attributes a file may have
     FMayHaveAttr: TFileAttributeSet;
-    {! internally used TSearchRec structure }
+    /// internally used TSearchRec structure
     FSr: TSearchRec;
-    {! true if FindFirst was called and returned no error code }
+    /// true if FindFirst was called and returned no error code
     FActive: boolean;
-    {! number of matching files found }
+    /// number of matching files found
     FMatchCount: integer;
   public
-    {! creates a TSimpleDirEnumerator, sets the Mask, MustHaveAttr and MayHaveAttr
-       properties.
-       MustHaveAttr is set to [] and MayHaveAttr is set to include all possible
-       attributes, so calling FindNext will find any files or subdirectories,
-       but the special '.' and '..' directories
-       @param(Mask is the file search mask) }
+    /// &lt;summary&gt;
+    /// Creates a TSimpleDirEnumerator, sets the Mask, MustHaveAttr and MayHaveAttr
+    /// properties.
+    /// MustHaveAttr is set to [] and MayHaveAttr is set to include all possible
+    /// attributes, so calling FindNext will find any files or subdirectories,
+    /// but the special '.' and '..' directories
+    /// @param(Mask is the file search mask)
+    /// &lt;/summary&gt;
     constructor Create(const _Mask: string);
-    {! Destructor, will call FindClose if necessary }
+    /// &lt;summary&gt;
+    /// Destructor, will call FindClose if necessary
+    /// &lt;/summary&gt;
     destructor Destroy; override;
-    {! creates a TSimpleDirEnumerator, calls its FindAll method and frees it }
+    /// &lt;summary&gt;
+    /// creates a TSimpleDirEnumerator, calls its FindAll method and frees it
+    /// &lt;/summary&gt;
     class function Execute(const _Mask: string; _List: TStrings): integer;
-    {! Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
-       calls.
-       @param Filename is the name of the file found, if result is true, if you need
-              more information about it, use the SR property
-       @Returns true, if a matching file was found, false otherwise }
+    /// &lt;summary&gt;
+    /// Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
+    /// calls.
+    /// @param Filename is the name of the file found, if result is true, if you need
+    ///       more information about it, use the SR property
+    /// @Returns true, if a matching file was found, false otherwise
+    /// &lt;/summary&gt;
     function FindNext(out _Filename: string): boolean; overload;
-    {! Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
-       calls. If it returns true, use the SR property to get information about
-       the file. See the overloaded @link(FindNext) version if you need only
-       the filename.
-       @Returns(true, if a matching file was found, false otherwise) }
+    /// &lt;summary&gt;
+    /// Calls SysUtils.FindFirst on first call and SysUtls.FindNext in later
+    /// calls. If it returns true, use the SR property to get information about
+    /// the file. See the overloaded @link(FindNext) version if you need only
+    /// the filename.
+    /// @Returns(true, if a matching file was found, false otherwise)
+    /// &lt;/summary&gt;
     function FindNext: boolean; overload;
-    {! Calls FindNext until it returns false, stores all filenames in List and
-       returns the number of files found.
-       @param List is a TStrings object which will be filled with the filenames
-              of matching files, may be nil.
-       @returns the number of mathing files }
+    /// &lt;summary&gt;
+    /// Calls FindNext until it returns false, stores all filenames in List and
+    /// returns the number of files found.
+    /// @param List is a TStrings object which will be filled with the filenames
+    ///        of matching files, may be nil.
+    /// @returns the number of matching files
+    /// &lt;/summary&gt;
     function FindAll(_List: TStrings = nil): integer;
-    {! Calls FindClose so FindNext will start again. Reset does not change any
-       properties (e.g. Mask, MustHaveAttr, MayHaveAttr) }
+    /// &lt;summary&gt;
+    /// Calls FindClose so FindNext will start again. Reset does not change any
+    /// properties (e.g. Mask, MustHaveAttr, MayHaveAttr)
+    /// &lt;/summary&gt;
     procedure Reset;
-    {! Returns the number of matches so far, that is the number of successful
-       calls to FindNext }
+    /// Returns the number of matches so far, that is the number of successful
+    /// calls to FindNext
+    /// &lt;/summary&gt;
     property MatchCount: integer read FMatchCount;
-    {! Returns the search mask }
+    /// &lt;summary&gt;
+    /// Returns the search mask
+    /// &lt;/summary&gt;
     property Mask: string read FMask; // write fMask;
-    {! the set of attributes a file must have to be found by FindNext }
+    /// &lt;summary&gt;
+    /// the set of attributes a file must have to be found by FindNext
+    /// &lt;/summary&gt;
     property MustHaveAttr: TFileAttributeSet read FMustHaveAttr write FMustHaveAttr;
-    {! the set of allowed attributes for a file to be found by FindNext }
+    /// &lt;summary&gt;
+    /// the set of allowed attributes for a file to be found by FindNext
+    /// &lt;/summary&gt;
     property MayHaveAttr: TFileAttributeSet read FMayHaveAttr write FMayHaveAttr;
-    {! the search rec containing additional information about the file }
+    /// &lt;summary&gt;
+    /// the search rec containing additional information about the file
+    /// &lt;/summary&gt;
     property Sr: TSearchRec read FSr;
   end;
 
 type
-  {! represents the status of a CopyFile/MoveFileWithProgress operation, passed
-     as parameter to the callback function. }
+  /// &lt;summary&gt;
+  /// Represents the status of a CopyFile/MoveFileWithProgress operation, passed
+  /// as parameter to the callback function.
+  /// &lt;/summary&gt;
   TCopyProgressStatus = class
   public
   {(*}
   type
-    {! possible return values for the callback function }
+    /// &lt;summary&gt;
+    /// possible return values for the callback function
+    /// &lt;/summary&gt;
     TProgressResult = (
-      prContinue, {!&lt; continue with the copy/move operation }
-      prCancel,   {!&lt; cancel the operation, cannot be resumed }
-      prStop,     {!&lt; stop the operation, can be resumed, if cfwRestartable was passed }
-      prQuiet);   {!&lt; continue the operation, do not call the callback }
-    {! reason for calling the callback function }
+      prContinue, /// &lt; continue with the copy/move operation
+      prCancel,   /// &lt; cancel the operation, cannot be resumed
+      prStop,     /// &lt; stop the operation, can be resumed, if cfwRestartable was passed
+      prQuiet);   /// &lt; continue the operation, do not call the callback
+    /// &lt;summary&gt;
+    /// reason for calling the callback function
+    /// &lt;/summary&gt;
     TProgressReason = (
-      prChunkFinished, {!&lt; a chunk of the file has been copied }
-      prStreamSwitch); {!&lt; started to copy a new stream (set in the first callback) }
+      prChunkFinished, /// &lt; a chunk of the file has been copied
+      prStreamSwitch); /// &lt; started to copy a new stream (set in the first callback)
   {*)}
   protected
     FTotalFileSize: LARGE_INTEGER;
@@ -131,34 +166,65 @@
     FSourceFile: THandle;
     FDestinationFile: THandle;
   public
-    {! total size of the file }
+    /// &lt;summary&gt;
+    /// total size of the file
+    /// &lt;/summary&gt;
     property TotalFileSize: LARGE_INTEGER read FTotalFileSize;
-    {! total bytes that have been transferred so far }
+    /// &lt;summary&gt;
+    /// total bytes that have been transferred so far
+    /// &lt;/summary&gt;
     property TotalBytesTransferred: LARGE_INTEGER read FTotalBytesTransferred;
-    {! size of the stream that is currently being transferred }
+    /// &lt;summary&gt;
+    /// size of the stream that is currently being transferred
+    /// &lt;/summary&gt;
     property StreamSize: LARGE_INTEGER read FStreamSize;
-    {! bytes of the current stream taht have been transferred so far }
+    /// &lt;summary&gt;
+    /// bytes of the current stream taht have been transferred so far
+    /// &lt;/summary&gt;
     property StreamBytesTransferred: LARGE_INTEGER read FStreamBytesTransferred;
-    {! Number of the current stream, starts with 1 (usually always 1) }
+    /// &lt;summary&gt;
+    /// Number of the current stream, starts with 1 (usually always 1)
+    /// &lt;/summary&gt;
     property StreamNumber: LongWord read FStreamNumber;
-    {! reason for callback }
+    /// &lt;summary&gt;
+    /// reason for callback
+    /// &lt;/summary&gt;
     property CallbackReason: TProgressReason read FCallbackReason;
-    {! Handle of source file }
+    /// &lt;summary&gt;
+    /// Handle of source file
+    /// &lt;/summary&gt;
     property SourceFile: THandle read FSourceFile;
-    {! Handle of destination file }
+    /// &lt;summary&gt;
+    /// Handle of destination file
+    /// &lt;/summary&gt;
     property DestinationFile: THandle read FDestinationFile;
   end;
+
+  ///&lt;summary&gt;
+  /// Type for OnCopyFileProgress event
+  ///  @param Status is the currenct status of the operation
+  ///  @param Continue determines whether to continue copying or aborting, defaults
+  ///         to prContinue
+  /// &lt;/summary&gt;
   TCopyFileProgressEvt = procedure(_Status: TCopyProgressStatus;
     var _Continue: TCopyProgressStatus.TProgressResult) of object;
 
-  {! defines the action to take if a file already exists but has a different content }
+  /// &lt;summary&gt;
+  /// defines the action to take if a file already exists but has a different content
+  /// &lt;/summary&gt;
   TFileExistsAction = (feaIgnore, feaOverwrite);
   TOnSyncing = procedure(_Sender: TObject; const _SrcDir, _DstDir: string) of object;
   TOnSyncingFile = procedure(_Sender: TObject; const _SrcDir, _DstDir: string; _Total, _Done: Int64) of object;
-  {! called if a destination file already exists
-     @param Action is the action to take, default is feaIgnore }
+
+  /// &lt;summary&gt;
+  /// called if a destination file already exists
+  /// @param Action is the action to take, default is feaIgnore
+  /// &lt;/summary&gt;
   TOnFileExists = procedure(_Sender: TObject; const _SrcFile, _DstFile: TFileInfoRec; var _Action: TFileExistsAction) of object;
-  {! Synchronizes two directories }
+
+  /// &lt;summary&gt;
+  /// Synchronizes two directories
+  /// &lt;/summary&gt;
   TDirectorySync = class
   private
     FCurrentSource: string;
@@ -174,36 +240,50 @@
     function doOnFileExists(const _SrcDir, _DstDir, _Filename: string): TFileExistsAction;
     procedure ProgressStatusCallback(_Status: TCopyProgressStatus; var _Continue: TCopyProgressStatus.TProgressResult);
   public
-    {! Checks if there are files in the source directory that are already in
-       the destination directory, for each file that exists, the OnFileExists
-       event is called. }
+    /// &lt;summary&gt;
+    /// Checks if there are files in the source directory that are already in
+    /// the destination directory, for each file that exists, the OnFileExists
+    /// event is called.
+    /// &lt;/summary&gt;
     procedure CheckOneWay(const _SrcDir, _DstDir: string);
-    {! copies all files from DirA to DirB if they don't already exists
-       (not implemented: if CheckContent=true, the content existing files will be checked and if
-                         it doesn't match, OnDifferentFileExists is called )
-       @param FlattenDirHierarchy determines whether all files should be copied
-                                  directly DstDir or if subdirectories should
-                                  be created, default is false }
+    /// &lt;summary&gt;
+    /// copies all files from DirA to DirB if they don't already exists
+    /// (not implemented: if CheckContent=true, the content existing files will be checked and if
+    ///                   it doesn't match, OnDifferentFileExists is called)
+    /// @param FlattenDirHierarchy determines whether all files should be copied
+    ///                            directly DstDir or if subdirectories should
+    ///                            be created, default is false
+    /// &lt;/summary&gt;
     procedure SyncOneWay(const _SrcDir, _DstDir: string; _FlattenDirHierarchy: boolean = false);
-    {! calls SyncOneWay(DirA, DirB) and SyncOneWay(DirB, DirA)
-       (not implemented: if CheckContent=true, the content existing files will be checked and if
-                         it doesn't match, OnDifferentFileExists is called ) }
+    /// &lt;summary&gt;
+    /// calls SyncOneWay(DirA, DirB) and SyncOneWay(DirB, DirA)
+    /// (not implemented: if CheckContent=true, the content existing files will be checked and if
+    ///                   it doesn't match, OnDifferentFileExists is called)
+    /// &lt;/summary&gt;
     procedure SyncBothWays(const _DirA, _DirB: string);
 //    {! Not implemented: Called, if the content of an existing file is different }
 //    property OnDifferentFileExists: TOnDifferentFileExists read FOnDifferentFileExists write FOnDifferentFileExists;
 //    {! Not implemented: if true, OnDifferentFileExists will be called }
 //    property CheckContent: boolean read FCheckContent write FCheckContent default false;
-    {! called when a new directory is entered, to abort synchronization,
-       raise an exception (e.g. SysUtils.Abort), and catch it in the calling method }
+    /// &lt;summary&gt;
+    /// called when a new directory is entered, to abort synchronization,
+    /// raise an exception (e.g. SysUtils.Abort), and catch it in the calling method
+    /// &lt;/summary&gt;
     property OnSyncingDir: TOnSyncing read FOnSyncingDir write FOnSyncingDir;
-    {! called when a file is being copied, to abort synchronization,
-      raise an exception (e.g. SysUtils.Abort), and catch it in the calling method }
+    /// &lt;summary&gt;
+    /// called when a file is being copied, to abort synchronization,
+    /// raise an exception (e.g. SysUtils.Abort), and catch it in the calling method
+    /// &lt;/summary&gt;
     property OnSyncingFile: TOnSyncingFile read FOnSyncingFile write FOnSyncingFile;
-    {! called from CheckOneWay if a destination file already exists }
+    /// &lt;summary&gt;
+    /// called from CheckOneWay if a destination file already exists
+    /// &lt;/summary&gt;
     property OnFileExists: TOnFileExists read FOnFileExists write FOnFileExists;
   end;
 
-  {! This class owns all utility functions as class methods so they don't pollute the name space }
+  /// &lt;summary&gt;
+  /// This class owns all utility functions as class methods so they don't pollute the name space
+  /// &lt;/summary&gt;
   TFileSystem = class
   public
   {(*}
@@ -215,205 +295,254 @@
     TCopyFileWithProgressFlagSet = set of TCopyFileWithProgressFlags;
     TCopyFileWithProgressResult = (cfwOK, cfwAborted, cfwError);
     TMoveFileWithProgressFlags = (
-      mfwFailIfExists, {!&lt; fail if the destination file already exists }
-      mfwAllowCopy,    {!&lt; allow using copy and delete if necessary }
-      mfwDelayUntilReboot, {!&lt; wait until next reboot for moving the file }
-      mfwWriteThrough, {!&lt; Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. }
-      mfwFailIfNotTrackable, {!&lt; The function fails if the source file is a link source, but the file cannot be tracked after the move. }
-      mfwRaiseException); {!&lt; raise an exception if there is an error }
+      mfwFailIfExists, /// &lt; fail if the destination file already exists
+      mfwAllowCopy,    /// &lt; allow using copy and delete if necessary
+      mfwDelayUntilReboot, /// &lt; wait until next reboot for moving the file
+      mfwWriteThrough, /// &lt; Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns.
+      mfwFailIfNotTrackable, /// &lt; The function fails if the source file is a link source, but the file cannot be tracked after the move.
+      mfwRaiseException); /// &lt; raise an exception if there is an error
     TMoveFileWithProgressFlagSet = set of TMoveFileWithProgressFlags;
   const
-  {! set of char constant containing all characters that are invalid in a filename }
+    /// &lt;summary&gt;
+    /// set of char constant containing all characters that are invalid in a filename
+    /// &lt;/summary&gt;
     INVALID_FILENAME_CHARS: set of Char = ['\', '/', ':', '*', '?', '&quot;', '&lt;', '&gt;', '|'];
   {*)}
-    {! Returns a temporary filename.
-       @param Directory is a string with the directory to create the file in, defaults
-                        to the TEMP directory.
-       @param Prefix is a string with a prefix for the filename, defaults to 'dz'.)
-       @param Unique is an word that the function converts to a hexadecimal string
-       for use in creating the temporary filename.)
-       &lt;ul&gt;
-         &lt;li&gt;If Unique is nonzero, the function appends the hexadecimal string to
-             &lt;b&gt;Prefix&lt;/b&gt;
-             to form the temporary filename. In this case, the function does not create
-             the specified file, and does not test whether the filename is unique.&lt;/li&gt;
-         &lt;li&gt;If Unique is zero, the function uses a hexadecimal string derived
-             from the current system time. In this case, the function uses different
-             values until it finds a unique filename, and then it creates the file
-             in the &lt;b&gt;Directory&lt;/b&gt;.&lt;/li&gt;
-       &lt;/ul&gt;
-       @returns a filename to use for a temporary file. }
+    /// &lt;summary&gt;
+    /// Returns a temporary filename.
+    /// @param Directory is a string with the directory to create the file in, defaults
+    ///                  to the TEMP directory.
+    /// @param Prefix is a string with a prefix for the filename, defaults to 'dz'.)
+    /// @param Unique is an word that the function converts to a hexadecimal string
+    /// for use in creating the temporary filename.)
+    /// &lt;ul&gt;
+    ///   &lt;li&gt;If Unique is nonzero, the function appends the hexadecimal string to
+    ///       &lt;b&gt;Prefix&lt;/b&gt;
+    ///       to form the temporary filename. In this case, the function does not create
+    ///       the specified file, and does not test whether the filename is unique.&lt;/li&gt;
+    ///   &lt;li&gt;If Unique is zero, the function uses a hexadecimal string derived
+    ///       from the current system time. In this case, the function uses different
+    ///       values until it finds a unique filename, and then it creates the file
+    ///       in the &lt;b&gt;Directory&lt;/b&gt;.&lt;/li&gt;
+    /// &lt;/ul&gt;
+    /// @returns a filename to use for a temporary file.
+    /// &lt;/summary&gt;
     class function GetTempFileName(_Directory: string = ''; const _Prefix: string = 'dz';
       _Unique: word = 0): string;
 
-    {! Calls the corresponding Windows function and returns the short path name
-       for an *existing* file or directory. }
+    /// &lt;summary&gt;
+    /// Calls the corresponding Windows function and returns the short path name
+    /// for an *existing* file or directory.
+    /// &lt;/summary&gt;
     class function GetShortPathname(const _LongName: string): string;
 
-    {! Creates a unique subdirectory under BaseDir with the given Prefix
-       if Basedir is an empty string the system's %TEMP% directory is used.
-       @returns the name of the created directory }
+    /// &lt;summary&gt;
+    /// Creates a unique subdirectory under BaseDir with the given Prefix
+    /// if Basedir is an empty string the system's %TEMP% directory is used.
+    /// @returns the name of the created directory
+    /// &lt;/summary&gt;
     class function CreateUniqueDirectory(_BaseDir: string = ''; const _Prefix: string = 'dz'): string;
 
-    {! Calls the Win32Api function GetTempPath but returns a string rather than
-       a PChar.
-       @returns(a string with the TEMP directory) }
+    /// &lt;summary&gt;
+    /// Calls the Win32Api function GetTempPath but returns a string rather than
+    /// a PChar.
+    /// @returns a string with the TEMP directory
+    /// &lt;/summary&gt;
     class function GetTempPath: string;
-    {! Moves the file Source to Dest using the Windows MoveFile function.
-       @param Source is a string containing the name of the existing file
-       @param Dest is a string containing the destination file name
-       @param RaiseException is a boolean which controls whether the function
-              retrieves the Windows error and raises an exception
-              if it fails. If false, it will not raise an exception
-              but just return false if moving the file fails.
-       @returns true, if the file could be moved, false otherwise. }
+    /// &lt;summary&gt;
+    /// Moves the file Source to Dest using the Windows MoveFile function.
+    /// @param Source is a string containing the name of the existing file
+    /// @param Dest is a string containing the destination file name
+    /// @param RaiseException is a boolean which controls whether the function
+    ///        retrieves the Windows error and raises an exception
+    ///        if it fails. If false, it will not raise an exception
+    ///        but just return false if moving the file fails.
+    /// @returns true, if the file could be moved, false otherwise.
+    /// &lt;/summary&gt;
     class function MoveFile(const _Source, _Dest: string; _RaiseException: boolean = true): boolean;
-    {! Copies the file Source to Dest using the Windows CopyFile function.
-       @param Source is a string containing the name of the existing file
-       @param Dest is a string containing the destination file name
-       @param FailIfExists is a boolean specifying whether the copy operation
-              should fail if the destination file already exists.
-       @param RaiseException is a boolean which controls whether the function
-              retrieves the Windows error and raises an exception
-              if it fails. If false, it will not raise an exception
-              but just return false if copying the file fails.
-       @param ForceOverwrite is a boolean which controls whether the function removes
-              a read-only flag from the destination file if necessary.
-       @returns true, if the file could be copied, false otherwise. }
+    /// &lt;summary&gt;
+    /// Copies the file Source to Dest using the Windows CopyFile function.
+    /// @param Source is a string containing the name of the existing file
+    /// @param Dest is a string containing the destination file name
+    /// @param FailIfExists is a boolean specifying whether the copy operation
+    ///        should fail if the destination file already exists.
+    /// @param RaiseException is a boolean which controls whether the function
+    ///        retrieves the Windows error and raises an exception
+    ///        if it fails. If false, it will not raise an exception
+    ///        but just return false if copying the file fails.
+    /// @param ForceOverwrite is a boolean which controls whether the function removes
+    ///        a read-only flag from the destination file if necessary.
+    /// @returns true, if the file could be copied, false otherwise.
+    /// &lt;/summary&gt;
     class function CopyFile(const _Source, _Dest: string; _FailIfExists: boolean = true;
       _RaiseException: boolean = true; _ForceOverwrite: boolean = false): boolean; overload;
-    {! Copies the file Source to Dest using the Windows CopyFile function.
-       @param(Source is a string containing the name of the existing file)
-       @param(Dest is a string containing the destination file name)
-       @param(Flags is a set of TCopyFileFlags specifying whether the copy operation
-              cfFailIfExists: fail if the destination file already exists.
-              cfForceOverwrite: remove a read-only flag from the destination file if necessary.
-              cfRaiseException: retrieve the Windows error and raise an exception if it fails.
-                If not set, it will not raise an exception but just return false if
-                copying the file fails.)
-       @returns(true, if the file could be copied, false otherwise.) }
+    /// &lt;summary&gt;
+    /// Copies the file Source to Dest using the Windows CopyFile function.
+    /// @param(Source is a string containing the name of the existing file)
+    /// @param(Dest is a string containing the destination file name)
+    /// @param(Flags is a set of TCopyFileFlags specifying whether the copy operation
+    ///        cfFailIfExists: fail if the destination file already exists.
+    ///        cfForceOverwrite: remove a read-only flag from the destination file if necessary.
+    ///        cfRaiseException: retrieve the Windows error and raise an exception if it fails.
+    ///          If not set, it will not raise an exception but just return false if
+    ///          copying the file fails.)
+    /// @returns(true, if the file could be copied, false otherwise.)
+    /// &lt;/summary&gt;
     class function CopyFile(const _Source, _Dest: string;
       _Flags: TCopyFileFlagSet = [cfRaiseException]): boolean; overload;
-    {! Copies the file Source to Dest using the Windows CopyFileEx function which
-       allows for a progress callback
-       @param(Source is a string containing the name of the existing file)
-       @param(Dest is a string containing the destination file name)
-       @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
-              cfwFailIfExists: fail if the destination file already exists.
-              cfwRestartable: stores information in the destination file that allows
-                to restart a stopped copy operation
-              cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
-                If not set, it will not raise an exception but just return cfwAborted
-                or cfwError if copying the file fails. (set by default))
-       @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
-                stopped in the callback function and cfeError on any other error.
-       @raises  EOSError if an error occurs and cfwRaiseException was passed }
+    /// &lt;summary&gt;
+    /// Copies the file Source to Dest using the Windows CopyFileEx function which
+    /// allows for a progress callback
+    /// @param(Source is a string containing the name of the existing file)
+    /// @param(Dest is a string containing the destination file name)
+    /// @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
+    ///        cfwFailIfExists: fail if the destination file already exists.
+    ///        cfwRestartable: stores information in the destination file that allows
+    ///          to restart a stopped copy operation
+    ///        cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
+    ///          If not set, it will not raise an exception but just return cfwAborted
+    ///          or cfwError if copying the file fails. (set by default))
+    /// @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
+    ///          stopped in the callback function and cfeError on any other error.
+    /// @raises  EOSError if an error occurs and cfwRaiseException was passed
+    /// &lt;/summary&gt;
     class function CopyFileWithProgress(const _Source, _Dest: string; _Progress: TCopyFileProgressEvt;
       _Flags: TCopyFileWithProgressFlagSet = [cfwRaiseException]): TCopyFileWithProgressResult;
-    {! Copies the file Source to Dest using the Windows MoveFileWithProgress function which
-       allows for a progress callback
-       NOTE: If the file can be moved rather than copied, no call to the callback
-             function will occur!
-       @param(Source is a string containing the name of the existing file)
-       @param(Dest is a string containing the destination file name)
-       @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
-              cfwFailIfExists: fail if the destination file already exists.
-              cfwRestartable: stores information in the destination file that allows
-                to restart a stopped copy operation
-              cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
-                If not set, it will not raise an exception but just return cfwAborted
-                or cfwError if copying the file fails. (set by default))
-       @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
-                stopped in the callback function and cfeError on any other error.
-       @raises  EOSError if an error occurs and cfwRaiseException was passed }
+    /// &lt;summary&gt;
+    /// Copies the file Source to Dest using the Windows MoveFileWithProgress function which
+    /// allows for a progress callback
+    /// NOTE: If the file can be moved rather than copied, no call to the callback
+    ///       function will occur!
+    /// @param(Source is a string containing the name of the existing file)
+    /// @param(Dest is a string containing the destination file name)
+    /// @param(Flags is a set of TCopyFileWithProgressFlags specifying whether the copy operation
+    ///        cfwFailIfExists: fail if the destination file already exists.
+    ///        cfwRestartable: stores information in the destination file that allows
+    ///          to restart a stopped copy operation
+    ///        cfwRaiseException: retrieve the Windows error and raise an exception if it fails.
+    ///          If not set, it will not raise an exception but just return cfwAborted
+    ///          or cfwError if copying the file fails. (set by default))
+    /// @returns cfeOK, if the copying succeeds, cfeAborted if the copying was aborted or
+    ///          stopped in the callback function and cfeError on any other error.
+    /// @raises  EOSError if an error occurs and cfwRaiseException was passed
+    /// &lt;/summary&gt;
     class function MoveFileWithProgress(const _Source, _Dest: string; _Progress: TCopyFileProgressEvt;
       _Flags: TMoveFileWithProgressFlagSet = [mfwRaiseException]): TCopyFileWithProgressResult;
-    {! Creates a directory (parent directories must already exist)
-       @param DirectoryName is the name for the new directory
-       @param RaiseException determines whether an exception is raised on error, default = true
-       @returns true, if the directory was created
-       @raises EOSError if there was an error and RaiseException was true }
+    /// &lt;summary&gt;
+    /// Creates a directory (parent directories must already exist)
+    /// @param DirectoryName is the name for the new directory
+    /// @param RaiseException determines whether an exception is raised on error, default = true
+    /// @returns true, if the directory was created
+    /// @raises EOSError if there was an error and RaiseException was true
+    /// &lt;/summary&gt;
     class function CreateDir(const _DirectoryName: string; _RaiseException: boolean = true): boolean;
-    {! Creates a new directory, including the creation of parent directories as needed.
-       @param DirectoryPath is the name for the new directory
-       @param RaiseException determines whether an exception is raised on error, default = true
-       @returns true, if the directory was created
-       @raises EOSError if there was an error and RaiseException was true }
+    /// &lt;summary&gt;
+    /// Creates a new directory, including the creation of parent directories as needed.
+    /// @param DirectoryPath is the name for the new directory
+    /// @param RaiseException determines whether an exception is raised on error, default = true
+    /// @returns true, if the directory was created
+    /// @raises EOSError if there was an error and RaiseException was true
+    /// &lt;/summary&gt;
     class function ForceDir(const _DirectoryPath: string; _RaiseException: boolean = true): boolean;
-    {! Sets a file's readonly flag
-       @param Filename is the file to change
-       @param Set determines whether to set or clear the flag }
+    /// &lt;summary&gt;
+    /// Sets a file's readonly flag
+    /// @param Filename is the file to change
+    /// @param Set determines whether to set or clear the flag
+    /// &lt;/summary&gt;
     class function SetReadonly(const _Filename: string; _Set: boolean; _RaiseException: boolean = true): boolean;
-    {! Deletes the file using the SysUtils.DeleteFile function.
-       @param(Filename is a string containing the name of the file)
-       @param(RaiseException is a boolean which controls whether the function
-              retrieves the Windows error and raises an exception
-              if it fails. If false, it will not raise an exception
-              but just return false if moving the file fails. )
-       @param(Force is a boolean which controls whether this function will try to delete
-              readonly files, If true, it will use SetFileAttr to reset the
-              readonly attribut and try to delete the file again.)
-       @returns(true, if the file could be deleted, false otherwise.) }
+    /// &lt;summary&gt;
+    /// Deletes the file using the SysUtils.DeleteFile function.
+    /// @param Filename is a string containing the name of the file
+    /// @param RaiseException is a boolean which controls whether the function
+    ///        retrieves the Windows error and raises an exception
+    ///        if it fails. If false, it will not raise an exception
+    ///        but just return false if moving the file fails. 
+    /// @param Force is a boolean which controls whether this function will try to delete
+    ///        readonly files, If true, it will use SetFileAttr to reset the
+    ///        readonly attribut and try to delete the file again.
+    /// @returns true, if the file could be deleted, false otherwise.
+    /// &lt;/summary&gt;
     class function DeleteFile(const _Filename: string; _RaiseException: boolean = true; _Force: boolean = false): boolean;
-    {! Deletes all files in a directory matching a given filemask (non-recursive)
-       @param Dir is a string containting the directory in which the files are to be
-                  deleted, must NOT be empty
-       @param Mask is a string containting the file search mask, all files matching
-                   this mask will be deleted
-       @param RaiseException is a boolean which controls whether the function
-                             retrieves the Windows error and raises an exception
-                             if it fails. If false, it will not raise an exception
-                             but just return false if moving the file fails.
-       @param Force is a boolean which controls whether this function will try to delete
-                    readonly files, If true, it will use SetFileAttr to reset the
-                    readonly attribut and try to delete the file again.
-       @returns the number of files that could not be deleted. }
+    /// &lt;summary&gt;
+    /// Deletes all files in a directory matching a given filemask (non-recursive)
+    /// @param Dir is a string containting the directory in which the files are to be
+    ///            deleted, must NOT be empty
+    /// @param Mask is a string containting the file search mask, all files matching
+    ///             this mask will be deleted
+    /// @param RaiseException is a boolean which controls whether the function
+    ///                       retrieves the Windows error and raises an exception
+    ///                       if it fails. If false, it will not raise an exception
+    ///                       but just return false if moving the file fails.
+    /// @param Force is a boolean which controls whether this function will try to delete
+    ///              readonly files, If true, it will use SetFileAttr to reset the
+    ///              readonly attribut and try to delete the file again.
+    /// @returns the number of files that could not be deleted.
+    /// &lt;/summary&gt;
     class function DeleteMatchingFiles(const _Dir, _Mask: string;
       _RaiseException: boolean = true; _Force: boolean = false): integer;
-    {! tries to find a matching file
-       @param Mask is the filename mask to match
-       @param Filename is the name of the file which has been found, only valid if result &lt;&gt; mfNotFound
-       @returns mfNotFound, if no file was found, or mfDirectory, mfFile or mfSpecial
-                describing the type of the file which has been found }
+    /// &lt;summary&gt;
+    /// tries to find a matching file
+    /// @param Mask is the filename mask to match
+    /// @param Filename is the name of the file which has been found, only valid if result &lt;&gt; mfNotFound
+    /// @returns mfNotFound, if no file was found, or mfDirectory, mfFile or mfSpecial
+    ///          describing the type of the file which has been found
+    /// &lt;/summary&gt;
     class function FindMatchingFile(const _Mask: string; out _Filename: string): TMatchingFileResult;
     class function RemoveDir(const _Dirname: string; _RaiseException: boolean = true;
       _Force: boolean = false): boolean;
-    {! Deletes a directory with all files and subdirectories.
-       @param(Dirname is the name of the directory to delete)
-       @param(Force specifies whether it should also delete readonly files) }
+    /// &lt;summary&gt;
+    /// Deletes a directory with all files and subdirectories.
+    /// @param(Dirname is the name of the directory to delete)
+    /// @param(Force specifies whether it should also delete readonly files)
+    /// &lt;/summary&gt;
     class function DelTree(const _Dirname: string; _Force: boolean = false; _RaiseException: boolean = true): boolean;
-    {! reads a text file and returns its content as a string
-       @param Filename is the name of the file to read
-       @returns the file's content as a string }
+    /// &lt;summary&gt;
+    /// reads a text file and returns its content as a string
+    /// @param Filename is the name of the file to read
+    /// @returns the file's content as a string
+    /// &lt;/summary&gt;
     class function ReadTextFile(const _Filename: string): string;
-
-    {! checks whether the given string is a valid filename (without path), that is
-       does not contain one of the characters defined in INVALID_FILENAME_CHARS
-       @param s is the string to check
-       @returns true, if the string is a valid filename, false otherwise }
+    /// &lt;summary&gt;
+    /// checks whether the given string is a valid filename (without path), that is
+    /// does not contain one of the characters defined in INVALID_FILENAME_CHARS
+    /// @param s is the string to check
+    /// @returns true, if the string is a valid filename, false otherwise
+    /// &lt;/summary&gt;
     class function IsValidFilename(const _s: string): boolean; overload;
-    {! checks whether the given string is a valid filename (without path), that is
-       does not contain one of the characters defined in INVALID_FILENAME_CHARS and
-       returns the first error position.
-       @param s is the string to check
-       @param ErrPos is the first error position, only valid it result = false
-       @returns true, if the string is a valid filename, false otherwise }
+    /// &lt;summary&gt;
+    /// checks whether the given string is a valid filename (without path), that is
+    /// does not contain one of the characters defined in INVALID_FILENAME_CHARS and
+    /// returns the first error position.
+    /// @param s is the string to check
+    /// @param ErrPos is the first error position, only valid it result = false
+    /// @returns true, if the string is a valid filename, false otherwise
+    /// &lt;/summary&gt;
     class function IsValidFilename(const _s: string; out _ErrPos: integer): boolean; overload;
-    {! creates a backup of the file appending the current date and time to the base
-       file name.
-       @param Filename is the name of the file to back up
-       @param BackupDir is a directory in which to create the backup file, if empty
-                        the same directory as the original file is used }
+    /// &lt;summary&gt;
+    /// creates a backup of the file appending the current date and time to the base
+    /// file name.
+    /// @param Filename is the name of the file to back up
+    /// @param BackupDir is a directory in which to create the backup file, if empty
+    ///                  the same directory as the original file is used
+    /// &lt;/summary&gt;
     class procedure BackupFile(const _Filename: string; _BackupDir: string = '');
     class function GetFileInfo(const _Filename: string): TFileInfoRec;
-    {! Returns the free space (in bytes) on the disk with the given drive letter }
+    /// &lt;summary&gt;
+    /// Returns the free space (in bytes) on the disk with the given drive letter
+    /// &lt;/summary&gt;
     class function DiskFree(_DriveLetter: char): Int64;
   end;
 
 type
-  {! callback event for generating a filename for the given generation }
+  /// &lt;summary&gt;
+  /// callback event for generating a filename for the given generation
+  ///  &lt;/summary&gt;
   TOnGenerateFilename = procedure(_Sender: TObject; _Generation: integer; var _Filename: string) of object;
 type
+  /// &lt;summary&gt;
+  /// This class handles keeping gernations of files, e.g. log files. The default
+  /// is to keep 10 generations
+  /// &lt;/summary&gt;
   TFileGenerationHandler = class
   private
     FBaseName: string;
@@ -425,28 +554,44 @@
     FPrependZeros: integer;
     function GenerateFilename(_Generation: integer): string;
   public
-    {! @param BaseName is the base filename to which by default _&lt;n&gt; followed by
-                       the Suffix will be appended
-       @param Suffix is the suffix for the filename, usually an extension which
-                     must include the dot (.) }
+    /// &lt;summary&gt;
+    /// @param BaseName is the base filename to which by default _&lt;n&gt; followed by
+    ///                 the Suffix will be appended
+    /// @param Suffix is the suffix for the filename, usually an extension which
+    ///               must include the dot (.)
+    /// &lt;/summary&gt;
     constructor Create(const _BaseName, _Suffix: string);
-    {! generates the filename and returns it }
+    /// &lt;summary&gt;
+    /// generates the filename and returns it
+    /// &lt;/summary&gt;
     function Execute(_KeepOriginal: boolean): string;
-    {! the maximum of file generations that should be kept }
+    /// &lt;summary&gt;
+    /// the maximum of file generations that should be kept
+    /// &lt;/summary&gt;
     property MaxGenerations: integer read FMaxGenerations write FMaxGenerations default 5;
-    {! should the resulting filename contain a number? }
+    /// &lt;summary&gt;
+    /// should the resulting filename contain a number?
+    /// &lt;/summary&gt;
     property ResultContainsNumber: boolean read FResultContainsNumber write FResultContainsNumber default false;
-    {! does the oldest file have the highest number? }
+    /// &lt;summary&gt;
+    /// does the oldest file have the highest number?
+    /// &lt;/summary&gt;
     property OldestIsHighest: boolean read FOldestIsHighest write FOldestIsHighest default true;
     property PrependZeros: integer read FPrependZeros write FPrependZeros default 0;
-    {! allows read access to the file's base name as passed to the constructor }
+    /// &lt;summary&gt;
+    /// allows read access to the file's base name as passed to the constructor
+    /// &lt;/summary&gt;
     property BaseName: string read FBaseName;
     property Suffix: string read FSuffix;
-    {! callback event for generating a filename for the given generation }
+    /// &lt;summary&gt;
+    /// callback event for generating a filename for the given generation
+    /// &lt;/summary&gt;
     property OnGenerateFilename: TOnGenerateFilename read FOnGenerateFilename write FOnGenerateFilename;
   end;
 
-{! This is an abbreviation for IncludeTrailingPathDelimiter }
+/// &lt;summary&gt;
+/// This is an abbreviation for IncludeTrailingPathDelimiter
+/// &lt;/summary&gt;
 function itpd(const _Dirname: string): string; inline;
 
 implementation
@@ -464,18 +609,18 @@
   STR_GETTEMPFILENAME_ERROR_DS = 'u_dzFileUtils.GetTempFilename: %1:s (Code: %0:d) calling Windows.GetTempFileName';
   STR_GETSHORTPATHNAME_ERROR_DS = 'u_dzFileUtils.GetShortPathname: %1:s (Code: %0:d) calling Windows.GetShortPathname';
   STR_GETSHORTPATHNAME_TOO_LONG_D = 'Short pathname is longer than MAX_PATH (%d) characters';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_MOVEFILE_ERROR_SS = 'Error %%1:s (%%0:d) while trying to move &quot;%s&quot; to &quot;%s&quot;.';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_SETREADONLY_ERROR_S = 'Error %%1:s (%%0:d) while changing the readonly flag of &quot;%s&quot;';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_COPYFILE_ERROR_SS = 'Error %%1:s (%%0:d) while trying to copy &quot;%s&quot; to &quot;%s&quot;.';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_DELETEFILE_ERROR_S = 'Error %%1:s (%%0:d) deleting file &quot;%s&quot;';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_REMOVEDIR_ERROR_S = 'Error %%1:s (%%0:d) deleting directory &quot;%s&quot;';
   STR_DELTREE_ERROR_S = '&quot;%s&quot; does not exist or is not a directory';
-  // doppelte % zum Durchreichen in Prozedur
+  // duplicate % so they get passed through the format function
   STR_CREATEDIR_ERROR_S = 'Error %%1:s (%%0:d) creating directory &quot;%s&quot;';
 
 function itpd(const _Dirname: string): string; inline;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000120.html">[Dzchart-svncheckins] r251 - utilities/dzLib/trunk/src
</A></li>
	<LI>Next message: <A HREF="000122.html">[Dzchart-svncheckins] r253 - in utilities/dzLib/trunk/tests: .	dzfileutils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#121">[ date ]</a>
              <a href="thread.html#121">[ thread ]</a>
              <a href="subject.html#121">[ subject ]</a>
              <a href="author.html#121">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dzchart-svncheckins">More information about the dzchart-svncheckins
mailing list</a><br>
</body></html>
