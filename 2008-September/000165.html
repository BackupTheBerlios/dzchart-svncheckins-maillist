<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dzchart-svncheckins] r298 - utilities/dzLib/trunk/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dzchart-svncheckins/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:dzchart-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BDzchart-svncheckins%5D%20r298%20-%20utilities/dzLib/trunk/src&In-Reply-To=%3C200809041035.m84AZHMB029848%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000164.html">
   <LINK REL="Next"  HREF="000166.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dzchart-svncheckins] r298 - utilities/dzLib/trunk/src</H1>
    <B>twm at mail.berlios.de</B> 
    <A HREF="mailto:dzchart-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BDzchart-svncheckins%5D%20r298%20-%20utilities/dzLib/trunk/src&In-Reply-To=%3C200809041035.m84AZHMB029848%40sheep.berlios.de%3E"
       TITLE="[Dzchart-svncheckins] r298 - utilities/dzLib/trunk/src">twm at mail.berlios.de
       </A><BR>
    <I>Thu Sep  4 12:35:17 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000164.html">[Dzchart-svncheckins] r297 - utilities/dzLib/trunk/src
</A></li>
        <LI>Next message: <A HREF="000166.html">[Dzchart-svncheckins] r299 - utilities/dzLib/trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#165">[ date ]</a>
              <a href="thread.html#165">[ thread ]</a>
              <a href="subject.html#165">[ subject ]</a>
              <a href="author.html#165">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: twm
Date: 2008-09-04 12:35:11 +0200 (Thu, 04 Sep 2008)
New Revision: 298

Modified:
   utilities/dzLib/trunk/src/u_dzRingBuffer.pas
Log:
* changed all pasdoc comments to xmldoc
* replaced resource strings with calls to DGetText(..., 'dzlib')


Modified: utilities/dzLib/trunk/src/u_dzRingBuffer.pas
===================================================================
--- utilities/dzLib/trunk/src/u_dzRingBuffer.pas	2008-09-04 10:25:53 UTC (rev 297)
+++ utilities/dzLib/trunk/src/u_dzRingBuffer.pas	2008-09-04 10:35:11 UTC (rev 298)
@@ -17,168 +17,173 @@
 type
   TdzCustomRingBuffer = class
   protected
-    {: size of one element stored in this buffer }
-    fElementSize: integer;
-    {: length of the buffer }
-    fLength: integer;
-    {: pointer to a memory block that stores the buffer }
-    fBuffer: PByte;
-    {: position of the first element stored in the buffer,
-       if fFirstUsed = fFirstFree the buffer is empty }
-    fFirstUsed: integer;
-    {: position of the next element bo be stored in the buffer
-       if fFirstUsed = fFirstFree the buffer is empty }
-    fFirstFree: integer;
-    {: number of elements stored in the buffer }
-    fElementCount: integer;
-    {: is called by the destructor to do any finalization that might be
-       necessary for the elements stored in the buffer. Does nothing here. }
+    ///&lt;summary&gt; size of one element stored in this buffer &lt;/summary&gt;
+    FElementSize: integer;
+    ///&lt;summary&gt; length of the buffer &lt;/summary&gt;
+    FLength: integer;
+    ///&lt;summary&gt; pointer to a memory block that stores the buffer &lt;/summary&gt;
+    FBuffer: PByte;
+    ///&lt;summary&gt; position of the first element stored in the buffer,
+    ///          if fFirstUsed = fFirstFree the buffer is empty &lt;/summary&gt;
+    FFirstUsed: integer;
+    ///&lt;summary&gt; position of the next element bo be stored in the buffer
+    ///          if fFirstUsed = fFirstFree the buffer is empty &lt;/summary&gt;
+    FFirstFree: integer;
+    ///&lt;summary&gt; number of elements stored in the buffer &lt;/summary&gt;
+    FElementCount: integer;
+    ///&lt;summary&gt; is called by the destructor to do any finalization that might be
+    ///          necessary for the elements stored in the buffer. Does nothing here. &lt;/summary&gt;
     procedure FinalizeElements; virtual;
-    {: inserts the given Element in front of the buffer }
+    ///&lt;summary&gt; inserts the given Element in front of the buffer &lt;/summary&gt;
     procedure InsertFront(const _Element); virtual;
-    {: inserts the given Element at the end of the buffer }
+    ///&lt;summary&gt; inserts the given Element at the end of the buffer &lt;/summary&gt;
     procedure InsertEnd(const _Element); virtual;
-    {: extracts the first Element from the buffer }
+    ///&lt;summary&gt; extracts the first Element from the buffer &lt;/summary&gt;
     procedure ExtractFront(var _Element); virtual;
-    {: extracts the last Element from the buffer }
+    ///&lt;summary&gt; extracts the last Element from the buffer &lt;/summary&gt;
     procedure ExtractEnd(var _Element); virtual;
-    {: gets the Element with the index Idx }
+    ///&lt;summary&gt; gets the Element with the index Idx &lt;/summary&gt;
     procedure GetElement(_Idx: integer; var _Element); virtual;
-    {: sets the Element with the index Idx, note: No finalization is done
-       for the element previously stored at Idx. }
+    ///&lt;summary&gt; sets the Element with the index Idx, note: No finalization is done
+    ///          for the element previously stored at Idx. &lt;/summary&gt;
     procedure SetElement(_Idx: integer; const _Element); virtual;
-    {: gets the first Element from the buffer }
+    ///&lt;summary&gt; gets the first Element from the buffer &lt;/summary&gt;
     procedure GetFirst(var _Element); virtual;
-    {: gets the last Element from the buffer }
+    ///&lt;summary&gt; gets the last Element from the buffer &lt;/summary&gt;
     procedure GetLast(var _Element); virtual;
-    {: checks whether there is enough space for another element in the buffer }
+    ///&lt;summary&gt; checks whether there is enough space for another element in the buffer &lt;/summary&gt;
     procedure CheckFull; virtual;
-    {: checks whether there are any elements in the buffer }
+    ///&lt;summary&gt; checks whether there are any elements in the buffer &lt;/summary&gt;
     procedure CheckEmpty; virtual;
-    {: returns true, if the buffer is full }
+    ///&lt;summary&gt; returns true, if the buffer is full &lt;/summary&gt;
     function IsFull: boolean; virtual;
-    {: returns true, if the buffer is empty }
+    ///&lt;summary&gt; returns true, if the buffer is empty &lt;/summary&gt;
     function IsEmpty: boolean; virtual;
-    {: returns the number of elements stored in the buffer }
+    ///&lt;summary&gt; returns the number of elements stored in the buffer &lt;/summary&gt;
     function GetCount: integer; virtual;
-    {: deletes all elements from the buffer }
+    ///&lt;summary&gt; deletes all elements from the buffer &lt;/summary&gt;
     procedure Clear; virtual;
   public
-    {: creates a ringbuffer with enough space to store Length elements of
-       ElementSize bytes size }
+    ///&lt;summary&gt; creates a ringbuffer with enough space to store Length elements of
+    ///          ElementSize bytes size &lt;/summary&gt;
     constructor Create(_ElementSize: integer; _Length: integer);
-    {: calls FinalizeElements and frees the memory allocated for the buffer }
+    ///&lt;summary&gt; calls FinalizeElements and frees the memory allocated for the buffer &lt;/summary&gt;
     destructor Destroy; override;
   end;
 
 type
-  {: publishes all methods of TdzCustomRingBuffer }
+  ///&lt;summary&gt; publishes all methods of TdzCustomRingBuffer &lt;/summary&gt;
   TdzRingBuffer = class(TdzCustomRingbuffer)
   public
-    {: inserts the given Element in front of the buffer }
+    ///&lt;summary&gt; inserts the given Element in front of the buffer &lt;/summary&gt;
     procedure InsertFront(const _Element); override;
-    {: inserts the given Element at the end of the buffer }
+    ///&lt;summary&gt; inserts the given Element at the end of the buffer &lt;/summary&gt;
     procedure InsertEnd(const _Element); override;
-    {: extracts the first Element from the buffer }
+    ///&lt;summary&gt; extracts the first Element from the buffer &lt;/summary&gt;
     procedure ExtractFront(var _Element); override;
-    {: extracts the last Element from the buffer }
+    ///&lt;summary&gt; extracts the last Element from the buffer &lt;/summary&gt;
     procedure ExtractEnd(var _Element); override;
-    {: gets the Element with the index Idx }
+    ///&lt;summary&gt; gets the Element with the index Idx &lt;/summary&gt;
     procedure GetElement(_Idx: integer; var _Element); override;
-    {: sets the Element with the index Idx, note: No finalization is done
-       for the element previously stored at Idx. }
+    ///&lt;summary&gt; sets the Element with the index Idx, note: No finalization is done
+    ///          for the element previously stored at Idx. &lt;/summary&gt;
     procedure SetElement(_Idx: integer; const _Element); override;
-    {: gets the first Element from the buffer }
+    ///&lt;summary&gt; gets the first Element from the buffer &lt;/summary&gt;
     procedure GetFirst(var _Element); override;
-    {: gets the last Element from the buffer }
+    ///&lt;summary&gt; gets the last Element from the buffer &lt;/summary&gt;
     procedure GetLast(var _Element); override;
-    {: checks whether there is enough space for another element in the buffer }
+    ///&lt;summary&gt; checks whether there is enough space for another element in the buffer &lt;/summary&gt;
     procedure CheckFull; override;
-    {: checks whether there are any elements in the buffer }
+    ///&lt;summary&gt; checks whether there are any elements in the buffer &lt;/summary&gt;
     procedure CheckEmpty; override;
-    {: returns true, if the buffer is full }
+    ///&lt;summary&gt; returns true, if the buffer is full &lt;/summary&gt;
     function IsFull: boolean; override;
-    {: returns true, if the buffer is empty }
+    ///&lt;summary&gt; returns true, if the buffer is empty &lt;/summary&gt;
     function IsEmpty: boolean; override;
-    {: returns the number of elements stored in the buffer }
+    ///&lt;summary&gt; returns the number of elements stored in the buffer &lt;/summary&gt;
     function GetCount: integer; override;
-    {: deletes all elements from the buffer }
+    ///&lt;summary&gt; deletes all elements from the buffer &lt;/summary&gt;
     procedure Clear; override;
   end;
 
 type
-  {: makes only those methods public that are useful for a stack }
+  ///&lt;summary&gt; makes only those methods public that are useful for a stack
+  ///          (Yes, it doesn't really make much sense implementing a stack
+  ///          as a ring buffer.) &lt;/summary&gt;
   TdzRingStack = class(TdzCustomRingbuffer)
   public
-    {: inserts the given Element at the end of the buffer }
+    ///&lt;summary&gt; inserts the given Element at the end of the buffer &lt;/summary&gt;
     procedure InsertEnd(const _Element); override;
-    {: extracts the last Element from the buffer }
+    ///&lt;summary&gt; extracts the last Element from the buffer &lt;/summary&gt;
     procedure ExtractEnd(var _Element); override;
-    {: gets the Element with the index Idx }
+    ///&lt;summary&gt; gets the Element with the index Idx &lt;/summary&gt;
     procedure GetElement(_Idx: integer; var _Element); override;
-    {: sets the Element with the index Idx, note: No finalization is done
-       for the element previously stored at Idx. }
+    ///&lt;summary&gt; sets the Element with the index Idx, note: No finalization is done
+    ///          for the element previously stored at Idx. &lt;summary&gt;
     procedure SetElement(_Idx: integer; const _Element); override;
-    {: gets the last Element from the buffer }
+    ///&lt;summary&gt; gets the last Element from the buffer &lt;/summary&gt;
     procedure GetLast(var _Element); override;
-    {: returns true, if the buffer is full }
+    ///&lt;summary&gt; returns true, if the buffer is full &lt;/summary&gt;
     function IsFull: boolean; override;
-    {: returns true, if the buffer is empty }
+    ///&lt;summary&gt; returns true, if the buffer is empty &lt;/summary&gt;
     function IsEmpty: boolean; override;
-    {: returns the number of elements stored in the buffer }
+    ///&lt;summary&gt; returns the number of elements stored in the buffer &lt;/summary&gt;
     function GetCount: integer; override;
-    {: deletes all elements from the buffer }
+    ///&lt;summary&gt; deletes all elements from the buffer &lt;/summary&gt;
     procedure Clear; override;
   end;
 
 type
-  {: makes only those methods public that are usefull for a queue }
+  ///&lt;summary&gt; makes only those methods public that are usefull for a queue &lt;/summary&gt;
   TdzRingQueue = class(TdzCustomRingbuffer)
-    {: inserts the given Element at the end of the buffer }
+    ///&lt;summary&gt; inserts the given Element at the end of the buffer &lt;/summary&gt;
     procedure InsertEnd(const _Element); override;
-    {: extracts the first Element from the buffer }
+    ///&lt;summary&gt; extracts the first Element from the buffer &lt;/summary&gt;
     procedure ExtractFront(var _Element); override;
-    {: gets the Element with the index Idx }
+    ///&lt;summary&gt; gets the Element with the index Idx &lt;/summary&gt;
     procedure GetElement(_Idx: integer; var _Element); override;
-    {: sets the Element with the index Idx, note: No finalization is done
-       for the element previously stored at Idx. }
+    ///&lt;summary&gt; sets the Element with the index Idx, note: No finalization is done
+    ///          for the element previously stored at Idx. &lt;/summary&gt;
     procedure SetElement(_Idx: integer; const _Element); override;
-    {: gets the first Element from the buffer }
+    ///&lt;summary&gt; gets the first Element from the buffer &lt;/summary&gt;
     procedure GetFirst(var _Element); override;
-    {: returns true, if the buffer is full }
+    ///&lt;summary&gt; returns true, if the buffer is full &lt;/summary&gt;
     function IsFull: boolean; override;
-    {: returns true, if the buffer is empty }
+    ///&lt;summary&gt; returns true, if the buffer is empty &lt;/summary&gt;
     function IsEmpty: boolean; override;
-    {: returns the number of elements stored in the buffer }
+    ///&lt;summary&gt; returns the number of elements stored in the buffer &lt;/summary&gt;
     function GetCount: integer; override;
-    {: deletes all elements from the buffer }
+    ///&lt;summary&gt; deletes all elements from the buffer &lt;/summary&gt;
     procedure Clear; override;
   end;
 
 implementation
 
-resourcestring
-  RS_INDEX_OUT_OF_BOUNDS_D = 'Index %d out of bounds.';
-  RS_BUFFER_IS_FULL = 'Buffer is full';
-  RS_BUFFER_IS_EMPTY = 'Buffer is empty';
+uses
+  u_dzTranslator;
 
+function _(const _s: string): string; inline;
+begin
+  Result := u_dzTranslator.DGetText(_s, 'dzlib');
+end;
+
 { TdzCustomRingBuffer }
 
 constructor TdzCustomRingBuffer.Create(_ElementSize, _Length: integer);
 begin
   inherited Create;
-  fLength := _Length;
-  fElementSize := _ElementSize;
-  fFirstUsed := 0;
-  fFirstFree := 0;
-  GetMem(fBuffer, fLength * fElementSize);
+  FLength := _Length;
+  FElementSize := _ElementSize;
+  FFirstUsed := 0;
+  FFirstFree := 0;
+  GetMem(FBuffer, FLength * FElementSize);
 end;
 
 destructor TdzCustomRingBuffer.Destroy;
 begin
-  if Assigned(fBuffer) and (fLength &gt; 0) then begin
+  if Assigned(FBuffer) and (FLength &gt; 0) then begin
     FinalizeElements;
-    FreeMem(fBuffer);
+    FreeMem(FBuffer);
   end;
   inherited;
 end;
@@ -193,11 +198,11 @@
   p: PByte;
 begin
   CheckFull;
-  fFirstUsed := (fFirstUsed - 1) mod fLength;
-  p := fBuffer;
-  Inc(p, fFirstUsed * fElementSize);
-  Move(_Element, p^, fElementSize);
-  Inc(fElementCount);
+  FFirstUsed := (FFirstUsed - 1) mod FLength;
+  p := FBuffer;
+  Inc(p, FFirstUsed * FElementSize);
+  Move(_Element, p^, FElementSize);
+  Inc(FElementCount);
 end;
 
 procedure TdzCustomRingBuffer.InsertEnd(const _Element);
@@ -205,11 +210,11 @@
   p: PByte;
 begin
   CheckFull;
-  p := fBuffer;
-  Inc(p, fFirstFree * fElementSize);
-  Move(_Element, p^, fElementSize);
-  fFirstFree := (fFirstFree + 1) mod fLength;
-  Inc(fElementCount);
+  p := FBuffer;
+  Inc(p, FFirstFree * FElementSize);
+  Move(_Element, p^, FElementSize);
+  FFirstFree := (FFirstFree + 1) mod FLength;
+  Inc(FElementCount);
 end;
 
 procedure TdzCustomRingBuffer.ExtractFront(var _Element);
@@ -217,11 +222,11 @@
   p: PByte;
 begin
   CheckEmpty;
-  p := fBuffer;
-  Inc(p, fFirstUsed * fElementSize);
-  Move(p^, _Element, fElementSize);
-  fFirstUsed := (fFirstUsed + 1) mod fLength;
-  Dec(fElementCount);
+  p := FBuffer;
+  Inc(p, FFirstUsed * FElementSize);
+  Move(p^, _Element, FElementSize);
+  FFirstUsed := (FFirstUsed + 1) mod FLength;
+  Dec(FElementCount);
 end;
 
 procedure TdzCustomRingBuffer.ExtractEnd(var _Element);
@@ -229,33 +234,33 @@
   p: PByte;
 begin
   CheckEmpty;
-  fFirstFree := (fFirstFree - 1) mod fLength;
-  p := fBuffer;
-  Inc(p, fFirstFree * fElementSize);
-  Move(p^, _Element, fElementSize);
-  Dec(fElementCount);
+  FFirstFree := (FFirstFree - 1) mod FLength;
+  p := FBuffer;
+  Inc(p, FFirstFree * FElementSize);
+  Move(p^, _Element, FElementSize);
+  Dec(FElementCount);
 end;
 
 procedure TdzCustomRingBuffer.GetElement(_Idx: integer; var _Element);
 var
   p: PByte;
 begin
-  if (fFirstUsed + _Idx) mod fLength &gt;= fFirstFree then
-    raise EIndexOutOfBounds.CreateFmt(RS_INDEX_OUT_OF_BOUNDS_D, [_Idx]);
-  p := fBuffer;
-  Inc(p, (fFirstUsed + _Idx) * fElementSize);
-  Move(p^, _Element, fElementSize);
+  if (FFirstUsed + _Idx) mod FLength &gt;= FFirstFree then
+    raise EIndexOutOfBounds.CreateFmt(_('Index %d out of bounds.'), [_Idx]);
+  p := FBuffer;
+  Inc(p, (FFirstUsed + _Idx) * FElementSize);
+  Move(p^, _Element, FElementSize);
 end;
 
 procedure TdzCustomRingBuffer.SetElement(_Idx: integer; const _Element);
 var
   p: PByte;
 begin
-  if (fFirstUsed + _Idx) mod fLength &gt;= fFirstFree then
-    raise EIndexOutOfBounds.CreateFmt(RS_INDEX_OUT_OF_BOUNDS_D, [_Idx]);
-  p := fBuffer;
-  Inc(p, (fFirstUsed + _Idx) * fElementSize);
-  Move(_Element, p^, fElementSize);
+  if (FFirstUsed + _Idx) mod FLength &gt;= FFirstFree then
+    raise EIndexOutOfBounds.CreateFmt(_('Index %d out of bounds.'), [_Idx]);
+  p := FBuffer;
+  Inc(p, (FFirstUsed + _Idx) * FElementSize);
+  Move(_Element, p^, FElementSize);
 end;
 
 procedure TdzCustomRingBuffer.GetFirst(var _Element);
@@ -270,37 +275,37 @@
 
 function TdzCustomRingBuffer.IsFull: boolean;
 begin
-  Result := fElementCount &gt;= fLength;
+  Result := FElementCount &gt;= FLength;
 end;
 
 procedure TdzCustomRingBuffer.CheckFull;
 begin
   if IsFull then
-    raise EBufferFull.Create(RS_BUFFER_IS_FULL);
+    raise EBufferFull.Create('Buffer is full');
 end;
 
 function TdzCustomRingBuffer.IsEmpty: boolean;
 begin
-  Result := fElementCount = 0;
+  Result := FElementCount = 0;
 end;
 
 procedure TdzCustomRingBuffer.CheckEmpty;
 begin
   if IsEmpty then
-    raise EBufferEmpty.Create(RS_BUFFER_IS_EMPTY);
+    raise EBufferEmpty.Create('Buffer is empty');
 end;
 
 function TdzCustomRingBuffer.GetCount: integer;
 begin
-  Result := fElementCount;
+  Result := FElementCount;
 end;
 
 procedure TdzCustomRingBuffer.Clear;
 begin
   FinalizeElements;
-  fFirstUsed := 0;
-  fFirstFree := 0;
-  fElementCount := 0;
+  FFirstUsed := 0;
+  FFirstFree := 0;
+  FElementCount := 0;
 end;
 
 { TdzRingBuffer }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000164.html">[Dzchart-svncheckins] r297 - utilities/dzLib/trunk/src
</A></li>
	<LI>Next message: <A HREF="000166.html">[Dzchart-svncheckins] r299 - utilities/dzLib/trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#165">[ date ]</a>
              <a href="thread.html#165">[ thread ]</a>
              <a href="subject.html#165">[ subject ]</a>
              <a href="author.html#165">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dzchart-svncheckins">More information about the dzchart-svncheckins
mailing list</a><br>
</body></html>
