From twm at mail.berlios.de  Sun Jan 31 15:04:15 2010
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 31 Jan 2010 15:04:15 +0100
Subject: [Dzchart-svncheckins] r371 - 3rd/jedi_inc/trunk
Message-ID: <201001311404.o0VE4F9u022766@sheep.berlios.de>

Author: twm
Date: 2010-01-31 15:03:25 +0100 (Sun, 31 Jan 2010)
New Revision: 371

Modified:
   3rd/jedi_inc/trunk/jedi.inc
Log:
latest version of jedi.inc

Modified: 3rd/jedi_inc/trunk/jedi.inc
===================================================================
--- 3rd/jedi_inc/trunk/jedi.inc	2009-09-25 18:45:27 UTC (rev 370)
+++ 3rd/jedi_inc/trunk/jedi.inc	2010-01-31 14:03:25 UTC (rev 371)
@@ -1,75 +1,68 @@
 {$IFNDEF JEDI_INC}
 {$DEFINE JEDI_INC}
 
-// this means we do not really have the JCL, used somehwere in dzlib
-{$DEFINE no_jcl}
+{**************************************************************************************************}
+{                                                                                                  }
+{  The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License");}
+{  you may not use this file except in compliance with the License. You may obtain a copy of the   }
+{  License at http://www.mozilla.org/MPL/                                                          }
+{                                                                                                  }
+{  Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF  }
+{  ANY KIND, either express or implied. See the License for the specific language governing rights }
+{  and limitations under the License.                                                              }
+{                                                                                                  }
+{  The Original Code is: jedi.inc.                                                                 }
+{  The Initial Developer of the Original Code is Project JEDI http://www.delphi-jedi.org           }
+{                                                                                                  }
+{  Alternatively, the contents of this file may be used under the terms of the GNU Lesser General  }
+{  Public License (the  "LGPL License"), in which case the provisions of the LGPL License are      }
+{  applicable instead of those above. If you wish to allow use of your version of this file only   }
+{  under the terms of the LGPL License and not to allow others to use your version of this file    }
+{  under the MPL, indicate your decision by deleting the provisions above and replace them with    }
+{  the notice and other provisions required by the LGPL License. If you do not delete the          }
+{  provisions above, a recipient may use your version of this file under either the MPL or the     }
+{  LGPL License.                                                                                   }
+{                                                                                                  }
+{  For more information about the LGPL: http://www.gnu.org/copyleft/lesser.html                    }
+{                                                                                                  }
+{**************************************************************************************************}
+{                                                                                                  }
+{  This file defines various generic compiler directives used in different libraries, e.g. in the  }
+{  JEDI Code Library (JCL) and JEDI Visual Component Library Library (JVCL). The directives in     }
+{  this file are of generic nature and consist mostly of mappings from the VERXXX directives       }
+{  defined by Delphi, C++Builder and FPC to friendly names such as DELPHI5 and                     }
+{  SUPPORTS_WIDESTRING. These friendly names are subsequently used in the libraries to test for    }
+{  compiler versions and/or whether the compiler supports certain features (such as widestrings or }
+{  64 bit integers. The libraries provide an additional, library specific, include file. For the   }
+{  JCL e.g. this is jcl.inc. These files should be included in source files instead of this file   }
+{  (which is pulled in automatically).                                                             }
+{                                                                                                  }
+{**************************************************************************************************}
+{                                                                                                  }
+{ Last modified: $Date:: 2009-08-07 10:25:11 +0200 (ven. 07 ao?t 2009)                         $ }
+{ Revision:      $Rev:: 126                                                                      $ }
+{ Author:        $Author:: outch                                                                 $ }
+{                                                                                                  }
+{**************************************************************************************************}
 
-{******************************************************************************}
-{                                                                              }
-{  The contents of this file are subject to the Mozilla Public License         }
-{  Version 1.1 (the "License"); you may not use this file except in            }
-{  compliance with the License. You may obtain a copy of the License at        }
-{  http://www.mozilla.org/MPL/                                                 }
-{                                                                              }
-{  Software distributed under the License is distributed on an "AS IS" basis,  }
-{  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License    }
-{  for the specific language governing rights and limitations under the        }
-{  License.                                                                    }
-{                                                                              }
-{  The Original Code is: jedi.inc.                                             }
-{  The Initial Developer of the Original Code is Project JEDI                  }
-{  http://www.delphi-jedi.org                                                  }
-{                                                                              }
-{  Alternatively, the contents of this file may be used under the terms of     }
-{  the GNU Lesser General Public License (the  "LGPL License"), in which case  }
-{  the provisions of the LGPL License are applicable instead of those above.   }
-{  If you wish to allow use of your version of this file only under the terms  }
-{  of the LGPL License and not to allow others to use your version of this     }
-{  file under the MPL, indicate your decision by deleting the provisions       }
-{  above and replace them with the notice and other provisions required by     }
-{  the LGPL License. If you do not delete the provisions above, a recipient    }
-{  may use your version of this file under either the MPL or the LGPL License. }
-{                                                                              }
-{  For more information about the LGPL:                                        }
-{  http://www.gnu.org/copyleft/lesser.html                                     }
-{                                                                              }
-{******************************************************************************}
-{                                                                              }
-{  This file defines various generic compiler directives used in different     }
-{  libraries, e.g. in the JEDI Code Library (JCL) and JEDI Visual Component    }
-{  Library Library (J-VCL). The directives in this file are of generic nature  }
-{  and consist mostly of mappings from the VERXXX directives defined by        }
-{  Delphi, C++ Builder and FPC to friendly names such as DELPHI5 and           }
-{  SUPPORTS_WIDESTRING. These friendly names are subsequently used in the      }
-{  libraries to test for compiler versions and/or whether the compiler         }
-{  supports certain features (such as widestrings or 64 bit integers. The      }
-{  libraries provide an additional, library specific, include file. For the    }
-{  JCL e.g. this is jcl.inc. These files should be included in source files    }
-{  instead of this file (which is pulled in automatically).                    }
-{                                                                              }
-{******************************************************************************}
-
-// Last modified: $Date: 2007-03-18 18:48:59 +0100 (dim., 18 mars 2007) $
-// For history see end of file
-
 (*
 
 - Development environment directives
 
   This file defines two directives to indicate which development environment the
   library is being compiled with. Currently this can either be Delphi, Kylix,
-  C++ Builder or FPC.
+  C++Builder or FPC.
 
   Directive           Description
   ------------------------------------------------------------------------------
   DELPHI              Defined if compiled with Delphi
   KYLIX               Defined if compiled with Kylix
   DELPHICOMPILER      Defined if compiled with Delphi or Kylix/Delphi
-  BCB                 Defined if compiled with C++ Builder
-  CPPBUILDER          Defined if compiled with C++ Builder (alias for BCB)
-  BCBCOMPILER         Defined if compiled with C++ Builder or Kylix/C++
-  DELPHILANGUAGE      Defined if compiled with Delphi, Kylix or C++ Builder
-  BORLAND             Defined if compiled with Delphi, Kylix or C++ Builder
+  BCB                 Defined if compiled with C++Builder
+  CPPBUILDER          Defined if compiled with C++Builder (alias for BCB)
+  BCBCOMPILER         Defined if compiled with C++Builder or Kylix/C++
+  DELPHILANGUAGE      Defined if compiled with Delphi, Kylix or C++Builder
+  BORLAND             Defined if compiled with Delphi, Kylix or C++Builder
   FPC                 Defined if compiled with FPC
 
 - Platform Directives
@@ -80,10 +73,22 @@
   Directive           Description
   ------------------------------------------------------------------------------
   WIN32               Defined when target platform is 32 bit Windows
+  WIN64               Defined when target platform is 64 bit Windows
   MSWINDOWS           Defined when target platform is 32 bit Windows
   LINUX               Defined when target platform is Linux
-  UNIX                Defined when target platform is Linux or Unix
+  UNIX                Defined when target platform is Unix-like (including Linux)
+  CLR                 Defined when target platform is .NET
 
+- Architecture directives. These are auto-defined by FPC
+  CPU32 and CPU64 are mostly for generic pointer size dependant differences rather
+  than for a specific architecture.
+
+  CPU386              Defined when target platform is native x86 (win32)
+  CPUx86_64           Defined when target platform is native x86_64 (win64)
+  CPU32               Defined when target is 32-bit
+  CPU64	              Defined when target is 64-bit
+  CPUASM              Defined when target assembler is available
+
 - Visual library Directives
 
   The following directives indicate for a visual library. In a Delphi/BCB
@@ -97,6 +102,7 @@
   VisualCLX           Defined for Kylix; needs to be defined for Delphi/BCB to
                       use JCL with VisualCLX applications.
 
+
 - Other cross-platform related defines
 
   These symbols are intended to help in writing portable code.
@@ -107,6 +113,7 @@
   Win32API            Code is specific for the Win32 API;
                       use instead of "{$IFNDEF CLR} {$IFDEF MSWINDOWS}" constructs
 
+
 - Delphi Versions
 
   The following directives are direct mappings from the VERXXX directives to a
@@ -115,18 +122,24 @@
 
   Directive           Description
   ------------------------------------------------------------------------------
-  DELPHI1             Defined when compiling with Delphi 1
-  DELPHI2             Defined when compiling with Delphi 2
-  DELPHI3             Defined when compiling with Delphi 3
-  DELPHI4             Defined when compiling with Delphi 4
-  DELPHI5             Defined when compiling with Delphi 5
-  DELPHI6             Defined when compiling with Delphi 6
-  DELPHI7             Defined when compiling with Delphi 7
-  DELPHI8             Defined when compiling with Delphi 8
-  DELPHI2005          Defined when compiling with Delphi 2005
+  DELPHI1             Defined when compiling with Delphi 1 (Codename WASABI/MANGO)
+  DELPHI2             Defined when compiling with Delphi 2 (Codename POLARIS)
+  DELPHI3             Defined when compiling with Delphi 3 (Codename IVORY)
+  DELPHI4             Defined when compiling with Delphi 4 (Codename ALLEGRO)
+  DELPHI5             Defined when compiling with Delphi 5 (Codename ARGUS)
+  DELPHI6             Defined when compiling with Delphi 6 (Codename ILLIAD)
+  DELPHI7             Defined when compiling with Delphi 7 (Codename AURORA)
+  DELPHI8             Defined when compiling with Delphi 8 (Codename OCTANE)
+  DELPHI2005          Defined when compiling with Delphi 2005 (Codename DIAMONDBACK)
   DELPHI9             Alias for DELPHI2005
-  DELPHI10            Defined when compiling with Delphi Personality of BDS 4.0
-  DELPHI11            Defined when compiling with Delphi for Win32 2007
+  DELPHI10            Defined when compiling with Delphi 2006 (Codename DEXTER)
+  DELPHI2006          Alias for DELPHI10
+  DELPHI11            Defined when compiling with Delphi 2007 for Win32 (Codename SPACELY)
+  DELPHI2007          Alias for DELPHI11
+  DELPHI12            Defined when compiling with Delphi 2009 for Win32 (Codename TIBURON)
+  DELPHI2009          Alias for DELPHI12
+  DELPHI14            Defined when compiling with Delphi 2010 for Win32 (Codename WEAVER)
+  DELPHI2010          Alias for DELPHI14
   DELPHI1_UP          Defined when compiling with Delphi 1 or higher
   DELPHI2_UP          Defined when compiling with Delphi 2 or higher
   DELPHI3_UP          Defined when compiling with Delphi 3 or higher
@@ -137,9 +150,16 @@
   DELPHI8_UP          Defined when compiling with Delphi 8 or higher
   DELPHI2005_UP       Defined when compiling with Delphi 2005 or higher
   DELPHI9_UP          Alias for DELPHI2005_UP
-  DELPHI10_UP         Defined when compiling with Delphi Personality of BDS 4.0 or higher
-  DELPHI11_UP         Defined when compiling with Delphi for Win32 2007 or higher
+  DELPHI10_UP         Defined when compiling with Delphi 2006 or higher
+  DELPHI2006_UP       Alias for DELPHI10_UP
+  DELPHI11_UP         Defined when compiling with Delphi 2007 for Win32 or higher
+  DELPHI2007_UP       Alias for DELPHI11_UP
+  DELPHI12_UP         Defined when compiling with Delphi 2009 for Win32 or higher
+  DELPHI2009_UP       Alias for DELPHI12_UP
+  DELPHI14_UP         Defined when compiling with Delphi 2010 for Win32 or higher
+  DELPHI2010_UP       Alias for DELPHI14_UP
 
+
 - Kylix Versions
 
   The following directives are direct mappings from the VERXXX directives to a
@@ -150,11 +170,12 @@
   ------------------------------------------------------------------------------
   KYLIX1              Defined when compiling with Kylix 1
   KYLIX2              Defined when compiling with Kylix 2
-  KYLIX3              Defined when compiling with Kylix 3
+  KYLIX3              Defined when compiling with Kylix 3 (Codename CORTEZ)
   KYLIX1_UP           Defined when compiling with Kylix 1 or higher
   KYLIX2_UP           Defined when compiling with Kylix 2 or higher
   KYLIX3_UP           Defined when compiling with Kylix 3 or higher
 
+
 - Delphi Compiler Versions (Delphi / Kylix, not in BCB mode)
 
   Directive           Description
@@ -169,7 +190,9 @@
   DELPHICOMPILER8      Defined when compiling with Delphi 8
   DELPHICOMPILER9      Defined when compiling with Delphi 2005
   DELPHICOMPILER10     Defined when compiling with Delphi Personality of BDS 4.0
-  DELPHICOMPILER11     Defined when compiling with Delphi for Win32 2007
+  DELPHICOMPILER11     Defined when compiling with Delphi 2007 for Win32
+  DELPHICOMPILER12     Defined when compiling with Delphi Personality of BDS 6.0
+  DELPHICOMPILER14     Defined when compiling with Delphi Personality of BDS 7.0
   DELPHICOMPILER1_UP   Defined when compiling with Delphi 1 or higher
   DELPHICOMPILER2_UP   Defined when compiling with Delphi 2 or higher
   DELPHICOMPILER3_UP   Defined when compiling with Delphi 3 or higher
@@ -179,32 +202,42 @@
   DELPHICOMPILER7_UP   Defined when compiling with Delphi 7 or higher
   DELPHICOMPILER8_UP   Defined when compiling with Delphi 8 or higher
   DELPHICOMPILER9_UP   Defined when compiling with Delphi 2005
-  DELPHICOMPILER10_UP  Defined when compiling with Delphi Personality of BDS 4.0 or higher
-  DELPHICOMPILER11_UP  Defined when compiling with Delphi for Win32 2007 or higher
+  DELPHICOMPILER10_UP  Defined when compiling with Delphi 2006 or higher
+  DELPHICOMPILER11_UP  Defined when compiling with Delphi 2007 for Win32 or higher
+  DELPHICOMPILER12_UP  Defined when compiling with Delphi 2009 for Win32 or higher
+  DELPHICOMPILER14_UP  Defined when compiling with Delphi 2010 for Win32 or higher
 
-- C++ Builder Versions
 
+- C++Builder Versions
+
   The following directives are direct mappings from the VERXXX directives to a
   friendly name of the associated compiler. These directives are only defined if
-  the compiler is C++ Builder (ie BCB is defined).
+  the compiler is C++Builder (ie BCB is defined).
 
   Directive    Description
   ------------------------------------------------------------------------------
-  BCB1         Defined when compiling with C++ Builder 1
-  BCB3         Defined when compiling with C++ Builder 3
-  BCB4         Defined when compiling with C++ Builder 4
-  BCB5         Defined when compiling with C++ Builder 5
-  BCB6         Defined when compiling with C++ Builder 6
-  BCB10        Defined when compiling with C++ Builder Personality of BDS 4.0
-  BCB1_UP      Defined when compiling with C++ Builder 1 or higher
-  BCB3_UP      Defined when compiling with C++ Builder 3 or higher
-  BCB4_UP      Defined when compiling with C++ Builder 4 or higher
-  BCB5_UP      Defined when compiling with C++ Builder 5 or higher
-  BCB6_UP      Defined when compiling with C++ Builder 6 or higher
-  BCB10_UP     Defined when compiling with C++ Builder Personality of BDS 4.0 or higher
+  BCB1         Defined when compiling with C++Builder 1
+  BCB3         Defined when compiling with C++Builder 3
+  BCB4         Defined when compiling with C++Builder 4
+  BCB5         Defined when compiling with C++Builder 5 (Codename RAMPAGE)
+  BCB6         Defined when compiling with C++Builder 6 (Codename RIPTIDE)
+  BCB10        Defined when compiling with C++Builder Personality of BDS 4.0 (also known as C++Builder 2006) (Codename DEXTER)
+  BCB11        Defined when compiling with C++Builder Personality of RAD Studio 2007 (also known as C++Builder 2007) (Codename COGSWELL)
+  BCB12        Defined when compiling with C++Builder Personality of RAD Studio 2009 (also known as C++Builder 2009) (Codename TIBURON)
+  BCB14        Defined when compiling with C++Builder Personality of RAD Studio 2010 (also known as C++Builder 2010) (Codename WEAVER)
+  BCB1_UP      Defined when compiling with C++Builder 1 or higher
+  BCB3_UP      Defined when compiling with C++Builder 3 or higher
+  BCB4_UP      Defined when compiling with C++Builder 4 or higher
+  BCB5_UP      Defined when compiling with C++Builder 5 or higher
+  BCB6_UP      Defined when compiling with C++Builder 6 or higher
+  BCB10_UP     Defined when compiling with C++Builder Personality of BDS 4.0 or higher
+  BCB11_UP     Defined when compiling with C++Builder Personality of RAD Studio 2007 or higher
+  BCB12_UP     Defined when compiling with C++Builder Personality of RAD Studio 2009 or higher
+  BCB14_UP     Defined when compiling with C++Builder Personality of RAD Studio 2010 or higher
 
-- Borland Developer Studio Versions
 
+- CodeGear RAD Studio / Borland Developer Studio Versions
+
   The following directives are direct mappings from the VERXXX directives to a
   friendly name of the associated IDE. These directives are only defined if
   the IDE is Borland Developer Studio Version 2 or above.
@@ -214,15 +247,19 @@
 
   Directive    Description
   ------------------------------------------------------------------------------
-  BDS          Defined when compiling with a Borland Developer Studio version's dcc32.exe
-  BDS2         Defined when compiling with BDS 2.0 (Delphi 8)
-  BDS3         Defined when compiling with BDS 3.0 (Delphi 2005)
-  BDS4         Defined when compiling with BDS 4.0 (Borland Developer Studio 2006)
-  BDS5         Defined when compiling with BDS 5.0 (Codegear RAD Studio 2007)
+  BDS          Defined when compiling with BDS version of dcc32.exe (Codename SIDEWINDER)
+  BDS2         Defined when compiling with BDS 2.0 (Delphi 8) (Codename OCTANE)
+  BDS3         Defined when compiling with BDS 3.0 (Delphi 2005) (Codename DIAMONDBACK)
+  BDS4         Defined when compiling with BDS 4.0 (Borland Developer Studio 2006) (Codename DEXTER)
+  BDS5         Defined when compiling with BDS 5.0 (CodeGear RAD Studio 2007) (Codename HIGHLANDER)
+  BDS6         Defined when compiling with BDS 6.0 (CodeGear RAD Studio 2009) (Codename TIBURON)
+  BDS7         Defined when compiling with BDS 7.0 (CodeGear RAD Studio 2010) (Codename WEAVER)
   BDS2_UP      Defined when compiling with BDS 2.0 or higher
   BDS3_UP      Defined when compiling with BDS 3.0 or higher
   BDS4_UP      Defined when compiling with BDS 4.0 or higher
   BDS5_UP      Defined when compiling with BDS 5.0 or higher
+  BDS6_UP      Defined when compiling with BDS 6.0 or higher
+  BDS7_UP      Defined when compiling with BDS 7.0 or higher
 
 - Compiler Versions
 
@@ -230,62 +267,84 @@
   friendly name of the associated compiler. Unlike the DELPHI_X and BCB_X
   directives, these directives are indepedent of the development environment.
   That is, they are defined regardless of whether compilation takes place using
-  Delphi or C++ Builder.
+  Delphi or C++Builder.
 
   Directive     Description
   ------------------------------------------------------------------------------
   COMPILER1      Defined when compiling with Delphi 1
-  COMPILER2      Defined when compiling with Delphi 2 or C++ Builder 1
+  COMPILER2      Defined when compiling with Delphi 2 or C++Builder 1
   COMPILER3      Defined when compiling with Delphi 3
-  COMPILER35     Defined when compiling with C++ Builder 3
-  COMPILER4      Defined when compiling with Delphi 4 or C++ Builder 4
-  COMPILER5      Defined when compiling with Delphi 5 or C++ Builder 5
-  COMPILER6      Defined when compiling with Delphi 6 or C++ Builder 6
+  COMPILER35     Defined when compiling with C++Builder 3
+  COMPILER4      Defined when compiling with Delphi 4 or C++Builder 4
+  COMPILER5      Defined when compiling with Delphi 5 or C++Builder 5
+  COMPILER6      Defined when compiling with Delphi 6 or C++Builder 6
   COMPILER7      Defined when compiling with Delphi 7
   COMPILER8      Defined when compiling with Delphi 8
   COMPILER9      Defined when compiling with Delphi 9
-  COMPILER10     Defined when compiling with Delphi or C++ Builder Personalities of BDS 4.0
-  COMPILER11     Defined when compiling with Delphi for Win32 2007
+  COMPILER10     Defined when compiling with Delphi or C++Builder Personalities of BDS 4.0
+  COMPILER11     Defined when compiling with Delphi or C++Builder Personalities of BDS 5.0
+  COMPILER12     Defined when compiling with Delphi or C++Builder Personalities of BDS 6.0
+  COMPILER14     Defined when compiling with Delphi or C++Builder Personalities of BDS 7.0
   COMPILER1_UP   Defined when compiling with Delphi 1 or higher
-  COMPILER2_UP   Defined when compiling with Delphi 2 or C++ Builder 1 or higher
+  COMPILER2_UP   Defined when compiling with Delphi 2 or C++Builder 1 or higher
   COMPILER3_UP   Defined when compiling with Delphi 3 or higher
-  COMPILER35_UP  Defined when compiling with C++ Builder 3 or higher
-  COMPILER4_UP   Defined when compiling with Delphi 4 or C++ Builder 4 or higher
-  COMPILER5_UP   Defined when compiling with Delphi 5 or C++ Builder 5 or higher
-  COMPILER6_UP   Defined when compiling with Delphi 6 or C++ Builder 6 or higher
+  COMPILER35_UP  Defined when compiling with C++Builder 3 or higher
+  COMPILER4_UP   Defined when compiling with Delphi 4 or C++Builder 4 or higher
+  COMPILER5_UP   Defined when compiling with Delphi 5 or C++Builder 5 or higher
+  COMPILER6_UP   Defined when compiling with Delphi 6 or C++Builder 6 or higher
   COMPILER7_UP   Defined when compiling with Delphi 7
   COMPILER8_UP   Defined when compiling with Delphi 8
   COMPILER9_UP   Defined when compiling with Delphi Personalities of BDS 3.0
-  COMPILER10_UP  Defined when compiling with Delphi or C++ Builder Personalities of BDS 4.0 or higher
-  COMPILER11_UP  Defined when compiling with Delphi for Win32 2007 ir higher
+  COMPILER10_UP  Defined when compiling with Delphi or C++Builder Personalities of BDS 4.0 or higher
+  COMPILER11_UP  Defined when compiling with Delphi or C++Builder Personalities of BDS 5.0 or higher
+  COMPILER12_UP  Defined when compiling with Delphi or C++Builder Personalities of BDS 6.0 or higher
+  COMPILER14_UP  Defined when compiling with Delphi or C++Builder Personalities of BDS 7.0 or higher
 
+
 - RTL Versions
 
   Use e.g. following to determine the exact RTL version since version 14.0:
     {$IFDEF CONDITIONALEXPRESSIONS}
       {$IF Declared(RTLVersion) and (RTLVersion >= 14.2)}
-        // code for Delphi 6.02 or later, Kylix 2 or later, C++ Builder 6 or later
+        // code for Delphi 6.02 or higher, Kylix 2 or higher, C++Builder 6 or higher
         ...
       {$IFEND}
     {$ENDIF}
 
   Directive     Description
   ------------------------------------------------------------------------------
-  RTL80_UP      Defined when compiling with Delphi 1 or later
-  RTL90_UP      Defined when compiling with Delphi 2 or later
-  RTL93_UP      Defined when compiling with C++ Builder 1 or later
-  RTL100_UP     Defined when compiling with Delphi 3 or later
-  RTL110_UP     Defined when compiling with C++ Builder 3 or later
-  RTL120_UP     Defined when compiling with Delphi 4 or later
-  RTL125_UP     Defined when compiling with C++ Builder 4 or later
-  RTL130_UP     Defined when compiling with Delphi 5 or C++ Builder 5 or later
-  RTL140_UP     Defined when compiling with Delphi 6, Kylix 1, 2 or 3 or C++ Builder 6 or later
-  RTL150_UP     Defined when compiling with Delphi 7 or later
-  RTL160_UP     Defined when compiling with Delphi 8 or later
-  RTL170_UP     Defined when compiling with Delphi Personalities of BDS 3.0 or later
-  RTL180_UP     Defined when compiling with Delphi or C++ Builder Personalities of BDS 4.0 or later
-  RTL185_UP     Defined when compiling with Delphi for Win32 2007 or later
+  RTL80_UP      Defined when compiling with Delphi 1 or higher
+  RTL90_UP      Defined when compiling with Delphi 2 or higher
+  RTL93_UP      Defined when compiling with C++Builder 1 or higher
+  RTL100_UP     Defined when compiling with Delphi 3 or higher
+  RTL110_UP     Defined when compiling with C++Builder 3 or higher
+  RTL120_UP     Defined when compiling with Delphi 4 or higher
+  RTL125_UP     Defined when compiling with C++Builder 4 or higher
+  RTL130_UP     Defined when compiling with Delphi 5 or C++Builder 5 or higher
+  RTL140_UP     Defined when compiling with Delphi 6, Kylix 1, 2 or 3 or C++Builder 6 or higher
+  RTL150_UP     Defined when compiling with Delphi 7 or higher
+  RTL160_UP     Defined when compiling with Delphi 8 or higher
+  RTL170_UP     Defined when compiling with Delphi Personalities of BDS 3.0 or higher
+  RTL180_UP     Defined when compiling with Delphi or C++Builder Personalities of BDS 4.0 or higher
+  RTL185_UP     Defined when compiling with Delphi or C++Builder Personalities of BDS 5.0 or higher
+  RTL190_UP     Defined when compiling with Delphi.NET of BDS 5.0 or higher
+  RTL200_UP     Defined when compiling with Delphi or C++Builder Personalities of BDS 6.0 or higher
+  RTL210_UP     Defined when compiling with Delphi or C++Builder Personalities of BDS 7.0 or higher
 
+
+- CLR Versions
+
+  Directive     Description
+  ------------------------------------------------------------------------------
+  CLR            Defined when compiling for .NET
+  CLR10          Defined when compiling for .NET 1.0 (may be overriden by FORCE_CLR10)
+  CLR10_UP       Defined when compiling for .NET 1.0 or higher
+  CLR11          Defined when compiling for .NET 1.1 (may be overriden by FORCE_CLR11)
+  CLR11_UP       Defined when compiling for .NET 1.1 or higher
+  CLR20          Defined when compiling for .NET 2.0 (may be overriden by FORCE_CLR20)
+  CLR20_UP       Defined when compiling for .NET 2.0 or higher
+
+
 - Feature Directives
 
   The features directives are used to test if the compiler supports specific
@@ -295,61 +354,76 @@
 
   Directive              Description
   ------------------------------------------------------------------------------
-  SUPPORTS_CONSTPARAMS          Compiler supports const parameters (D1+)
-  SUPPORTS_SINGLE               Compiler supports the Single type (D1+)
-  SUPPORTS_DOUBLE               Compiler supports the Double type (D1+)
-  SUPPORTS_EXTENDED             Compiler supports the Extended type (D1+)
-  SUPPORTS_CURRENCY             Compiler supports the Currency type (D2+)
-  SUPPORTS_THREADVAR            Compiler supports threadvar declarations (D2+)
-  SUPPORTS_OUTPARAMS            Compiler supports out parameters (D3+)
-  SUPPORTS_VARIANT              Compiler supports variant (D2+)
-  SUPPORTS_WIDECHAR             Compiler supports the WideChar type (D2+)
-  SUPPORTS_WIDESTRING           Compiler supports the WideString type (D3+/BCB3+)
-  SUPPORTS_INTERFACE            Compiler supports interfaces (D3+/BCB3+)
-  SUPPORTS_DISPINTERFACE        Compiler supports dispatch interfaces (D3+/BCB3+)
-  SUPPORTS_DISPID               Compiler supports dispatch ids (D3+/BCB3+/FPC)
-  SUPPORTS_EXTSYM               Compiler supports the $EXTERNALSYM directive (D4+/BCB3+)
-  SUPPORTS_NODEFINE             Compiler supports the $NODEFINE directive (D4+/BCB3+)
-  SUPPORTS_LONGWORD             Compiler supports the LongWord type (unsigned 32 bit) (D4+/BCB4+)
-  SUPPORTS_INT64                Compiler supports the Int64 type (D4+/BCB4+)
-  SUPPORTS_DYNAMICARRAYS        Compiler supports dynamic arrays (D4+/BCB4+)
-  SUPPORTS_DEFAULTPARAMS        Compiler supports default parameters (D4+/BCB4+)
-  SUPPORTS_OVERLOAD             Compiler supports overloading (D4+/BCB4+)
-  SUPPORTS_IMPLEMENTS           Compiler supports implements (D4+/BCB4+)
-  SUPPORTS_DEPRECATED           Compiler supports the deprecated directive (D6+/BCB6+)
-  SUPPORTS_PLATFORM             Compiler supports the platform directive (D6+/BCB6+)
-  SUPPORTS_LIBRARY              Compiler supports the library directive (D6+/BCB6+)
-  SUPPORTS_LOCAL                Compiler supports the local directive (D6+/BCB6+)
-  SUPPORTS_INLINE               Compiler supports the inline directive (D9+)
-  SUPPORTS_FOR_IN               Compiler supports for in loops (D9+)
-  SUPPORTS_NESTED_CONSTANTS     Compiler supports nested constants (D9+)
-  SUPPORTS_NESTED_TYPES         Compiler supports nested types (D9+)
-  SUPPORTS_ENHANCED_RECORDS     Compiler supports class [operator|function|procedure] for record types (D9.NET, D10+)
-  SUPPORTS_CLASS_FIELDS         Compiler supports class fields (D9.NET, D10+)
-  SUPPORTS_CLASS_HELPERS        Compiler supports class helpers (D9.NET, D10+)
-  SUPPORTS_CLASS_OPERATORS      Compiler supports class operators (D9.NET, D10+)
-  SUPPORTS_STRICT               Compiler supports strict keyword (D9.NET, D10+)
-  SUPPORTS_STATIC               Compiler supports static keyword (D9.NET, D10+)
-  SUPPORTS_FINAL                Compiler supports final keyword (D9.NET, D10+)
-  ACCEPT_DEPRECATED             Compiler supports or ignores the deprecated directive (D6+/BCB6+/FPC)
-  ACCEPT_PLATFORM               Compiler supports or ignores the platform directive (D6+/BCB6+)
-  ACCEPT_LIBRARY                Compiler supports or ignores the library directive (D6+/BCB6+)
-  SUPPORTS_CUSTOMVARIANTS       Compiler supports custom variants (D6+/BCB6+)
-  SUPPORTS_VARARGS              Compiler supports varargs (D6+/BCB6+)
-  SUPPORTS_ENUMVALUE            Compiler supports assigning ordinalities to values of enums (D6+/BCB6+)
-  SUPPORTS_DEPRECATED_WARNINGS  Compiler supports deprecated warnings (D6+/BCB6+)
-  SUPPORTS_LIBRARY_WARNINGS     Compiler supports library warnings (D6+/BCB6+)
-  SUPPORTS_PLATFORM_WARNINGS    Compiler supports platform warnings (D6+/BCB6+)
-  SUPPORTS_UNSAFE_WARNINGS      Compiler supports unsafe warnings (D7)
-  SUPPORTS_WEAKPACKAGEUNIT      Compiler supports the WEAKPACKAGEUNIT directive
-  SUPPORTS_COMPILETIME_MESSAGES Compiler supports the MESSAGE directive
-  HAS_UNIT_LIBC                 Unit Libc exists (Kylix, FPC on Linux)
-  HAS_UNIT_RTLCONSTS            Unit RTLConsts exists (D6+/BCB6+)
-  HAS_UNIT_TYPES                Unit Types exists (D6+/BCB6+)
-  HAS_UNIT_VARIANTS             Unit Variants exists (D6+/BCB6+)
-  HAS_UNIT_STRUTILS             Unit StrUtils exists (D6+/BCB6+)
-  XPLATFORM_RTL                 The RTL supports crossplatform function names (e.g. RaiseLastOSError) (D6+/BCB6+/FPC)
+  SUPPORTS_CONSTPARAMS           Compiler supports const parameters (D1+)
+  SUPPORTS_SINGLE                Compiler supports the Single type (D1+)
+  SUPPORTS_DOUBLE                Compiler supports the Double type (D1+)
+  SUPPORTS_EXTENDED              Compiler supports the Extended type (D1+)
+  SUPPORTS_CURRENCY              Compiler supports the Currency type (D2+)
+  SUPPORTS_THREADVAR             Compiler supports threadvar declarations (D2+)
+  SUPPORTS_OUTPARAMS             Compiler supports out parameters (D3+)
+  SUPPORTS_VARIANT               Compiler supports variant (D2+)
+  SUPPORTS_WIDECHAR              Compiler supports the WideChar type (D2+)
+  SUPPORTS_WIDESTRING            Compiler supports the WideString type (D3+/BCB3+)
+  SUPPORTS_INTERFACE             Compiler supports interfaces (D3+/BCB3+)
+  SUPPORTS_DISPINTERFACE         Compiler supports dispatch interfaces (D3+/BCB3+)
+  SUPPORTS_DISPID                Compiler supports dispatch ids (D3+/BCB3+/FPC)
+  SUPPORTS_EXTSYM                Compiler supports the $EXTERNALSYM directive (D4+/BCB3+)
+  SUPPORTS_NODEFINE              Compiler supports the $NODEFINE directive (D4+/BCB3+)
+  SUPPORTS_LONGWORD              Compiler supports the LongWord type (unsigned 32 bit) (D4+/BCB4+)
+  SUPPORTS_INT64                 Compiler supports the Int64 type (D4+/BCB4+)
+  SUPPORTS_DYNAMICARRAYS         Compiler supports dynamic arrays (D4+/BCB4+)
+  SUPPORTS_DEFAULTPARAMS         Compiler supports default parameters (D4+/BCB4+)
+  SUPPORTS_OVERLOAD              Compiler supports overloading (D4+/BCB4+)
+  SUPPORTS_IMPLEMENTS            Compiler supports implements (D4+/BCB4+)
+  SUPPORTS_DEPRECATED            Compiler supports the deprecated directive (D6+/BCB6+)
+  SUPPORTS_PLATFORM              Compiler supports the platform directive (D6+/BCB6+)
+  SUPPORTS_LIBRARY               Compiler supports the library directive (D6+/BCB6+/FPC)
+  SUPPORTS_LOCAL                 Compiler supports the local directive (D6+/BCB6+)
+  SUPPORTS_SETPEFLAGS            Compiler supports the SetPEFlags directive (D6+/BCB6+)
+  SUPPORTS_EXPERIMENTAL_WARNINGS Compiler supports the WARN SYMBOL_EXPERIMENTAL and WARN UNIT_EXPERIMENTAL directives (D6+/BCB6+)
+  SUPPORTS_INLINE                Compiler supports the inline directive (D9+/FPC)
+  SUPPORTS_FOR_IN                Compiler supports for in loops (D9+)
+  SUPPORTS_NESTED_CONSTANTS      Compiler supports nested constants (D9+)
+  SUPPORTS_NESTED_TYPES          Compiler supports nested types (D9+)
+  SUPPORTS_REGION                Compiler supports the REGION and ENDREGION directives (D9+)
+  SUPPORTS_ENHANCED_RECORDS      Compiler supports class [operator|function|procedure] for record types (D9.NET, D10+)
+  SUPPORTS_CLASS_FIELDS          Compiler supports class fields (D9.NET, D10+)
+  SUPPORTS_CLASS_HELPERS         Compiler supports class helpers (D9.NET, D10+)
+  SUPPORTS_CLASS_OPERATORS       Compiler supports class operators (D9.NET, D10+)
+  SUPPORTS_STRICT                Compiler supports strict keyword (D9.NET, D10+)
+  SUPPORTS_STATIC                Compiler supports static keyword (D9.NET, D10+)
+  SUPPORTS_FINAL                 Compiler supports final keyword (D9.NET, D10+)
+  SUPPORTS_METHODINFO            Compiler supports the METHODINFO directives (D10+)
+  SUPPORTS_GENERICS              Compiler supports generic implementations (D11.NET, D12+)
+  SUPPORTS_DEPRECATED_DETAILS    Compiler supports additional text for the deprecated directive (D11.NET, D12+)
+  ACCEPT_DEPRECATED              Compiler supports or ignores the deprecated directive (D6+/BCB6+/FPC)
+  ACCEPT_PLATFORM                Compiler supports or ignores the platform directive (D6+/BCB6+/FPC)
+  ACCEPT_LIBRARY                 Compiler supports or ignores the library directive (D6+/BCB6+)
+  SUPPORTS_CUSTOMVARIANTS        Compiler supports custom variants (D6+/BCB6+)
+  SUPPORTS_VARARGS               Compiler supports varargs (D6+/BCB6+)
+  SUPPORTS_ENUMVALUE             Compiler supports assigning ordinalities to values of enums (D6+/BCB6+)
+  SUPPORTS_DEPRECATED_WARNINGS   Compiler supports deprecated warnings (D6+/BCB6+)
+  SUPPORTS_LIBRARY_WARNINGS      Compiler supports library warnings (D6+/BCB6+)
+  SUPPORTS_PLATFORM_WARNINGS     Compiler supports platform warnings (D6+/BCB6+)
+  SUPPORTS_UNSAFE_WARNINGS       Compiler supports unsafe warnings (D7)
+  SUPPORTS_WEAKPACKAGEUNIT       Compiler supports the WEAKPACKAGEUNIT directive
+  SUPPORTS_COMPILETIME_MESSAGES  Compiler supports the MESSAGE directive
+  SUPPORTS_PACKAGES              Compiler supports Packages
+  HAS_UNIT_LIBC                  Unit Libc exists (Kylix, FPC on Linux/x86)
+  HAS_UNIT_RTLCONSTS             Unit RTLConsts exists (D6+/BCB6+/FPC)
+  HAS_UNIT_TYPES                 Unit Types exists (D6+/BCB6+/FPC)
+  HAS_UNIT_VARIANTS              Unit Variants exists (D6+/BCB6+/FPC)
+  HAS_UNIT_STRUTILS              Unit StrUtils exists (D6+/BCB6+/FPC)
+  HAS_UNIT_DATEUTILS             Unit DateUtils exists (D6+/BCB6+/FPC)
+  HAS_UNIT_CONTNRS               Unit contnrs exists (D6+/BCB6+/FPC)
+  HAS_UNIT_HTTPPROD              Unit HTTPProd exists (D9+)
+  HAS_UNIT_ANSISTRINGS           Unit AnsiStrings exists (D12+)
+  HAS_UNIT_PNGIMAGE              Unit PngImage exists (D12+)
+  XPLATFORM_RTL                  The RTL supports crossplatform function names (e.g. RaiseLastOSError) (D6+/BCB6+/FPC)
+  SUPPORTS_UNICODE               string type is aliased to an unicode string (WideString or UnicodeString) (DX.NET, D12+)
+  SUPPORTS_UNICODE_STRING        Compiler supports UnicodeString (D12+)
 
+
 - Compiler Settings
 
   The compiler settings directives indicate whether a specific compiler setting
@@ -383,15 +457,22 @@
 
 { Set FreePascal to Delphi mode }
 {$IFDEF FPC}
-{$MODE DELPHI}
-{$ASMMODE Intel}
-{$UNDEF BORLAND}
+  {$MODE DELPHI}
+  {$ASMMODE Intel}
+  {$UNDEF BORLAND}
+  {$DEFINE CPUASM}
+   // FPC defines CPU32, CPU64 and Unix automatically
 {$ENDIF}
 
 {$IFDEF BORLAND}
-{$IFDEF LINUX}
-{$DEFINE KYLIX}
-{$ENDIF LINUX}
+  {$IFDEF LINUX}
+    {$DEFINE KYLIX}
+  {$ENDIF LINUX}
+  {$IFNDEF CLR}
+    {$DEFINE CPU386}  // For Borland compilers select the x86 compat assembler by default
+    {$DEFINE CPU32}   // Assume Borland compilers are 32-bit (rather than 64-bit)
+    {$DEFINE CPUASM}
+  {$ENDIF ~CLR}
 {$ENDIF BORLAND}
 
 {------------------------------------------------------------------------------}
@@ -399,577 +480,767 @@
 {------------------------------------------------------------------------------}
 
 {$IFDEF BORLAND}
-{$IFDEF KYLIX}
-{$I kylix.inc} // FPC incompatible stuff
-{$ELSE ~KYLIX}
+  {$IFDEF KYLIX}
+    {$I kylix.inc} // FPC incompatible stuff
+  {$ELSE ~KYLIX}
 
-{$DEFINE UNKNOWN_COMPILER_VERSION}
+    {$DEFINE UNKNOWN_COMPILER_VERSION}
 
-{$IFDEF VER80}
-{$DEFINE COMPILER1}
-{$DEFINE DELPHI1}
-{$DEFINE DELPHICOMPILER1}
-{$DEFINE RTL80_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER80}
+      {$DEFINE COMPILER1}
+      {$DEFINE DELPHI1}
+      {$DEFINE DELPHICOMPILER1}
+      {$DEFINE RTL80_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER90}
-{$DEFINE COMPILER2}
-{$DEFINE DELPHI2}
-{$DEFINE DELPHICOMPILER2}
-{$DEFINE RTL90_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER90}
+      {$DEFINE COMPILER2}
+      {$DEFINE DELPHI2}
+      {$DEFINE DELPHICOMPILER2}
+      {$DEFINE RTL90_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER93}
-{$DEFINE COMPILER2}
-{$DEFINE BCB1}
-{$DEFINE BCB}
-{$DEFINE RTL93_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER93}
+      {$DEFINE COMPILER2}
+      {$DEFINE BCB1}
+      {$DEFINE BCB}
+      {$DEFINE RTL93_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER100}
-{$DEFINE COMPILER3}
-{$DEFINE DELPHI3}
-{$DEFINE DELPHICOMPILER3}
-{$DEFINE RTL100_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER100}
+      {$DEFINE COMPILER3}
+      {$DEFINE DELPHI3}
+      {$DEFINE DELPHICOMPILER3}
+      {$DEFINE RTL100_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER110}
-{$DEFINE COMPILER35}
-{$DEFINE BCB3}
-{$DEFINE RTL110_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER110}
+      {$DEFINE COMPILER35}
+      {$DEFINE BCB3}
+      {$DEFINE BCB}
+      {$DEFINE RTL110_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER120}
-{$DEFINE COMPILER4}
-{$DEFINE DELPHI4}
-{$DEFINE DELPHICOMPILER4}
-{$DEFINE RTL120_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER120}
+      {$DEFINE COMPILER4}
+      {$DEFINE DELPHI4}
+      {$DEFINE DELPHICOMPILER4}
+      {$DEFINE RTL120_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER125}
-{$DEFINE COMPILER4}
-{$DEFINE BCB4}
-{$DEFINE BCB}
-{$DEFINE RTL125_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER125}
+      {$DEFINE COMPILER4}
+      {$DEFINE BCB4}
+      {$DEFINE BCB}
+      {$DEFINE RTL125_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER130}
-{$DEFINE COMPILER5}
-{$IFDEF BCB}
-{$DEFINE BCB5}
-{$ELSE}
-{$DEFINE DELPHI5}
-{$DEFINE DELPHICOMPILER5}
-{$ENDIF}
-{$DEFINE RTL130_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER130}
+      {$DEFINE COMPILER5}
+      {$IFDEF BCB}
+        {$DEFINE BCB5}
+      {$ELSE}
+        {$DEFINE DELPHI5}
+        {$DEFINE DELPHICOMPILER5}
+      {$ENDIF}
+      {$DEFINE RTL130_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER140}
-{$DEFINE COMPILER6}
-{$IFDEF BCB}
-{$DEFINE BCB6}
-{$ELSE}
-{$DEFINE DELPHI6}
-{$DEFINE DELPHICOMPILER6}
-{$ENDIF}
-{$DEFINE RTL140_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER140}
+      {$DEFINE COMPILER6}
+      {$IFDEF BCB}
+        {$DEFINE BCB6}
+      {$ELSE}
+        {$DEFINE DELPHI6}
+        {$DEFINE DELPHICOMPILER6}
+      {$ENDIF}
+      {$DEFINE RTL140_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER150}
-{$DEFINE COMPILER7}
-{$DEFINE DELPHI7}
-{$DEFINE DELPHICOMPILER7}
-{$DEFINE RTL150_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER150}
+      {$DEFINE COMPILER7}
+      {$DEFINE DELPHI7}
+      {$DEFINE DELPHICOMPILER7}
+      {$DEFINE RTL150_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER160}
-{$DEFINE BDS2}
-{$DEFINE BDS}
-{$DEFINE COMPILER8}
-{$DEFINE DELPHI8}
-{$DEFINE DELPHICOMPILER8}
-{$DEFINE RTL160_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER160}
+      {$DEFINE BDS2}
+      {$DEFINE BDS}
+      {$IFDEF CLR}
+        {$DEFINE CLR10}
+      {$ENDIF CLR}
+      {$DEFINE COMPILER8}
+      {$DEFINE DELPHI8}
+      {$DEFINE DELPHICOMPILER8}
+      {$DEFINE RTL160_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER170}
-{$DEFINE BDS3}
-{$DEFINE BDS}
-{$DEFINE COMPILER9}
-{$DEFINE DELPHI9}
-{$DEFINE DELPHI2005} // synonym to DELPHI9
-{$DEFINE DELPHICOMPILER9}
-{$DEFINE RTL170_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER170}
+      {$DEFINE BDS3}
+      {$DEFINE BDS}
+      {$IFDEF CLR}
+        {$DEFINE CLR11}
+      {$ENDIF CLR}
+      {$DEFINE COMPILER9}
+      {$DEFINE DELPHI9}
+      {$DEFINE DELPHI2005} // synonym to DELPHI9
+      {$DEFINE DELPHICOMPILER9}
+      {$DEFINE RTL170_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF VER180}
-{$DEFINE BDS}
-{$IFDEF VER185}
-{$DEFINE BDS5}
-{$DEFINE COMPILER11}
-{$IFDEF BCB}
-{$DEFINE BCB11}
-{$ELSE}
-{$DEFINE DELPHI11}
-{$DEFINE DELPHICOMPILER11}
-{$ENDIF}
-{$DEFINE RTL185_UP}
-{$ELSE ~~VER185}
-{$DEFINE BDS4}
-{$DEFINE COMPILER10}
-{$IFDEF BCB}
-{$DEFINE BCB10}
-{$ELSE}
-{$DEFINE DELPHI10}
-{$DEFINE DELPHICOMPILER10}
-{$ENDIF}
-{$DEFINE RTL180_UP}
-{$ENDIF ~VER185}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER180}
+      {$DEFINE BDS}
+      {$IFDEF CLR}
+        {$DEFINE CLR11}
+      {$ENDIF CLR}
+      {$IFDEF VER185}
+        {$DEFINE BDS5}
+        {$DEFINE COMPILER11}
+        {$IFDEF BCB}
+          {$DEFINE BCB11}
+        {$ELSE}
+          {$DEFINE DELPHI11}
+          {$DEFINE DELPHI2007} // synonym to DELPHI11
+          {$DEFINE DELPHICOMPILER11}
+        {$ENDIF}
+        {$DEFINE RTL185_UP}
+      {$ELSE ~~VER185}
+        {$DEFINE BDS4}
+        {$DEFINE COMPILER10}
+        {$IFDEF BCB}
+          {$DEFINE BCB10}
+        {$ELSE}
+          {$DEFINE DELPHI10}
+          {$DEFINE DELPHI2006} // synonym to DELPHI10
+          {$DEFINE DELPHICOMPILER10}
+        {$ENDIF}
+        {$DEFINE RTL180_UP}
+      {$ENDIF ~VER185}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
 
-{$IFDEF UNKNOWN_COMPILER_VERSION} // adjust for newer version
-{$DEFINE BDS5}
-{$DEFINE BDS}
-{$DEFINE COMPILER11}
-{$DEFINE DELPHI11}
-{$DEFINE DELPHICOMPILER11}
-{$DEFINE RTL185_UP}
-{$UNDEF UNKNOWN_COMPILER_VERSION}
-{$ENDIF}
+    {$IFDEF VER190} // Delphi 2007 for .NET
+      {$DEFINE BDS}
+      {$DEFINE BDS5}
+      {$IFDEF CLR}
+        {$DEFINE CLR20}
+      {$ENDIF CLR}
+      {$DEFINE COMPILER11}
+      {$DEFINE DELPHI11}
+      {$DEFINE DELPHI2007} // synonym to DELPHI11
+      {$DEFINE DELPHICOMPILER11}
+      {$DEFINE RTL190_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF VER190}
 
-{$ENDIF ~KYLIX}
+    {$IFDEF VER200} // RAD Studio 2009
+      {$DEFINE BDS}
+      {$DEFINE BDS6}
+      {$IFDEF CLR}
+        {$DEFINE CLR20}
+      {$ENDIF CLR}
+      {$DEFINE COMPILER12}
+      {$IFDEF BCB}
+        {$DEFINE BCB12}
+      {$ELSE}
+        {$DEFINE DELPHI12}
+        {$DEFINE DELPHI2009} // synonym to DELPHI12
+        {$DEFINE DELPHICOMPILER12}
+      {$ENDIF BCB}
+      {$IFDEF CLR}
+        {$DEFINE RTL190_UP}
+      {$ELSE}
+        {$DEFINE RTL200_UP}
+      {$ENDIF}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF VER200}
 
-{$IFDEF BCB}
-{$DEFINE CPPBUILDER}
-{$DEFINE BCBCOMPILER}
-{$ELSE ~BCB}
-{$DEFINE DELPHI}
-{$DEFINE DELPHICOMPILER}
-{$ENDIF ~BCB}
+    {$IFDEF VER210} // RAD Studio 2010
+      {$DEFINE BDS}
+      {$DEFINE BDS7}
+      {$DEFINE COMPILER14}
+      {$IFDEF BCB}
+        {$DEFINE BCB14}
+      {$ELSE}
+        {$DEFINE DELPHI14}
+        {$DEFINE DELPHI2010} // synonym to DELPHI14
+        {$DEFINE DELPHICOMPILER14}
+      {$ENDIF BCB}
+      {$DEFINE RTL210_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF VER210}
 
+    {$IFDEF UNKNOWN_COMPILER_VERSION} // adjust for newer version (always use latest version)
+      {$DEFINE BDS}
+      {$DEFINE BDS7}
+      {$DEFINE COMPILER14}
+      {$IFDEF BCB}
+        {$DEFINE BCB14}
+      {$ELSE}
+        {$DEFINE DELPHI14}
+        {$DEFINE DELPHI2010} // synonym to DELPHI14
+        {$DEFINE DELPHICOMPILER14}
+      {$ENDIF BCB}
+      {$DEFINE RTL210_UP}
+      {$UNDEF UNKNOWN_COMPILER_VERSION}
+    {$ENDIF}
+
+  {$ENDIF ~KYLIX}
+
+  {$IFDEF BCB}
+    {$DEFINE CPPBUILDER}
+    {$DEFINE BCBCOMPILER}
+  {$ELSE ~BCB}
+    {$DEFINE DELPHI}
+    {$DEFINE DELPHICOMPILER}
+  {$ENDIF ~BCB}
+
 {$ENDIF BORLAND}
 
 {------------------------------------------------------------------------------}
 { DELPHIX_UP from DELPHIX mappings                                             }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHI11 }{$DEFINE DELPHI11_UP }{$ENDIF}
-{$IFDEF DELPHI10 }{$DEFINE DELPHI10_UP }{$ENDIF}
-{$IFDEF DELPHI9  }{$DEFINE DELPHI9_UP  }{$ENDIF}
-{$IFDEF DELPHI8  }{$DEFINE DELPHI8_UP  }{$ENDIF}
-{$IFDEF DELPHI7  }{$DEFINE DELPHI7_UP  }{$ENDIF}
-{$IFDEF DELPHI6  }{$DEFINE DELPHI6_UP  }{$ENDIF}
-{$IFDEF DELPHI5  }{$DEFINE DELPHI5_UP  }{$ENDIF}
-{$IFDEF DELPHI4  }{$DEFINE DELPHI4_UP  }{$ENDIF}
-{$IFDEF DELPHI3  }{$DEFINE DELPHI3_UP  }{$ENDIF}
-{$IFDEF DELPHI2  }{$DEFINE DELPHI2_UP  }{$ENDIF}
-{$IFDEF DELPHI1  }{$DEFINE DELPHI1_UP  }{$ENDIF}
+{$IFDEF DELPHI14} {$DEFINE DELPHI14_UP} {$ENDIF}
+{$IFDEF DELPHI12} {$DEFINE DELPHI12_UP} {$ENDIF}
+{$IFDEF DELPHI11} {$DEFINE DELPHI11_UP} {$ENDIF}
+{$IFDEF DELPHI10} {$DEFINE DELPHI10_UP} {$ENDIF}
+{$IFDEF DELPHI9}  {$DEFINE DELPHI9_UP}  {$ENDIF}
+{$IFDEF DELPHI8}  {$DEFINE DELPHI8_UP}  {$ENDIF}
+{$IFDEF DELPHI7}  {$DEFINE DELPHI7_UP}  {$ENDIF}
+{$IFDEF DELPHI6}  {$DEFINE DELPHI6_UP}  {$ENDIF}
+{$IFDEF DELPHI5}  {$DEFINE DELPHI5_UP}  {$ENDIF}
+{$IFDEF DELPHI4}  {$DEFINE DELPHI4_UP}  {$ENDIF}
+{$IFDEF DELPHI3}  {$DEFINE DELPHI3_UP}  {$ENDIF}
+{$IFDEF DELPHI2}  {$DEFINE DELPHI2_UP}  {$ENDIF}
+{$IFDEF DELPHI1}  {$DEFINE DELPHI1_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { DELPHIX_UP from DELPHIX_UP mappings                                          }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHI11_UP}{$DEFINE DELPHI10_UP }{$ENDIF}
-{$IFDEF DELPHI10_UP }{$DEFINE DELPHI9_UP  }{$ENDIF}
+{$IFDEF DELPHI14_UP}
+  {$DEFINE DELPHI2010_UP} // synonym to DELPHI14_UP
+  {$DEFINE DELPHI12_UP}
+{$ENDIF}
 
+{$IFDEF DELPHI12_UP}
+  {$DEFINE DELPHI2009_UP} // synonym to DELPHI12_UP
+  {$DEFINE DELPHI11_UP}
+{$ENDIF}
+
+{$IFDEF DELPHI11_UP}
+  {$DEFINE DELPHI2007_UP} // synonym to DELPHI11_UP
+  {$DEFINE DELPHI10_UP}
+{$ENDIF}
+
+{$IFDEF DELPHI10_UP}
+  {$DEFINE DELPHI2006_UP} // synonym to DELPHI10_UP
+  {$DEFINE DELPHI9_UP}
+{$ENDIF}
+
 {$IFDEF DELPHI9_UP}
-{$DEFINE DELPHI2005_UP} // synonym to DELPHI9_UP
-{$DEFINE DELPHI8_UP}
+  {$DEFINE DELPHI2005_UP} // synonym to DELPHI9_UP
+  {$DEFINE DELPHI8_UP}
 {$ENDIF}
 
-{$IFDEF DELPHI8_UP }{$DEFINE DELPHI7_UP }{$ENDIF}
-{$IFDEF DELPHI7_UP }{$DEFINE DELPHI6_UP }{$ENDIF}
-{$IFDEF DELPHI6_UP }{$DEFINE DELPHI5_UP }{$ENDIF}
-{$IFDEF DELPHI5_UP }{$DEFINE DELPHI4_UP }{$ENDIF}
-{$IFDEF DELPHI4_UP }{$DEFINE DELPHI3_UP }{$ENDIF}
-{$IFDEF DELPHI3_UP }{$DEFINE DELPHI2_UP }{$ENDIF}
-{$IFDEF DELPHI2_UP }{$DEFINE DELPHI1_UP }{$ENDIF}
+{$IFDEF DELPHI8_UP} {$DEFINE DELPHI7_UP} {$ENDIF}
+{$IFDEF DELPHI7_UP} {$DEFINE DELPHI6_UP} {$ENDIF}
+{$IFDEF DELPHI6_UP} {$DEFINE DELPHI5_UP} {$ENDIF}
+{$IFDEF DELPHI5_UP} {$DEFINE DELPHI4_UP} {$ENDIF}
+{$IFDEF DELPHI4_UP} {$DEFINE DELPHI3_UP} {$ENDIF}
+{$IFDEF DELPHI3_UP} {$DEFINE DELPHI2_UP} {$ENDIF}
+{$IFDEF DELPHI2_UP} {$DEFINE DELPHI1_UP} {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BCBX_UP from BCBX mappings                                                   }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BCB11}{$DEFINE BCB11_UP}{$ENDIF}
-{$IFDEF BCB10}{$DEFINE BCB10_UP}{$ENDIF}
-{$IFDEF BCB6 }{$DEFINE BCB6_UP }{$ENDIF}
-{$IFDEF BCB5 }{$DEFINE BCB5_UP }{$ENDIF}
-{$IFDEF BCB4 }{$DEFINE BCB4_UP }{$ENDIF}
-{$IFDEF BCB3 }{$DEFINE BCB3_UP }{$ENDIF}
-{$IFDEF BCB1 }{$DEFINE BCB1_UP }{$ENDIF}
+{$IFDEF BCB14} {$DEFINE BCB14_UP} {$ENDIF}
+{$IFDEF BCB12} {$DEFINE BCB12_UP} {$ENDIF}
+{$IFDEF BCB11} {$DEFINE BCB11_UP} {$ENDIF}
+{$IFDEF BCB10} {$DEFINE BCB10_UP} {$ENDIF}
+{$IFDEF BCB6}  {$DEFINE BCB6_UP}  {$ENDIF}
+{$IFDEF BCB5}  {$DEFINE BCB5_UP}  {$ENDIF}
+{$IFDEF BCB4}  {$DEFINE BCB4_UP}  {$ENDIF}
+{$IFDEF BCB3}  {$DEFINE BCB3_UP}  {$ENDIF}
+{$IFDEF BCB1}  {$DEFINE BCB1_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BCBX_UP from BCBX_UP mappings                                                }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BCB11_UP}{$DEFINE BCB10_UP}{$ENDIF}
-{$IFDEF BCB10_UP}{$DEFINE BCB6_UP }{$ENDIF}
-{$IFDEF BCB6_UP }{$DEFINE BCB5_UP }{$ENDIF}
-{$IFDEF BCB5_UP }{$DEFINE BCB4_UP }{$ENDIF}
-{$IFDEF BCB4_UP }{$DEFINE BCB3_UP }{$ENDIF}
-{$IFDEF BCB3_UP }{$DEFINE BCB1_UP }{$ENDIF}
+{$IFDEF BCB14_UP} {$DEFINE BCB12_UP} {$ENDIF}
+{$IFDEF BCB12_UP} {$DEFINE BCB11_UP} {$ENDIF}
+{$IFDEF BCB11_UP} {$DEFINE BCB10_UP} {$ENDIF}
+{$IFDEF BCB10_UP} {$DEFINE BCB6_UP}  {$ENDIF}
+{$IFDEF BCB6_UP}  {$DEFINE BCB5_UP}  {$ENDIF}
+{$IFDEF BCB5_UP}  {$DEFINE BCB4_UP}  {$ENDIF}
+{$IFDEF BCB4_UP}  {$DEFINE BCB3_UP}  {$ENDIF}
+{$IFDEF BCB3_UP}  {$DEFINE BCB1_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BDSX_UP from BDSX mappings                                                   }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BDS5 }{$DEFINE BDS5_UP }{$ENDIF}
-{$IFDEF BDS4 }{$DEFINE BDS4_UP }{$ENDIF}
-{$IFDEF BDS3 }{$DEFINE BDS3_UP }{$ENDIF}
-{$IFDEF BDS2 }{$DEFINE BDS2_UP }{$ENDIF}
+{$IFDEF BDS7} {$DEFINE BDS7_UP} {$ENDIF}
+{$IFDEF BDS6} {$DEFINE BDS6_UP} {$ENDIF}
+{$IFDEF BDS5} {$DEFINE BDS5_UP} {$ENDIF}
+{$IFDEF BDS4} {$DEFINE BDS4_UP} {$ENDIF}
+{$IFDEF BDS3} {$DEFINE BDS3_UP} {$ENDIF}
+{$IFDEF BDS2} {$DEFINE BDS2_UP} {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { BDSX_UP from BDSX_UP mappings                                                }
 {------------------------------------------------------------------------------}
 
-{$IFDEF BDS5_UP }{$DEFINE BDS4_UP }{$ENDIF}
-{$IFDEF BDS4_UP }{$DEFINE BDS3_UP }{$ENDIF}
-{$IFDEF BDS3_UP }{$DEFINE BDS2_UP }{$ENDIF}
+{$IFDEF BDS7_UP} {$DEFINE BDS6_UP} {$ENDIF}
+{$IFDEF BDS6_UP} {$DEFINE BDS5_UP} {$ENDIF}
+{$IFDEF BDS5_UP} {$DEFINE BDS4_UP} {$ENDIF}
+{$IFDEF BDS4_UP} {$DEFINE BDS3_UP} {$ENDIF}
+{$IFDEF BDS3_UP} {$DEFINE BDS2_UP} {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { DELPHICOMPILERX_UP from DELPHICOMPILERX mappings                             }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHICOMPILER11 }{$DEFINE DELPHICOMPILER11_UP }{$ENDIF}
-{$IFDEF DELPHICOMPILER10 }{$DEFINE DELPHICOMPILER10_UP }{$ENDIF}
-{$IFDEF DELPHICOMPILER9  }{$DEFINE DELPHICOMPILER9_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER8  }{$DEFINE DELPHICOMPILER8_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER7  }{$DEFINE DELPHICOMPILER7_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER6  }{$DEFINE DELPHICOMPILER6_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER5  }{$DEFINE DELPHICOMPILER5_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER4  }{$DEFINE DELPHICOMPILER4_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER3  }{$DEFINE DELPHICOMPILER3_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER2  }{$DEFINE DELPHICOMPILER2_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER1  }{$DEFINE DELPHICOMPILER1_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER14} {$DEFINE DELPHICOMPILER14_UP} {$ENDIF}
+{$IFDEF DELPHICOMPILER12} {$DEFINE DELPHICOMPILER12_UP} {$ENDIF}
+{$IFDEF DELPHICOMPILER11} {$DEFINE DELPHICOMPILER11_UP} {$ENDIF}
+{$IFDEF DELPHICOMPILER10} {$DEFINE DELPHICOMPILER10_UP} {$ENDIF}
+{$IFDEF DELPHICOMPILER9}  {$DEFINE DELPHICOMPILER9_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER8}  {$DEFINE DELPHICOMPILER8_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER7}  {$DEFINE DELPHICOMPILER7_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER6}  {$DEFINE DELPHICOMPILER6_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER5}  {$DEFINE DELPHICOMPILER5_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER4}  {$DEFINE DELPHICOMPILER4_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER3}  {$DEFINE DELPHICOMPILER3_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER2}  {$DEFINE DELPHICOMPILER2_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER1}  {$DEFINE DELPHICOMPILER1_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { DELPHICOMPILERX_UP from DELPHICOMPILERX_UP mappings                          }
 {------------------------------------------------------------------------------}
 
-{$IFDEF DELPHICOMPILER11_UP }{$DEFINE DELPHICOMPILER10_UP }{$ENDIF}
-{$IFDEF DELPHICOMPILER10_UP }{$DEFINE DELPHICOMPILER9_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER9_UP  }{$DEFINE DELPHICOMPILER8_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER8_UP  }{$DEFINE DELPHICOMPILER7_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER8_UP  }{$DEFINE DELPHICOMPILER7_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER7_UP  }{$DEFINE DELPHICOMPILER6_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER6_UP  }{$DEFINE DELPHICOMPILER5_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER5_UP  }{$DEFINE DELPHICOMPILER4_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER4_UP  }{$DEFINE DELPHICOMPILER3_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER3_UP  }{$DEFINE DELPHICOMPILER2_UP  }{$ENDIF}
-{$IFDEF DELPHICOMPILER2_UP  }{$DEFINE DELPHICOMPILER1_UP  }{$ENDIF}
+{$IFDEF DELPHICOMPILER14_UP} {$DEFINE DELPHICOMPILER12_UP} {$ENDIF}
+{$IFDEF DELPHICOMPILER12_UP} {$DEFINE DELPHICOMPILER11_UP} {$ENDIF}
+{$IFDEF DELPHICOMPILER11_UP} {$DEFINE DELPHICOMPILER10_UP} {$ENDIF}
+{$IFDEF DELPHICOMPILER10_UP} {$DEFINE DELPHICOMPILER9_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER9_UP}  {$DEFINE DELPHICOMPILER8_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER8_UP}  {$DEFINE DELPHICOMPILER7_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER8_UP}  {$DEFINE DELPHICOMPILER7_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER7_UP}  {$DEFINE DELPHICOMPILER6_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER6_UP}  {$DEFINE DELPHICOMPILER5_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER5_UP}  {$DEFINE DELPHICOMPILER4_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER4_UP}  {$DEFINE DELPHICOMPILER3_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER3_UP}  {$DEFINE DELPHICOMPILER2_UP}  {$ENDIF}
+{$IFDEF DELPHICOMPILER2_UP}  {$DEFINE DELPHICOMPILER1_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { COMPILERX_UP from COMPILERX mappings                                         }
 {------------------------------------------------------------------------------}
 
-{$IFDEF COMPILER11 }{$DEFINE COMPILER11_UP }{$ENDIF}
-{$IFDEF COMPILER10 }{$DEFINE COMPILER10_UP }{$ENDIF}
-{$IFDEF COMPILER9  }{$DEFINE COMPILER9_UP  }{$ENDIF}
-{$IFDEF COMPILER8  }{$DEFINE COMPILER8_UP  }{$ENDIF}
-{$IFDEF COMPILER7  }{$DEFINE COMPILER7_UP  }{$ENDIF}
-{$IFDEF COMPILER6  }{$DEFINE COMPILER6_UP  }{$ENDIF}
-{$IFDEF COMPILER5  }{$DEFINE COMPILER5_UP  }{$ENDIF}
-{$IFDEF COMPILER4  }{$DEFINE COMPILER4_UP  }{$ENDIF}
-{$IFDEF COMPILER35 }{$DEFINE COMPILER35_UP }{$ENDIF}
-{$IFDEF COMPILER3  }{$DEFINE COMPILER3_UP  }{$ENDIF}
-{$IFDEF COMPILER2  }{$DEFINE COMPILER2_UP  }{$ENDIF}
-{$IFDEF COMPILER1  }{$DEFINE COMPILER1_UP  }{$ENDIF}
+{$IFDEF COMPILER14} {$DEFINE COMPILER14_UP} {$ENDIF}
+{$IFDEF COMPILER12} {$DEFINE COMPILER12_UP} {$ENDIF}
+{$IFDEF COMPILER11} {$DEFINE COMPILER11_UP} {$ENDIF}
+{$IFDEF COMPILER10} {$DEFINE COMPILER10_UP} {$ENDIF}
+{$IFDEF COMPILER9}  {$DEFINE COMPILER9_UP}  {$ENDIF}
+{$IFDEF COMPILER8}  {$DEFINE COMPILER8_UP}  {$ENDIF}
+{$IFDEF COMPILER7}  {$DEFINE COMPILER7_UP}  {$ENDIF}
+{$IFDEF COMPILER6}  {$DEFINE COMPILER6_UP}  {$ENDIF}
+{$IFDEF COMPILER5}  {$DEFINE COMPILER5_UP}  {$ENDIF}
+{$IFDEF COMPILER4}  {$DEFINE COMPILER4_UP}  {$ENDIF}
+{$IFDEF COMPILER35} {$DEFINE COMPILER35_UP} {$ENDIF}
+{$IFDEF COMPILER3}  {$DEFINE COMPILER3_UP}  {$ENDIF}
+{$IFDEF COMPILER2}  {$DEFINE COMPILER2_UP}  {$ENDIF}
+{$IFDEF COMPILER1}  {$DEFINE COMPILER1_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { COMPILERX_UP from COMPILERX_UP mappings                                      }
 {------------------------------------------------------------------------------}
 
-{$IFDEF COMPILER11_UP }{$DEFINE COMPILER10_UP}{$ENDIF}
-{$IFDEF COMPILER10_UP }{$DEFINE COMPILER9_UP }{$ENDIF}
-{$IFDEF COMPILER9_UP  }{$DEFINE COMPILER8_UP }{$ENDIF}
-{$IFDEF COMPILER8_UP  }{$DEFINE COMPILER7_UP }{$ENDIF}
-{$IFDEF COMPILER7_UP  }{$DEFINE COMPILER6_UP }{$ENDIF}
-{$IFDEF COMPILER6_UP  }{$DEFINE COMPILER5_UP }{$ENDIF}
-{$IFDEF COMPILER5_UP  }{$DEFINE COMPILER4_UP }{$ENDIF}
-{$IFDEF COMPILER4_UP  }{$DEFINE COMPILER35_UP}{$ENDIF}
-{$IFDEF COMPILER35_UP }{$DEFINE COMPILER3_UP }{$ENDIF}
-{$IFDEF COMPILER3_UP  }{$DEFINE COMPILER2_UP }{$ENDIF}
-{$IFDEF COMPILER2_UP  }{$DEFINE COMPILER1_UP }{$ENDIF}
+{$IFDEF COMPILER14_UP} {$DEFINE COMPILER12_UP} {$ENDIF}
+{$IFDEF COMPILER12_UP} {$DEFINE COMPILER11_UP} {$ENDIF}
+{$IFDEF COMPILER11_UP} {$DEFINE COMPILER10_UP} {$ENDIF}
+{$IFDEF COMPILER10_UP} {$DEFINE COMPILER9_UP}  {$ENDIF}
+{$IFDEF COMPILER9_UP}  {$DEFINE COMPILER8_UP}  {$ENDIF}
+{$IFDEF COMPILER8_UP}  {$DEFINE COMPILER7_UP}  {$ENDIF}
+{$IFDEF COMPILER7_UP}  {$DEFINE COMPILER6_UP}  {$ENDIF}
+{$IFDEF COMPILER6_UP}  {$DEFINE COMPILER5_UP}  {$ENDIF}
+{$IFDEF COMPILER5_UP}  {$DEFINE COMPILER4_UP}  {$ENDIF}
+{$IFDEF COMPILER4_UP}  {$DEFINE COMPILER35_UP} {$ENDIF}
+{$IFDEF COMPILER35_UP} {$DEFINE COMPILER3_UP}  {$ENDIF}
+{$IFDEF COMPILER3_UP}  {$DEFINE COMPILER2_UP}  {$ENDIF}
+{$IFDEF COMPILER2_UP}  {$DEFINE COMPILER1_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { RTLX_UP from RTLX_UP mappings                                                }
 {------------------------------------------------------------------------------}
 
-{$IFDEF RTL185_UP}{$DEFINE RTL180_UP}{$ENDIF}
-{$IFDEF RTL180_UP}{$DEFINE RTL170_UP}{$ENDIF}
-{$IFDEF RTL170_UP}{$DEFINE RTL160_UP}{$ENDIF}
-{$IFDEF RTL160_UP}{$DEFINE RTL150_UP}{$ENDIF}
-{$IFDEF RTL150_UP}{$DEFINE RTL145_UP}{$ENDIF}
-{$IFDEF RTL145_UP}{$DEFINE RTL142_UP}{$ENDIF}
-{$IFDEF RTL142_UP}{$DEFINE RTL140_UP}{$ENDIF}
-{$IFDEF RTL140_UP}{$DEFINE RTL130_UP}{$ENDIF}
-{$IFDEF RTL130_UP}{$DEFINE RTL125_UP}{$ENDIF}
-{$IFDEF RTL125_UP}{$DEFINE RTL120_UP}{$ENDIF}
-{$IFDEF RTL120_UP}{$DEFINE RTL110_UP}{$ENDIF}
-{$IFDEF RTL110_UP}{$DEFINE RTL100_UP}{$ENDIF}
-{$IFDEF RTL100_UP}{$DEFINE RTL93_UP }{$ENDIF}
-{$IFDEF RTL93_UP }{$DEFINE RTL90_UP }{$ENDIF}
-{$IFDEF RTL90_UP }{$DEFINE RTL80_UP }{$ENDIF}
+{$IFDEF RTL210_UP} {$DEFINE RTL200_UP} {$ENDIF}
+{$IFDEF RTL200_UP} {$DEFINE RTL190_UP} {$ENDIF}
+{$IFDEF RTL190_UP} {$DEFINE RTL185_UP} {$ENDIF}
+{$IFDEF RTL185_UP} {$DEFINE RTL180_UP} {$ENDIF}
+{$IFDEF RTL180_UP} {$DEFINE RTL170_UP} {$ENDIF}
+{$IFDEF RTL170_UP} {$DEFINE RTL160_UP} {$ENDIF}
+{$IFDEF RTL160_UP} {$DEFINE RTL150_UP} {$ENDIF}
+{$IFDEF RTL150_UP} {$DEFINE RTL145_UP} {$ENDIF}
+{$IFDEF RTL145_UP} {$DEFINE RTL142_UP} {$ENDIF}
+{$IFDEF RTL142_UP} {$DEFINE RTL140_UP} {$ENDIF}
+{$IFDEF RTL140_UP} {$DEFINE RTL130_UP} {$ENDIF}
+{$IFDEF RTL130_UP} {$DEFINE RTL125_UP} {$ENDIF}
+{$IFDEF RTL125_UP} {$DEFINE RTL120_UP} {$ENDIF}
+{$IFDEF RTL120_UP} {$DEFINE RTL110_UP} {$ENDIF}
+{$IFDEF RTL110_UP} {$DEFINE RTL100_UP} {$ENDIF}
+{$IFDEF RTL100_UP} {$DEFINE RTL93_UP}  {$ENDIF}
+{$IFDEF RTL93_UP}  {$DEFINE RTL90_UP}  {$ENDIF}
+{$IFDEF RTL90_UP}  {$DEFINE RTL80_UP}  {$ENDIF}
 
 {------------------------------------------------------------------------------}
+{ Check for CLR overrides of default detection                                 }
+{------------------------------------------------------------------------------}
 
+{$IFDEF CLR}
+  {$IFDEF FORCE_CLR10}
+    {$DEFINE CLR10}
+    {$UNDEF CLR11}
+    {$UNDEF CLR20}
+  {$ENDIF FORCE_CLR10}
+
+  {$IFDEF FORCE_CLR11}
+    {$UNDEF CLR10}
+    {$DEFINE CLR11}
+    {$UNDEF CLR20}
+  {$ENDIF FORCE_CLR11}
+
+  {$IFDEF FORCE_CLR20}
+    {$UNDEF CLR10}
+    {$UNDEF CLR11}
+    {$DEFINE CLR20}
+  {$ENDIF FORCE_CLR20}
+{$ENDIF CLR}
+
+{------------------------------------------------------------------------------}
+{ CLRX from CLRX_UP mappings                                                   }
+{------------------------------------------------------------------------------}
+
+{$IFDEF CLR10} {$DEFINE CLR10_UP} {$ENDIF}
+{$IFDEF CLR11} {$DEFINE CLR11_UP} {$ENDIF}
+{$IFDEF CLR20} {$DEFINE CLR20_UP} {$ENDIF}
+
+{------------------------------------------------------------------------------}
+{ CLRX_UP from CLRX_UP mappings                                                }
+{------------------------------------------------------------------------------}
+
+{$IFDEF CLR20_UP} {$DEFINE CLR11_UP} {$ENDIF}
+{$IFDEF CLR11_UP} {$DEFINE CLR10_UP} {$ENDIF}
+
+{------------------------------------------------------------------------------}
+
 {$IFDEF DELPHICOMPILER}
-{$DEFINE DELPHILANGUAGE}
+  {$DEFINE DELPHILANGUAGE}
 {$ENDIF}
 
 {$IFDEF BCBCOMPILER}
-{$DEFINE DELPHILANGUAGE}
+  {$DEFINE DELPHILANGUAGE}
 {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { KYLIXX_UP from KYLIXX mappings                                               }
 {------------------------------------------------------------------------------}
 
-{$IFDEF KYLIX3}
-{$DEFINE KYLIX3_UP}
-{$DEFINE KYLIX2_UP}
-{$DEFINE KYLIX1_UP}
-{$ENDIF}
+{$IFDEF KYLIX3} {$DEFINE KYLIX3_UP} {$ENDIF}
+{$IFDEF KYLIX2} {$DEFINE KYLIX2_UP} {$ENDIF}
+{$IFDEF KYLIX1} {$DEFINE KYLIX1_UP} {$ENDIF}
 
-{$IFDEF KYLIX2}
-{$DEFINE KYLIX2_UP}
-{$DEFINE KYLIX1_UP}
-{$ENDIF}
+{------------------------------------------------------------------------------}
+{ KYLIXX_UP from KYLIXX_UP mappings                                            }
+{------------------------------------------------------------------------------}
 
-{$IFDEF KYLIX1}
-{$DEFINE KYLIX1_UP}
-{$ENDIF}
+{$IFDEF KYLIX3_UP} {$DEFINE KYLIX2_UP} {$ENDIF}
+{$IFDEF KYLIX2_UP} {$DEFINE KYLIX1_UP} {$ENDIF}
 
 {------------------------------------------------------------------------------}
 { Map COMPILERX_UP to friendly feature names                                   }
 {------------------------------------------------------------------------------}
 
 {$IFDEF FPC}
-{$IFDEF  VER1_0}
-Please use FPC 2.0 or later to compile this.
-{$ELSE}
-{$DEFINE SUPPORTS_OUTPARAMS}
-{$DEFINE SUPPORTS_WIDECHAR}
-{$DEFINE SUPPORTS_WIDESTRING}
-{$IFDEF HASINTF}
-{$DEFINE SUPPORTS_INTERFACE}
-{$ENDIF}
-{$IFDEF HASVARIANT}
-{$DEFINE SUPPORTS_VARIANT}
-{$ENDIF}
-{$IFDEF FPC_HAS_TYPE_SINGLE}
-{$DEFINE SUPPORTS_SINGLE}
-{$ENDIF}
-{$IFDEF FPC_HAS_TYPE_DOUBLE}
-{$DEFINE SUPPORTS_DOUBLE}
-{$ENDIF}
-{$IFDEF FPC_HAS_TYPE_EXTENDED}
-{$DEFINE SUPPORTS_EXTENDED}
-{$ENDIF}
-{$IFDEF HASCURRENCY}
-{$DEFINE SUPPORTS_CURRENCY}
-{$ENDIF}
-{$DEFINE SUPPORTS_THREADVAR}
-{$DEFINE SUPPORTS_CONSTPARAMS}
-{$DEFINE SUPPORTS_LONGWORD}
-{$DEFINE SUPPORTS_INT64}
-{$DEFINE SUPPORTS_DYNAMICARRAYS}
-{$DEFINE SUPPORTS_DEFAULTPARAMS}
-{$DEFINE SUPPORTS_OVERLOAD}
-{$DEFINE ACCEPT_DEPRECATED}
-{$DEFINE ACCEPT_PLATFORM}
-{$DEFINE ACCEPT_LIBRARY}
-{$DEFINE SUPPORTS_EXTSYM}
-{$DEFINE SUPPORTS_NODEFINE}
+  {$IFDEF  VER1_0}
+     Please use FPC 2.0 or higher to compile this.
+  {$ELSE}
+    {$DEFINE SUPPORTS_OUTPARAMS}
+    {$DEFINE SUPPORTS_WIDECHAR}
+    {$DEFINE SUPPORTS_WIDESTRING}
+    {$IFDEF HASINTF}
+      {$DEFINE SUPPORTS_INTERFACE}
+    {$ENDIF}
+    {$IFDEF HASVARIANT}
+      {$DEFINE SUPPORTS_VARIANT}
+    {$ENDIF}
+    {$IFDEF FPC_HAS_TYPE_SINGLE}
+      {$DEFINE SUPPORTS_SINGLE}
+    {$ENDIF}
+    {$IFDEF FPC_HAS_TYPE_DOUBLE}
+      {$DEFINE SUPPORTS_DOUBLE}
+    {$ENDIF}
+    {$IFDEF FPC_HAS_TYPE_EXTENDED}
+      {$DEFINE SUPPORTS_EXTENDED}
+    {$ENDIF}
+    {$IFDEF HASCURRENCY}
+      {$DEFINE SUPPORTS_CURRENCY}
+    {$ENDIF}
+    {$DEFINE SUPPORTS_THREADVAR}
+    {$DEFINE SUPPORTS_CONSTPARAMS}
+    {$DEFINE SUPPORTS_LONGWORD}
+    {$DEFINE SUPPORTS_INT64}
+    {$DEFINE SUPPORTS_DYNAMICARRAYS}
+    {$DEFINE SUPPORTS_DEFAULTPARAMS}
+    {$DEFINE SUPPORTS_OVERLOAD}
+    {$DEFINE ACCEPT_DEPRECATED}  // 2.2 also gives warnings
+    {$DEFINE ACCEPT_PLATFORM}    // 2.2 also gives warnings
+    {$DEFINE ACCEPT_LIBRARY}
+    {$DEFINE SUPPORTS_EXTSYM}
+    {$DEFINE SUPPORTS_NODEFINE}
 
-{$DEFINE SUPPORTS_CUSTOMVARIANTS}
-{$DEFINE SUPPORTS_VARARGS}
-{$DEFINE SUPPORTS_ENUMVALUE}
-{$IFDEF LINUX}
-{$DEFINE HAS_UNIT_LIBC}
-{$ENDIF LINUX}
-{$DEFINE HAS_UNIT_TYPES}
-{$DEFINE HAS_UNIT_VARIANTS}
-{$DEFINE HAS_UNIT_STRUTILS}
-{$DEFINE HAS_UNIT_RTLCONSTS}
+    {$DEFINE SUPPORTS_CUSTOMVARIANTS}
+    {$DEFINE SUPPORTS_VARARGS}
+    {$DEFINE SUPPORTS_ENUMVALUE}
+    {$IFDEF LINUX}
+      {$DEFINE HAS_UNIT_LIBC}
+    {$ENDIF LINUX}
+    {$DEFINE HAS_UNIT_CONTNRS}
+    {$DEFINE HAS_UNIT_TYPES}
+    {$DEFINE HAS_UNIT_VARIANTS}
+    {$DEFINE HAS_UNIT_STRUTILS}
+    {$DEFINE HAS_UNIT_DATEUTILS}
+    {$DEFINE HAS_UNIT_RTLCONSTS}
 
-{$DEFINE XPLATFORM_RTL}
+    {$DEFINE XPLATFORM_RTL}
 
-{$UNDEF SUPPORTS_DISPINTERFACE}
-{$UNDEF SUPPORTS_IMPLEMENTS}
-{$UNDEF SUPPORTS_UNSAFE_WARNINGS}
-{$ENDIF}
+    {$IFDEF VER2_2}
+      {$DEFINE SUPPORTS_DISPINTERFACE}
+      {$DEFINE SUPPORTS_IMPLEMENTS}
+      {$DEFINE SUPPORTS_DISPID}
+    {$ELSE}
+      {$UNDEF SUPPORTS_DISPINTERFACE}
+      {$UNDEF SUPPORTS_IMPLEMENTS}
+    {$endif}
+    {$UNDEF SUPPORTS_UNSAFE_WARNINGS}
+  {$ENDIF}
 {$ENDIF FPC}
 
+{$IFDEF CLR}
+  {$DEFINE SUPPORTS_UNICODE}
+{$ENDIF CLR}
+
 {$IFDEF COMPILER1_UP}
-{$DEFINE SUPPORTS_CONSTPARAMS}
-{$DEFINE SUPPORTS_SINGLE}
-{$DEFINE SUPPORTS_DOUBLE}
-{$DEFINE SUPPORTS_EXTENDED}
+  {$DEFINE SUPPORTS_CONSTPARAMS}
+  {$DEFINE SUPPORTS_SINGLE}
+  {$DEFINE SUPPORTS_DOUBLE}
+  {$DEFINE SUPPORTS_EXTENDED}
+  {$DEFINE SUPPORTS_PACKAGES} 
 {$ENDIF COMPILER1_UP}
 
 {$IFDEF COMPILER2_UP}
-{$DEFINE SUPPORTS_CURRENCY}
-{$DEFINE SUPPORTS_THREADVAR}
-{$DEFINE SUPPORTS_VARIANT}
-{$DEFINE SUPPORTS_WIDECHAR}
+  {$DEFINE SUPPORTS_CURRENCY}
+  {$DEFINE SUPPORTS_THREADVAR}
+  {$DEFINE SUPPORTS_VARIANT}
+  {$DEFINE SUPPORTS_WIDECHAR}
 {$ENDIF COMPILER2_UP}
 
 {$IFDEF COMPILER3_UP}
-{$DEFINE SUPPORTS_OUTPARAMS}
-{$DEFINE SUPPORTS_WIDESTRING}
-{$DEFINE SUPPORTS_INTERFACE}
-{$DEFINE SUPPORTS_DISPINTERFACE}
-{$DEFINE SUPPORTS_DISPID}
-{$DEFINE SUPPORTS_WEAKPACKAGEUNIT}
+  {$DEFINE SUPPORTS_OUTPARAMS}
+  {$DEFINE SUPPORTS_WIDESTRING}
+  {$DEFINE SUPPORTS_INTERFACE}
+  {$DEFINE SUPPORTS_DISPINTERFACE}
+  {$DEFINE SUPPORTS_DISPID}
+  {$DEFINE SUPPORTS_WEAKPACKAGEUNIT}
 {$ENDIF COMPILER3_UP}
 
 {$IFDEF COMPILER35_UP}
-{$DEFINE SUPPORTS_EXTSYM}
-{$DEFINE SUPPORTS_NODEFINE}
+  {$DEFINE SUPPORTS_EXTSYM}
+  {$DEFINE SUPPORTS_NODEFINE}
 {$ENDIF COMPILER35_UP}
 
 {$IFDEF COMPILER4_UP}
-{$DEFINE SUPPORTS_LONGWORD}
-{$DEFINE SUPPORTS_INT64}
-{$DEFINE SUPPORTS_DYNAMICARRAYS}
-{$DEFINE SUPPORTS_DEFAULTPARAMS}
-{$DEFINE SUPPORTS_OVERLOAD}
-{$DEFINE SUPPORTS_IMPLEMENTS}
+  {$DEFINE SUPPORTS_LONGWORD}
+  {$DEFINE SUPPORTS_INT64}
+  {$DEFINE SUPPORTS_DYNAMICARRAYS}
+  {$DEFINE SUPPORTS_DEFAULTPARAMS}
+  {$DEFINE SUPPORTS_OVERLOAD}
+  {$DEFINE SUPPORTS_IMPLEMENTS}
 {$ENDIF COMPILER4_UP}
 
 {$IFDEF COMPILER6_UP}
-{$DEFINE SUPPORTS_DEPRECATED}
-{$DEFINE SUPPORTS_LIBRARY}
-{$DEFINE SUPPORTS_PLATFORM}
-{$DEFINE SUPPORTS_LOCAL}
-{$DEFINE ACCEPT_DEPRECATED}
-{$DEFINE ACCEPT_PLATFORM}
-{$DEFINE ACCEPT_LIBRARY}
-{$DEFINE SUPPORTS_DEPRECATED_WARNINGS}
-{$DEFINE SUPPORTS_LIBRARY_WARNINGS}
-{$DEFINE SUPPORTS_PLATFORM_WARNINGS}
-{$DEFINE SUPPORTS_CUSTOMVARIANTS}
-{$DEFINE SUPPORTS_VARARGS}
-{$DEFINE SUPPORTS_ENUMVALUE}
-{$DEFINE SUPPORTS_COMPILETIME_MESSAGES}
+  {$DEFINE SUPPORTS_DEPRECATED}
+  {$DEFINE SUPPORTS_LIBRARY}
+  {$DEFINE SUPPORTS_PLATFORM}
+  {$DEFINE SUPPORTS_LOCAL}
+  {$DEFINE SUPPORTS_SETPEFLAGS}
+  {$DEFINE SUPPORTS_EXPERIMENTAL_WARNINGS}
+  {$DEFINE ACCEPT_DEPRECATED}
+  {$DEFINE ACCEPT_PLATFORM}
+  {$DEFINE ACCEPT_LIBRARY}
+  {$DEFINE SUPPORTS_DEPRECATED_WARNINGS}
+  {$DEFINE SUPPORTS_LIBRARY_WARNINGS}
+  {$DEFINE SUPPORTS_PLATFORM_WARNINGS}
+  {$DEFINE SUPPORTS_CUSTOMVARIANTS}
+  {$DEFINE SUPPORTS_VARARGS}
+  {$DEFINE SUPPORTS_ENUMVALUE}
+  {$DEFINE SUPPORTS_COMPILETIME_MESSAGES}
 {$ENDIF COMPILER6_UP}
 
 {$IFDEF COMPILER7_UP}
-{$DEFINE SUPPORTS_UNSAFE_WARNINGS}
+  {$DEFINE SUPPORTS_UNSAFE_WARNINGS}
 {$ENDIF COMPILER7_UP}
 
 {$IFDEF COMPILER9_UP}
-{$DEFINE SUPPORTS_FOR_IN}
-{$DEFINE SUPPORTS_INLINE}
-{$DEFINE SUPPORTS_NESTED_CONSTANTS}
-{$DEFINE SUPPORTS_NESTED_TYPES}
-{$IFDEF CLR}
-{$DEFINE SUPPORTS_ENHANCED_RECORDS}
-{$DEFINE SUPPORTS_CLASS_FIELDS}
-{$DEFINE SUPPORTS_CLASS_HELPERS}
-{$DEFINE SUPPORTS_CLASS_OPERATORS}
-{$DEFINE SUPPORTS_STRICT}
-{$DEFINE SUPPORTS_STATIC}
-{$DEFINE SUPPORTS_FINAL}
-{$ENDIF CLR}
+  {$DEFINE SUPPORTS_FOR_IN}
+  {$DEFINE SUPPORTS_INLINE}
+  {$DEFINE SUPPORTS_NESTED_CONSTANTS}
+  {$DEFINE SUPPORTS_NESTED_TYPES}
+  {$DEFINE SUPPORTS_REGION}
+  {$IFDEF CLR}
+    {$DEFINE SUPPORTS_ENHANCED_RECORDS}
+    {$DEFINE SUPPORTS_CLASS_FIELDS}
+    {$DEFINE SUPPORTS_CLASS_HELPERS}
+    {$DEFINE SUPPORTS_CLASS_OPERATORS}
+    {$DEFINE SUPPORTS_STRICT}
+    {$DEFINE SUPPORTS_STATIC}
+    {$DEFINE SUPPORTS_FINAL}
+  {$ENDIF CLR}
 {$ENDIF COMPILER9_UP}
 
 {$IFDEF COMPILER10_UP}
-{$DEFINE SUPPORTS_ENHANCED_RECORDS}
-{$DEFINE SUPPORTS_CLASS_FIELDS}
-{$DEFINE SUPPORTS_CLASS_HELPERS}
-{$DEFINE SUPPORTS_CLASS_OPERATORS}
-{$DEFINE SUPPORTS_STRICT}
-{$DEFINE SUPPORTS_STATIC}
-{$DEFINE SUPPORTS_FINAL}
+  {$DEFINE SUPPORTS_ENHANCED_RECORDS}
+  {$DEFINE SUPPORTS_CLASS_FIELDS}
+  {$DEFINE SUPPORTS_CLASS_HELPERS}
+  {$DEFINE SUPPORTS_CLASS_OPERATORS}
+  {$DEFINE SUPPORTS_STRICT}
+  {$DEFINE SUPPORTS_STATIC}
+  {$DEFINE SUPPORTS_FINAL}
+  {$DEFINE SUPPORTS_METHODINFO}
 {$ENDIF COMPILER10_UP}
 
+{$IFDEF COMPILER11_UP}
+  {$IFDEF CLR}
+    {$DEFINE SUPPORTS_GENERICS}
+    {$DEFINE SUPPORTS_DEPRECATED_DETAILS}
+  {$ENDIF CLR}
+{$ENDIF COMPILER11_UP}
+
+{$IFDEF COMPILER12_UP}
+  {$DEFINE SUPPORTS_GENERICS}
+  {$DEFINE SUPPORTS_DEPRECATED_DETAILS}
+  {$IFNDEF CLR}
+    {$DEFINE SUPPORTS_UNICODE}
+    {$DEFINE SUPPORTS_UNICODE_STRING}
+  {$ENDIF  CLR}
+{$ENDIF COMPILER12_UP}
+
+{$IFDEF RTL130_UP}
+  {$DEFINE HAS_UNIT_CONTNRS}
+{$ENDIF RTL130_UP}
+
 {$IFDEF RTL140_UP}
-{$IFDEF LINUX}
-{$DEFINE HAS_UNIT_LIBC}
-{$ENDIF LINUX}
-{$DEFINE HAS_UNIT_RTLCONSTS}
-{$DEFINE HAS_UNIT_TYPES}
-{$DEFINE HAS_UNIT_VARIANTS}
-{$DEFINE HAS_UNIT_STRUTILS}
-{$DEFINE XPLATFORM_RTL}
+  {$IFDEF LINUX}
+    {$DEFINE HAS_UNIT_LIBC}
+  {$ENDIF LINUX}
+  {$DEFINE HAS_UNIT_RTLCONSTS}
+  {$DEFINE HAS_UNIT_TYPES}
+  {$DEFINE HAS_UNIT_VARIANTS}
+  {$DEFINE HAS_UNIT_STRUTILS}
+  {$DEFINE HAS_UNIT_DATEUTILS}
+  {$DEFINE XPLATFORM_RTL}
 {$ENDIF RTL140_UP}
 
+{$IFDEF RTL170_UP}
+  {$DEFINE HAS_UNIT_HTTPPROD}
+{$ENDIF RTL170_UP}
+
+{$IFDEF RTL200_UP}
+  {$DEFINE HAS_UNIT_ANSISTRINGS}
+  {$DEFINE HAS_UNIT_PNGIMAGE}
+{$ENDIF RTL200_UP}
+
 {------------------------------------------------------------------------------}
 { Cross-platform related defines                                               }
 {------------------------------------------------------------------------------}
 
-{$IFNDEF CPU386}
-{$DEFINE PUREPASCAL}
-{$ENDIF}
+{$IFNDEF CPUASM}
+  {$DEFINE PUREPASCAL}
+{$ENDIF ~CPUASM}
 
 {$IFDEF WIN32}
-{$DEFINE MSWINDOWS} // predefined for D6+/BCB6+
-{$DEFINE Win32API}
+  {$DEFINE MSWINDOWS} // predefined for D6+/BCB6+
+  {$DEFINE Win32API}
 {$ENDIF}
 
 {$IFDEF DELPHILANGUAGE}
-{$IFDEF LINUX}
-{$DEFINE UNIX}
-{$ENDIF}
+  {$IFDEF LINUX}
+    {$DEFINE UNIX}
+  {$ENDIF}
 
-{$IFNDEF CONSOLE}
-{$IFDEF LINUX}
-{$DEFINE VisualCLX}
-{$ENDIF}
-{$IFNDEF VisualCLX}
-{$DEFINE VCL}
-{$ENDIF}
-{$ENDIF ~CONSOLE}
+  {$IFNDEF CONSOLE}
+    {$IFDEF LINUX}
+      {$DEFINE VisualCLX}
+    {$ENDIF}
+    {$IFNDEF VisualCLX}
+      {$DEFINE VCL}
+    {$ENDIF}
+  {$ENDIF ~CONSOLE}
 {$ENDIF DELPHILANGUAGE}
 
 {------------------------------------------------------------------------------}
 { Compiler settings                                                            }
 {------------------------------------------------------------------------------}
 
-{$IFOPT A+}{$DEFINE ALIGN_ON}{$ENDIF}
-{$IFOPT B+}{$DEFINE BOOLEVAL_ON}{$ENDIF}
+{$IFOPT A+} {$DEFINE ALIGN_ON} {$ENDIF}
+{$IFOPT B+} {$DEFINE BOOLEVAL_ON} {$ENDIF}
 {$IFDEF COMPILER2_UP}
-{$IFOPT C+}{$DEFINE ASSERTIONS_ON}{$ENDIF}
+  {$IFOPT C+} {$DEFINE ASSERTIONS_ON} {$ENDIF}
 {$ENDIF}
-{$IFOPT D+}{$DEFINE DEBUGINFO_ON}{$ENDIF}
-{$IFOPT G+}{$DEFINE IMPORTEDDATA_ON}{$ENDIF}
+{$IFOPT D+} {$DEFINE DEBUGINFO_ON} {$ENDIF}
+{$IFOPT G+} {$DEFINE IMPORTEDDATA_ON} {$ENDIF}
 {$IFDEF COMPILER2_UP}
-{$IFOPT H+}{$DEFINE LONGSTRINGS_ON}{$ENDIF}
+  {$IFOPT H+} {$DEFINE LONGSTRINGS_ON} {$ENDIF}
 {$ENDIF}
-{ HINTS }
-{$IFOPT I+}{$DEFINE IOCHECKS_ON}{$ENDIF}
+
+// Hints
+{$IFOPT I+} {$DEFINE IOCHECKS_ON} {$ENDIF}
 {$IFDEF COMPILER2_UP}
-{$IFOPT J+}{$DEFINE WRITEABLECONST_ON}{$ENDIF}
+  {$IFOPT J+} {$DEFINE WRITEABLECONST_ON} {$ENDIF}
 {$ENDIF}
-{$IFOPT L+}{$DEFINE LOCALSYMBOLS}{$ENDIF}
-{$IFOPT M+}{$DEFINE TYPEINFO_ON}{$ENDIF}
-{$IFOPT O+}{$DEFINE OPTIMIZATION_ON}{$ENDIF}
-{$IFOPT P+}{$DEFINE OPENSTRINGS_ON}{$ENDIF}
-{$IFOPT Q+}{$DEFINE OVERFLOWCHECKS_ON}{$ENDIF}
-{$IFOPT R+}{$DEFINE RANGECHECKS_ON}{$ENDIF}
-{ REALCOMPATIBILITY }
-{$IFOPT T+}{$DEFINE TYPEDADDRESS_ON}{$ENDIF}
-{$IFOPT U+}{$DEFINE SAFEDIVIDE_ON}{$ENDIF}
-{$IFOPT V+}{$DEFINE VARSTRINGCHECKS_ON}{$ENDIF}
-{$IFOPT W+}{$DEFINE STACKFRAMES_ON}{$ENDIF}
-{ WARNINGS }
-{$IFOPT X+}{$DEFINE EXTENDEDSYNTAX_ON}{$ENDIF}
+{$IFOPT L+} {$DEFINE LOCALSYMBOLS} {$ENDIF}
+{$IFOPT M+} {$DEFINE TYPEINFO_ON} {$ENDIF}
+{$IFOPT O+} {$DEFINE OPTIMIZATION_ON} {$ENDIF}
+{$IFOPT P+} {$DEFINE OPENSTRINGS_ON} {$ENDIF}
+{$IFOPT Q+} {$DEFINE OVERFLOWCHECKS_ON} {$ENDIF}
+{$IFOPT R+} {$DEFINE RANGECHECKS_ON} {$ENDIF}
 
+// Real compatibility
+{$IFOPT T+} {$DEFINE TYPEDADDRESS_ON} {$ENDIF}
+{$IFOPT U+} {$DEFINE SAFEDIVIDE_ON} {$ENDIF}
+{$IFOPT V+} {$DEFINE VARSTRINGCHECKS_ON} {$ENDIF}
+{$IFOPT W+} {$DEFINE STACKFRAMES_ON} {$ENDIF}
+
+// Warnings
+{$IFOPT X+} {$DEFINE EXTENDEDSYNTAX_ON} {$ENDIF}
+
 // for Delphi/BCB trial versions remove the point from the line below
 {.$UNDEF SUPPORTS_WEAKPACKAGEUNIT}
 
 {$ENDIF ~JEDI_INC}
-



From twm at mail.berlios.de  Sun Jan 31 15:12:07 2010
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 31 Jan 2010 15:12:07 +0100
Subject: [Dzchart-svncheckins] r373 - component/trunk
Message-ID: <201001311412.o0VEC7G9023578@sheep.berlios.de>

Author: twm
Date: 2010-01-31 15:12:03 +0100 (Sun, 31 Jan 2010)
New Revision: 373

Added:
   component/trunk/u_dzDataSeries.pas
   component/trunk/u_dzXYChart.pas
Log:
bugfix in pasdoc comments

Copied: component/trunk/u_dzDataSeries.pas (from rev 66, component/trunk/u_dzDataSeries.pas)
===================================================================
--- component/trunk/u_dzDataSeries.pas	2006-02-11 19:30:05 UTC (rev 66)
+++ component/trunk/u_dzDataSeries.pas	2010-01-31 14:12:03 UTC (rev 373)
@@ -0,0 +1,751 @@
+(*****************************************************************************
+*           IdzDataSeries, IdzDataPoint interfaces
+*           TdzDataseries, TdzDataPoint classes
+*
+*        This unit is part of dummzeuch.de Charts
+*
+*                (c) 2003-2005 Thomas Mueller
+*                 http://www.dummzeuch.de
+*
+*  Based on Paul Warren's homegrown chart components
+*        http://users.uniserve.com/~hg_soft
+*
+*****************************************************************************
+* Version: MPL 1.1
+*
+* The contents of this file are subject to the Mozilla Public License Version
+* 1.1 (the "License"); you may not use this file except in compliance with
+* the License. You may obtain a copy of the License at
+* http://www.mozilla.org/MPL/
+*
+* Software distributed under the License is distributed on an "AS IS" basis,
+* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+* for the specific language governing rights and limitations under the
+* License.
+*
+* The Original Code is u_dzDataSeries.
+*
+* The Initial Developer of the Original Code is
+* Thomas Mueller.
+* Portions created by Thomas Mueller are Copyright (C) 2003-2004
+* by Thomas Mueller. All Rights Reserved.
+*
+* Contributor(s):
+* * Paul Warren
+* * Romeo Lefter
+*****************************************************************************)
+
+{: @abstract(Interface for dataseries and datapoint, used by u_dzXYChart)
+  This unit declares the interfaces @link(IdzSingleValueDataSeries),
+  @link(IdzMultiValueDataSeries) and @link(IdzDatapoint) which ar used
+  in @link(TdzXYChart).
+  An example implementtion @link(TdzPointDataSeries) for
+  IdzSingleValueDataSeries and @link(TdzDataPoint) for IdzDataPoint
+  is also provided.
+  For a more complex implementation of IdzSingleValueDataSeries see
+  @link(u_dzPolynomialDataSeries).
+  @author(Thomas Mueller)
+  @author(Paul Warren)
+  @author(Romeo Lefter)
+}
+
+unit u_dzDataSeries;
+
+interface
+
+uses
+  SysUtils,
+  Classes,
+{$IFDEF MSWINDOWS}
+  Graphics,
+{$ENDIF MSWINDOWS}
+{$IFDEF LINUX}
+  QGraphics,
+{$ENDIF}
+  Math,
+  Contnrs;
+
+type
+  {: Types of single value charts.
+     Maybe ctScatter and ctLine should be removed since ctScatter can be
+     implemented as ctXY with LineStyle = psClear and ctLine as ctXY with
+     PointStyle = psNone.
+     ctAlternatingLine is special: The chart will draw a line from
+     the first data point to the second then another from the third data
+     point to the fourth and so on. The special values Infinity and
+     NegInfinity (from Math unit) can be used to draw a horizontal line over
+     the whole chart. If there is no endpoint given for the last starting point
+     (that is the number of points in the series is not even), Infinity will be
+     assumed, so you can draw a horizontal line by just having a data series
+     with one point at (NegInfinity, Y-Value).
+     The idea behind this is to have control charts with limits that change
+     over time. In addition the start
+     and endpoints can have markers like with all the other series types. }
+  TSingleValueChartType = (ctScatter, ctLine, ctBar, ctXY, ctAlternatingLine);
+
+  {: Types of point style for ctScatter and ctXY style charts,
+     All types but psUpArrow and psDownArrow draw the point marker
+     around the actual point. psUpArrow and psDownArrow draw it so the
+     arrow points at the point. }
+  TPointStyle = (psNone, psRectangle, psCircle, psTriangle, psDownTriangle,
+    psCross, psDiagCross, psStar, psDiamond, psSmallDot, psUpArrow, psDownArrow,
+    psHorizontalLine, psVerticalLine);
+
+type
+  {: Types of multi value charts }
+  TMultiValueChartType = (ctHighLow, ctHighLowOpenClose, ctCandle);
+
+type
+  IdzDataSeries = interface ['{007BD1C9-62E8-D811-A461-000854097AB5}']
+    {: Get the number of data points in the data series
+       @returns the number of data points }
+    function GetPointCount: integer;
+    {: Get the Idx'th data point of the data series
+       @param(Idx is the index of the data point, must be >=0 and < GetPointCount)
+       @returns(a IdzDataPoint interface for the Idx'th data point) }
+    {: Get the line color for the data series }
+    function GetLineColor: TColor;
+    {: Get the line style for the data series }
+    function GetLineStyle: TPenStyle;
+    {: Get the point color for the data series }
+    function GetPointColor: TColor;
+    {: Get the point style for the data series }
+    function GetPointStyle: TPointStyle;
+    {: Get the fill color for the data series (for ctBar and to fill the point markers) }
+    function GetFillColor: TColor;
+    {: Get the caption of the data series used in the legend. }
+    function GetCaption: string;
+    {: This procedure is called to notify the class of some operations.
+       @param(Component is the component causing the notification)
+       @param(Operation is the operation causing the notification, that is one of
+              opInsert and opRemove) }
+    procedure Notification(_Component: TComponent; _Operation: TOperation);
+    {: returns true if this is a IdzMultiValueDataSeries }
+    function IsMulti: boolean;
+    {: returns the minimum and maximum X / Y values of the data series
+       (only valid if result is true)
+       @param(MinX is the minium X value)
+       @param(MaxX is the maximum X value)
+       @param(MinY is the minimum Y value)
+       @param(MaxX is the maximum Y value)
+       @returns(true, if there is at least one data point in the series) }
+    function GetMinAndMax(out _MinX, _MaxX, _MinY, _MaxY: Double): boolean;
+  end;
+
+type
+  {: @classname describes a single data point of a chart. }
+  IdzDataPoint = interface ['{08B26745-F831-4F36-9DFD-16884D3E8D6E}']
+    {: @returns the X value of the point }
+    function GetX: double;
+    {: @returns the Y value of the point }
+    function GetY: double;
+    //    function GetLabel: string;
+  end;
+
+type
+  {: @classname describes a single value data series, that is a data series where there is
+     only one Y value for a given X value (see also @link(IdzMultiValueDataSeries)) }
+  IdzSingleValueDataSeries = interface(IdzDataSeries)['{703E9533-F610-4354-939E-373E4BBAE78A}']
+    function GetDataPoint(_Idx: integer): IdzDataPoint;
+    {: Get the type of the data series }
+    function GetChartType: TSingleValueChartType;
+  end;
+
+type
+  IdzMultiValueDataPoint = interface ['{3E579B6B-55E8-D811-A461-000854097AB5}']
+    {: Returns the X value of the data point }
+    function GetX: double;
+    {: Returns the number of Y values of the data point }
+    function GetValueCount: integer;
+    {: Returns the Idx'th Y value of the data point.
+       @param(Idx is the value's index, must be >=0 and <GetValueCount)
+       Note that these points need not be in any order but low to high is recommended
+       otherwise the result might not be as expected, depending on the chart type. }
+    function GetY(_Idx: integer): double;
+  end;
+
+type
+  {: @classname describes a multi value data series, that is a data series where there are
+     several Y value for a given X value (see also @link(IdzSingleValueDataSeries)).
+     There is currently no implementation of this interface in TdzChart. }
+  IdzMultiValueDataSeries = interface(IdzDataSeries)['{02A14F76-F1D4-D811-B814-000854097AB5}']
+    {: Returns the Idx'th data point of the data series
+       @param(Idx is the index of the data point, must be >=0 and < GetPointCount)
+       @returns(a IdzMultiValueDataPoint interface for retrieving the values) }
+    function GetDataPoint(_Idx: integer): IdzMultiValueDataPoint;
+    {: Get the chart type for this data series. The following types are available:
+       <ul><li>ctHighLow is a vertical line described by GetLineColor and GetLineStyle
+               from the first to the last Y value. In addition the data points
+               might be drawn as described by GetPointColor and GetPointStyle</li>
+           <li>ctHighLowOpenClose is a vertical line from the first to the last
+               Y value. In addition there is a horizontal mark to the left marking
+               the second and the second to last Y value. This means that if there
+               are only two values it will look like a Z, if there are only
+               three values it will look like a cross. (Assuming the values
+               are given in ascending order, otherweise the result might be
+               unexpected.) The lines are drawn as described by GetLineColor
+               and GetLineStyel. In addition the data points may be drawn as
+               described by GetPointColor and GetPointStyle </li>
+           <li>ctCandle draws a vertical line from the first to the last Y value
+               and a vertical bar from the second to the second to last Y value.
+               The line is described by GetLineColor and GetLineStyle, the bar
+               by GetBarColor. In addition the data points may be drawn as
+               described by GetPointColor and GetPointStyle </li>
+       </ul>
+       If there is only one value, nothing will be drawn but the single data
+       point as described by GetPointColor and GetPointStyle. }
+    function GetChartType: TMultiValueChartType;
+    function GetBearishColor:TColor;
+    function GetBullishColor:TColor;
+  end;
+
+type
+  {: @classname implements the @link(IdzDataPoint) interface by simply storing
+     the X/Y values passed to it in the constructor }
+  TdzDataPoint = class(TInterfacedObject, IdzDataPoint)
+  protected
+    {: Stores the value returned by GetX }
+    fX: double;
+    {: Stores the value returned by GetY }
+    fY: double;
+    //    fPointLabel: string;
+        {: Returns the value stored in fX }
+    function GetX: double;
+    {: Returns the value stored in fY }
+    function GetY: double;
+    //    function GetLabel: string;
+  public
+    {: Creates a @classname object representing a data point at X/Y
+       @param(X is the X coordinate of the point)
+       @param(Y is the Y coordinate of the point)
+       @param(Label is an optional string describing the data point (not yet used)) }
+    constructor Create(const _X, _Y: double; const _Label: string = '');
+  end;
+
+type
+  {: @classname is a simple implementation of the @link(IdzSingleValueDataSeries)
+     interface. It stores a list of @link(IdzDataPoint) interfaces and returns
+     them when asked.}
+  TdzPointDataSeries = class(TInterfacedObject, IdzDataSeries, IdzSingleValueDataSeries)
+  protected
+    {: Stores the value of the @link(PointColor) property }
+    fPointColor: TColor;
+    {: Stores the value of the @link(PointStyle) property }
+    fPointStyle: TPointStyle;
+    {: Stores the value of the @link(LineColor) property }
+    fLineColor: TColor;
+    {: Stores the value of the @link(LineStyle) property }
+    fLineStyle: TPenStyle;
+    {: Stores the value of the @link(FillColor) property }
+    fFillColor: TColor;
+    {: Stores the value of the @link(ChartType) property }
+    fChartType: TSingleValueChartType;
+    {: Stores a list of @link(IdzDataPoint) interfaces. Items are added
+       to this list by calling @link(AddDatapoint) }
+    fPoints: TInterfaceList;
+    {: Stores the value of the Caption property }
+    fCaption: string;
+    {: Returns the number of items in the fPoints list }
+    function GetPointCount: integer;
+    {: Gets the Idx'th item from the fPoints list.
+       @param(Idx is the index into the fpoints list, must be >=0 and < @link(GetPointCount))
+       @returns a IdzDataPoint interface describing the point }
+    function GetDataPoint(_Idx: integer): IdzDataPoint;
+    {: Returns the line color for the data series }
+    function GetLineColor: TColor;
+    {: Returns the line style for the data series }
+    function GetLineStyle: TPenStyle;
+    {: Returns the point color for the data series }
+    function GetPointColor: TColor;
+    {: Returns the point style for the data series }
+    function GetPointStyle: TPointStyle;
+    {: Get the fill color for the data series (for ctBar and to fill the point markers) }
+    function GetFillColor: TColor;
+    {: Returns the chart type for the data series }
+    function GetChartType: TSingleValueChartType;
+    {: Returns the Caption for the data series (used in the Legend) }
+    function GetCaption: string;
+    {: Handles notifications, does nothing in this class }
+    procedure Notification(_Component: TComponent; _Operation: TOperation);
+    {: returns true if this is a IdzMultiValueDataSeries }
+    function IsMulti: boolean;
+    {: returns the minimum and maximum X / Y values of the data series
+       (only valid if result is true)
+       @param(MinX is the minium X value)
+       @param(MaxX is the maximum X value)
+       @param(MinY is the minimum Y value)
+       @param(MaxX is the maximum Y value)
+       @returns(true, if there is at least one data point in the series) }
+    function GetMinAndMax(out _MinX, _MaxX, _MinY, _MaxY: Double): boolean;
+  public
+    {: Creates a new @classname object with an empty data point list }
+    constructor Create;
+    {: Destroys a @classname object }
+    destructor Destroy; override;
+    {: Adds a data point to the data point list
+       @param(Point is the @link(IdzDataPoint) interface to add)
+       @returns(The index of the added data point) }
+    function AddDataPoint(const _Point: IdzDataPoint): integer; overload;
+    {: Creates a new TdzDataPoint object and adds it to the data point list
+       This is short for AddDataPoint(TdzDatapoint.Create(...)).
+       @param(X is the X coordinate of the new data point)
+       @param(Y is the Y coordinate of the new data point)
+       @param(Label is an optional string describing the data point (not used yet))
+       @returns(The index of the added data point) }
+    function AddDataPoint(const _X, _Y: double; const _Label: string = ''): integer; overload;
+    {: Contains the point color of the data series, default is clblack. }
+    property PointColor: TColor read fPointColor write fPointColor;
+    {: Contains the point style of the data series, default is psCircle }
+    property PointStyle: TPointStyle read fPointStyle write fPointStyle;
+    {: Contains the line color of the data series, default is clBlack }
+    property LineColor: TColor read fLineColor write fLineColor;
+    {: Contains the line style of the data series, default is psSolid }
+    property LineStyle: TPenStyle read fLineStyle write fLineStyle;
+    {: Contains the chart type of the data series, default is ctXY }
+    property ChartType: TSingleValueChartType read fChartType write fChartType;
+    {: Containts the fill color of the data series, default is clGray }
+    property FillColor: TColor read fFillColor write fFillColor;
+    {: Contains the caption of the data series used in the legend, default is an empty string }
+    property Caption: string read GetCaption write fCaption;
+  end;
+
+type
+  {: @classname implements the @link(IdzMultiValueDataPoint) interface by simply storing
+     the X and Y[] values passed to it in the constructor }
+  TdzMultiValueDataPoint = class(TInterfacedObject, IdzMultiValueDataPoint)
+  protected
+    {: Stores the value returned by GetX }
+    fX: double;
+    {: Stores the value returned by GetY }
+    fYArr: array of double;
+    //    fPointLabel: string;
+        {: Returns the value stored in fX }
+    function GetX: double;
+    {: Returns the number of Y values of the data point (that is Length(fYArr))}
+    function GetValueCount: integer;
+    {: Returns one of the values stored in fYArr }
+    function GetY(_Idx: integer): double;
+    //    function GetLabel: string;
+  public
+    {: Creates a @classname object representing a data point at X/Y
+       @param(X is the X coordinate of the point)
+       @param(YArr is a const arrry of double with Y values of the point)
+       @param(Label is an optional string describing the data point (not yet used)) }
+    constructor Create(const _X: double; const _YArr: array of double; const _Label: string = '');
+  end;
+
+  {: @classname is a simple implementation of a @link(IdzMultiValueDataSeries).
+     It stores a list of @link(IdzMultiValueDataPoint) interfaces and returns
+     them when asked }
+  TdzMultiValueDataSeries = class(TInterfacedObject, IdzDataSeries, IdzMultiValueDataSeries)
+  private
+    fCaption: string;
+    fFillColor: TColor;
+    fLineColor: TColor;
+    fPointColor: TColor;
+    fLineStyle: TPenStyle;
+    fPointStyle: TPointStyle;
+    fChartType: TMultiValueChartType;
+    fPoints: TInterfaceList;
+    fbullishColor:TColor;
+    fBearishColor:TColor;
+  protected
+    // implementation of IdzMultiValueDataSeries
+    {: Returns the number of points in the data series, that is the number of different X values. }
+    function GetPointCount: integer;
+    {: Returns the Idx'th data point of the data series
+       @param(Idx is the index of the data point, must be >=0 and < GetPointCount)
+       @returns(a IdzMultiValueDataPoint interface for retrieving the values) }
+    function GetDataPoint(_Idx: integer): IdzMultiValueDataPoint;
+    {: Get the chart type for this data series. The following types are available:
+       <ul><li>ctHighLow is a vertical line described by GetLineColor and GetLineStyle
+               from the first to the last Y value. In addition the data points
+               might be drawn as described by GetPointColor and GetPointStyle</li>
+           <li>ctHighLowOpenClose is a vertical line from the first to the last
+               Y value. In addition there is a horizontal mark to the left marking
+               the second and the second to last Y value. This means that if there
+               are only two values it will look like a Z, if there are only
+               three values it will look like a cross. (Assuming the values
+               are given in ascending order, otherweise the result might be
+               unexpected.) The lines are drawn as described by GetLineColor
+               and GetLineStyel. In addition the data points may be drawn as
+               described by GetPointColor and GetPointStyle </li>
+           <li>ctCandle draws a vertical line from the first to the last Y value
+               and a vertical bar from the second to the second to last Y value.
+               The line is described by GetLineColor and GetLineStyle, the bar
+               by GetBarColor. In addition the data points may be drawn as
+               described by GetPointColor and GetPointStyle </li>
+       </ul>
+       If there is only one value, nothing will be drawn but the single data
+       point as described by GetPointColor and GetPointStyle. }
+    function GetChartType: TMultiValueChartType;
+    {: Get the color for drawing lines }
+    function GetLineColor: TColor;
+    {: Get the style for drawing lines }
+    function GetLineStyle: TPenStyle;
+    {: Get the color for drawing points }
+    function GetPointColor: TColor;
+    {: Get the style for drawing data points }
+    function GetPointStyle: TPointStyle;
+    {: Get the fill color for the data series (for ctCandle and to fill the point markers) }
+    function GetFillColor: TColor;
+    {: Get the the caption for the data series used in the legend }
+    function GetCaption: string;
+    {: This procedure is called to notify the class of some operations.
+       @param(Component is the component causing the notification)
+       @param(Operation is the operation causing the notification, that is one of
+              opInsert and opRemove) }
+    procedure Notification(_Component: TComponent; _Operation: TOperation);
+    {: returns true if this is a IdzMultiValueDataSeries }
+    function IsMulti: boolean;
+    {: returns the minimum and maximum X / Y values of the data series
+       (only valid if result is true)
+       @param(MinX is the minium X value)
+       @param(MaxX is the maximum X value)
+       @param(MinY is the minimum Y value)
+       @param(MaxX is the maximum Y value)
+       @returns(true, if there is at least one data point in the series) }
+    function GetMinAndMax(out _MinX, _MaxX, _MinY, _MaxY: Double): boolean;
+    function GetBearishColor:TColor;
+    function GetBullishColor:TColor;
+  public
+    {: Creates a new @classname object with an empty data point list }
+    constructor Create;
+    {: Destroys a @classname object }
+    destructor Destroy; override;
+    {: Adds a data point to the data point list
+       @param(Point is the @link(IdzMultiValueDataPoint) interface to add)
+       @returns(The index of the added data point) }
+    function AddDataPoint(const _Point: IdzMultiValueDataPoint): integer; overload;
+    {: Creates a new TdzDataPoint object and adds it to the data point list
+       This is short for AddDataPoint(TdzDatapoint.Create(...)).
+       @param(X is the X coordinate of the new data point)
+       @param(YArr is an open array containing the Y values of the new data point)
+       @param(Label is an optional string describing the data point (not used yet))
+       @returns(The index of the added data point) }
+    function AddDataPoint(const _X: double; const _YArr: array of double; const _Label: string = ''): integer; overload;
+    {: Contains the point color of the data series, default is clblack. }
+    property PointColor: TColor read fPointColor write fPointColor;
+    {: Contains the point style of the data series, default is psCircle }
+    property PointStyle: TPointStyle read fPointStyle write fPointStyle;
+    {: Contains the line color of the data series, default is clBlack }
+    property LineColor: TColor read fLineColor write fLineColor;
+    {: Contains the line style of the data series, default is psSolid }
+    property LineStyle: TPenStyle read fLineStyle write fLineStyle;
+    {: Contains the chart type of the data series, default is ctXY }
+    property ChartType: TMultiValueChartType read fChartType write fChartType;
+    {: Containts the fill color of the data series, default is clGray }
+    property FillColor: TColor read fFillColor write fFillColor;
+    {: Contains the caption of the data series used in the legend, default is an empty string }
+    property Caption: string read GetCaption write fCaption;
+    property BearishColor:TColor read fBearishColor write fBearishColor;
+    property BullishColor:TColor read fBullishColor write fBullishColor;
+  end;
+
+implementation
+
+{ TdzPointDataSeries }
+
+constructor TdzPointDataSeries.Create;
+begin
+  inherited Create;
+  fPointColor := clBlack;
+  fPointStyle := psCircle;
+  fLineColor := clBlack;
+  fLineStyle := psSolid;
+  fFillColor := clGray;
+  fChartType := ctXy;
+  fPoints := TInterfaceList.Create;
+end;
+
+destructor TdzPointDataSeries.Destroy;
+begin
+  FreeAndNil(fPoints);
+  inherited;
+end;
+
+function TdzPointDataSeries.AddDataPoint(const _Point: IdzDataPoint): integer;
+begin
+  Result := fPoints.Add(_Point);
+end;
+
+function TdzPointDataSeries.AddDataPoint(const _X, _Y: double;
+  const _Label: string): integer;
+begin
+  Result := AddDataPoint(TdzDataPoint.Create(_X, _Y, _Label));
+end;
+
+function TdzPointDataSeries.GetPointCount: integer;
+begin
+  Result := fPoints.Count;
+end;
+
+function TdzPointDataSeries.GetDataPoint(_Idx: integer): IdzDataPoint;
+begin
+  Result := fPoints[_Idx] as IdzDataPoint;
+end;
+
+function TdzPointDataSeries.GetLineColor: TColor;
+begin
+  Result := fLineColor;
+end;
+
+function TdzPointDataSeries.GetPointColor: TColor;
+begin
+  Result := fPointColor;
+end;
+
+function TdzPointDataSeries.GetChartType: TSingleValueChartType;
+begin
+  Result := fChartType;
+end;
+
+function TdzPointDataSeries.GetFillColor: TColor;
+begin
+  Result := fFillColor;
+end;
+
+function TdzPointDataSeries.GetPointStyle: TPointStyle;
+begin
+  Result := fPointStyle;
+end;
+
+function TdzPointDataSeries.GetLineStyle: TPenStyle;
+begin
+  Result := fLineStyle;
+end;
+
+function TdzPointDataSeries.GetCaption: string;
+begin
+  Result := fCaption;
+end;
+
+procedure TdzPointDataSeries.Notification(_Component: TComponent; _Operation: TOperation);
+begin
+  // do nothing
+end;
+
+function TdzPointDataSeries.IsMulti: boolean;
+begin
+  Result := false;
+end;
+
+function TdzPointDataSeries.GetMinAndMax(out _MinX, _MaxX, _MinY, _MaxY: Double): boolean;
+var
+  i: integer;
+  x: double;
+  y: double;
+  Point: IdzDataPoint;
+begin
+  Result := GetPointCount > 0 ;
+  if Result then
+    begin
+      Point := GetDataPoint(0);
+      _MinX := Point.GetX;
+      _MaxX := _MinX;
+      _MinY := Point.GetY;
+      _MaxY := _MinY;
+      for i := 1 to GetPointCount - 1 do
+        begin
+          Point := GetDataPoint(i);
+          x := Point.GetX;
+          y := Point.GetY;
+          if x > _MaxX then
+            _MaxX := x;
+          if x < _MinX then
+            _MinX := x;
+          if y > _MaxY then
+            _MaxY := y;
+          if y < _MinY then
+            _MinY := y;
+        end;
+    end;
+end;
+
+{ TdzDataPoint }
+
+constructor TdzDataPoint.Create(const _X, _Y: double; const _Label: string);
+begin
+  inherited Create;
+  fX := _X;
+  fY := _Y;
+  //  fPointLabel := _Label;
+end;
+
+function TdzDataPoint.GetX: double;
+begin
+  Result := fX;
+end;
+
+function TdzDataPoint.GetY: double;
+begin
+  Result := fY;
+end;
+
+{ TdzMultiValueDataPoint }
+
+constructor TdzMultiValueDataPoint.Create(const _X: double;
+  const _YArr: array of double; const _Label: string);
+var
+  i: integer;
+begin
+  inherited Create;
+  fX := _X;
+  SetLength(fYArr, Length(_YArr));
+  for i := Low(fYArr) to High(fYArr) do
+    fYArr[i] := _YArr[i];
+end;
+
+function TdzMultiValueDataPoint.GetValueCount: integer;
+begin
+  Result := Length(fYArr);
+end;
+
+function TdzMultiValueDataPoint.GetX: double;
+begin
+  Result := fX;
+end;
+
+function TdzMultiValueDataPoint.GetY(_Idx: integer): double;
+begin
+  Result := fYArr[_Idx];
+end;
+
+{ TdzMultiValueDataSeries }
+
+constructor TdzMultiValueDataSeries.Create;
+begin
+  inherited Create;
+  fPointColor := clBlack;
+  fPointStyle := psCross;
+  fLineColor := clBlack;
+  fLineStyle := psSolid;
+  fFillColor := clGray;
+  fChartType := ctHighLow;
+  fBearishColor:=ClRed;
+  fbullishColor:=clBlue;
+
+  fPoints := TInterfaceList.Create;
+end;
+
+destructor TdzMultiValueDataSeries.Destroy;
+begin
+  FreeAndNil(fPoints);
+  inherited;
+end;
+
+function TdzMultiValueDataSeries.AddDataPoint(const _Point: IdzMultiValueDataPoint): integer;
+begin
+  Result := fPoints.Add(_Point);
+end;
+
+function TdzMultiValueDataSeries.AddDataPoint(const _X: double;
+  const _YArr: array of double; const _Label: string): integer;
+begin
+  Result := AddDataPoint(TdzMultiValueDataPoint.Create(_X, _YArr, _Label));
+end;
+
+function TdzMultiValueDataSeries.GetDataPoint(_Idx: integer): IdzMultiValueDataPoint;
+begin
+  Result := IdzMultiValueDataPoint(fPoints[_Idx]);
+end;
+
+function TdzMultiValueDataSeries.GetPointCount: integer;
+begin
+  Result := fPoints.Count;
+end;
+
+function TdzMultiValueDataSeries.GetFillColor: TColor;
+begin
+  Result := fFillColor;
+end;
+
+function TdzMultiValueDataSeries.GetCaption: string;
+begin
+  Result := fCaption;
+end;
+
+function TdzMultiValueDataSeries.GetChartType: TMultiValueChartType;
+begin
+  Result := fChartType;
+end;
+
+function TdzMultiValueDataSeries.GetLineColor: TColor;
+begin
+  Result := fLineColor;
+end;
+
+function TdzMultiValueDataSeries.GetLineStyle: TPenStyle;
+begin
+  Result := fLineStyle;
+end;
+
+function TdzMultiValueDataSeries.GetPointColor: TColor;
+begin
+  Result := fPointColor;
+end;
+
+function TdzMultiValueDataSeries.GetPointStyle: TPointStyle;
+begin
+  Result := fPointStyle;
+end;
+
+function TdzMultiValueDataSeries.GetBearishColor:TColor;
+begin
+  Result:=fBearishColor;
+end;
+
+function TdzMultiValueDataSeries.GetBullishColor:TColor;
+begin
+  Result:=fbullishColor;
+end;
+
+procedure TdzMultiValueDataSeries.Notification(_Component: TComponent;
+  _Operation: TOperation);
+begin
+  // do nothing
+end;
+
+function TdzMultiValueDataSeries.IsMulti: boolean;
+begin
+  Result := true;
+end;
+
+function TdzMultiValueDataSeries.GetMinAndMax(out _MinX, _MaxX, _MinY, _MaxY: Double): boolean;
+var
+  PtIdx: integer;
+  ValueIdx: integer;
+  x: double;
+  y: double;
+  Point: IdzMultiValueDataPoint;
+begin
+  Result := (GetPointCount > 0) and (GetDataPoint(0).GetValueCount > 0);
+  if Result then
+    begin
+      Point := GetDataPoint(0);
+      _MinX := Point.GetX;
+      _MaxX := _MinX;
+      _MinY := Point.GetY(0);
+      _MaxY := _MinY;
+      for PtIdx := 1 to GetPointCount - 1 do
+        begin
+          Point := GetDataPoint(PtIdx);
+          x := Point.GetX;
+          for ValueIdx := 0 to Point.GetValueCount - 1 do
+            begin
+              y := Point.GetY(ValueIdx);
+              if x > _MaxX then
+                _MaxX := x;
+              if x < _MinX then
+                _MinX := x;
+              if y > _MaxY then
+                _MaxY := y;
+              if y < _MinY then
+                _MinY := y;
+            end;
+        end;
+    end;
+end;
+
+end.
+

Copied: component/trunk/u_dzXYChart.pas (from rev 66, component/trunk/u_dzXYChart.pas)
===================================================================
--- component/trunk/u_dzXYChart.pas	2006-02-11 19:30:05 UTC (rev 66)
+++ component/trunk/u_dzXYChart.pas	2010-01-31 14:12:03 UTC (rev 373)
@@ -0,0 +1,1946 @@
+(*****************************************************************************
+ *                 TdzXYChart Component
+ *
+ *        This unit is part of dummzeuch.de Charts
+ *
+ *              (c) 2003-2005 Thomas Mueller
+ *                 http://www.dummzeuch.de
+ *
+ *  Based on Paul Warren's homegrown chart components
+ *        http://users.uniserve.com/~hg_soft
+ *
+ *****************************************************************************
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is u_dzXYChart.
+ *
+ * The Initial Developer of the Original Code is
+ * Thomas Mueller.
+ * Portions created by the Initial Developer are Copyright (C) 2003-2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * * Paul Warren
+ * * Romeo Lefter
+ *****************************************************************************)
+
+ {: @abstract(Implements TdzXYChart, capable of drawing XY, scatter, line and bar charts.)
+    @author(Thomas Mueller)
+    @author(Paul Warren)
+    @author(Romeo Lefter)
+ }
+
+unit u_dzXYChart;
+
+interface
+
+uses
+  SysUtils,
+  Types,
+  Classes,
+  Math,
+  Contnrs,
+{$IFDEF MSWINDOWS}
+  Windows,
+  Messages,
+  Graphics,
+  Controls,
+  Forms,
+  Dialogs,
+  StdCtrls,
+{$ENDIF MSWINDOWS}
+{$IFDEF LINUX}
+  Qt,
+  u_dzQWindows,
+  QGraphics,
+  QControls,
+  QForms,
+  QDialogs,
+  QStdCtrls,
+{$ENDIF LINUX}
+  u_dzDataSeries,
+  u_dzCustomCharts,
+  u_dzCanvas,
+  u_dzGraphics;
+
+type
+  EInvalidDataSeries = class(EdzCharts);
+
+const
+  {: Default title string for chart legend }
+  DEFAULT_LEGEND_TITLE = 'Legend';
+  {: Default title string for X axis }
+  DEFAULT_X_AXIS_NAME = 'X-Axis';
+  {: Default title string for Y axis }
+  DEFAULT_Y_AXIS_NAME = 'Y-Axis';
+
+type
+  TScaleType = (stLinear{, stLogarithmic});
+
+type
+  {: Defnies the orientation of the axis labels }
+  TAxisLabelOrientation = (loHorizontal, loVertical);
+  {: Event procedure type used in the @link(TdzXYChart.OnScaling) event
+     @param(Sender is the sending chart)
+     @param(MinX is the minimum X value to display in the chart)
+     @param(MaxX is the maximum X value to display in the chart)
+     @param(MinY is the minimum Y value to display in the chart)
+     @param(MaxY is the maximum Y value to display in the chart) }
+  TOnScaling = procedure(_Sender: TObject; var _MinX, _MaxX, _MinY, _MaxY: Double) of object;
+  {: Event procecure used in the @link(TdzChartAxis.OnFormatLabel) event.
+     @param(Sender is the sending axis)
+     @param(Value is the label's value to be formatted)
+     @param(Text is the actual label text, defaults to FloatToStr(Value) ) }
+  TOnFormatAxisLabel = procedure(_Sender: TObject; _Value: Double; var _Text: string) of object;
+  {: Event procedure used in the @link(TdzChartAxis.OnGetNextLabel) event.
+     @param(Sender is the sending axis)
+     @param(LabelIndex is the current label's index, starting with 0 and
+            by 1 after every call to this event)
+     @param(Value is the position of the next label)
+     @param(Stop is a boolean indicating whether the call returned a label for
+            the axis, it defaults to true so it must be set to false as long
+            as there are labels to draw, the last call must set Stop to true
+            the value of Value will be ignored.) }
+  TOnGetNextAxisLabel = procedure(_Sender: TObject; _LabelIndex: integer; var _Value: double; var _Stop: boolean) of object;
+
+type
+  TdzCustomXYChart = class;
+
+  {: Describes an axis scale }
+  TdzCustomAxisScale = class(TComponent)
+  protected
+    {: Stores the Automatic property }
+    fAutomatic: boolean;
+    {: Stores the Min property }
+    fMin: double;
+    {: Stores the Max property }
+    fMax: double;
+    {: Stores the Divisions property }
+    fDivisions: double;
+    {: Stores the ScaleType property }
+    fScaleType: TScaleType;
+    {: Calls the chart's refresh method }
+    procedure RefreshChart;
+    {: Setter method for Automatic property, calls RefreshChart if value changed }
+    procedure SetAutomatic(const _Automatic: boolean);
+    {: Setter method for Divisions property, calls RefreshChart if value changed }
+    procedure SetDivisions(const _Divisions: double);
+    {: Setter method for Max property, calls RefreshChart if value changed }
+    procedure SetMax(const _Max: double);
+    {: Setter method for Min property, calls RefreshChart if value changed }
+    procedure SetMin(const _Min: double);
+    {: Setter method for ScaleType property, calls RefreshChart if value changed }
+    procedure SetScaleType(const _ScaleType: TScaleType);
+    {: If set to true, automatic scaling is enabled, so the values of the
+       Min, Max and Divisions will be ignored. }
+    property Automatic: boolean read fAutomatic write SetAutomatic stored true;
+    {: Minimum value of the axis scale (Only valid if Automatich is set to false)
+       See @link(Divisions) for an example. }
+    property Min: double read fMin write SetMin;
+    {: Maximum value of the axis scale (Only valid if Automatich is set to false)
+       See @link(Divisions) for an example. }
+    property Max: double read fMax write SetMax;
+    {: Division value of the axis scale (Only valid if Automatic is set to false)
+       this is the number of divisions the axis scale will be divided into to
+       place axis labels.
+       Example:
+       @longcode(#
+         MyChart.BeginUpdate;
+         try
+           MyChart.LeftAxis.Scale.Automatic := false;
+           MyChart.LeftAxis.Scale.Min := 0;
+           MyChart.LeftAxis.Scale.Max := 10;
+           MyChart.LeftAxis.Scale.Divisions := 2;
+         finally
+           MyChart.EndUpdate;
+         end;
+       #)
+       Will make the chart start at Y = 0 and end at Y = 10 and divide this
+       into two parts, resulting in labels at Y = 0, 5 and 10. }
+    property Divisions: double read fDivisions write SetDivisions;
+    {: determines whether the scale is a linear or logarithmic scale }
+    property ScaleType: TScaleType read fScaleType write SetScaleType;
+  public
+    {: Constructor for @classname }
+    constructor Create(_Owner: TComponent); override;
+  end;
+
+  {: @classname extends @inherited by publishing the properties Automatic,
+     Min, Max and Divisions }
+  TdzAxisScale = class(TdzCustomAxisScale)
+  published
+    {: see @inherited }
+    property Automatic;
+    {: see @inherited }
+    property Min;
+    {: see @inherited }
+    property Max;
+    {: see @inherited }
+    property Divisions;
+    {: see @inherited }
+    property ScaleType;
+  end;
+
+  {: Describes a chart axis for a @link(TdzXYChart) }
+  TdzCustomChartAxis = class(TdzCustomTitle)
+  protected
+    {: Used internally to store the "natural" label orientation, that is
+       horizontal for the left and vertical for the bottom axis }
+    fNaturalLabelOrientation: TAxisLabelOrientation;
+    {: Stores the LabelFont property }
+    fLabelFont: TFont;
+    {: Stores the LabelOrientation property }
+    fLabelOrientation: TAxisLabelOrientation;
+    {: Stores the Scale subcomponent }
+    fScale: TdzAxisScale;
+    {: Stores the OnGetNextLabel event }
+    fOnGetNextLabel: TOnGetNextAxisLabel;
+    {: Stores the OnFormatLabel event }
+    FOnFormatLabel: TOnFormatAxisLabel;
+    {: Setter method for the LabelFont property }
+    procedure SetLabelFont(_LabelFont: TFont);
+    {: Setter method for the LabelOrientation property }
+    procedure SetLabelOrientation(_LabelOrientation: TAxisLabelOrientation);
+    {: Initializes the default labels for the axis
+       @param(Size is the current axis size in pixels)
+       @param(Min is the minimum value of the axis as determined by the chart component)
+       @param(Max is the maximum value of the axis as determined by the chart component)
+       @param(Canvas is the canvas used to draw the axis) }
+    procedure InitDefaultLabels(_Size: integer; const _Min, _Max: double; const _Canvas: IdzCanvas);
+    {: Calls the OnGetNextLabel event if assigned, otherwise uses the values of
+       the Scale subcomponent to calculate the axis labels.
+       @param(Idx is the label index, starting with 0 and incremented by 1 after
+              each call)
+       @param(Value is the value of the next label)
+       @returns(true, if there is no (more) label, false otherwise) }
+    function GetNextLabel(_Idx: integer; var _Value: double): boolean;
+    {: Calls the OnFormatLabel event if assigned, otherwise the label will
+       be formatted using FloatToStr(Value).
+       @param(Value is the value to be formatted)
+       @returns(A formatted label string) }
+    function FormatLabel(const _Value: double): string;
+    {: Calculates the space in pixels needed for drawing the axis' labels
+       @param(Canvas is the canvas used to calculate the space) }
+    function CalcLabelingSpace(const _Canvas: IdzCanvas): integer; virtual;
+
+    {: @name is a sub component @link(TdzAxisScale) describing how the axis is to be scaled }
+    property Scale: TdzAxisScale read fScale;
+    {: @name is the font to be used for drawing the axis labels }
+    property LabelFont: TFont read fLabelFont write SetLabelFont;
+    {: @name is the orientation of the label text }
+    property LabelOrientation: TAxisLabelOrientation read fLabelOrientation write SetLabelOrientation;
+
+    {: @name is called to get the axis label positions, if not assigned, the
+       label positions will be determined by the @link(Scale) property }
+    property OnGetNextLabel: TOnGetNextAxisLabel read fOnGetNextLabel write fOnGetNextLabel;
+    {: @name is called to format an axis label, if not assigned the label will
+       be formatted as @code(FloatToStr(Value)) }
+    property OnFormatLabel: TOnFormatAxisLabel read FOnFormatLabel write FOnFormatLabel;
+  public
+    {: Creates a new @classname object }
+    constructor Create(_Owner: TComponent); override;
+    {: Destroys a @classname object }
+    destructor Destroy; override;
+  end;
+
+  {: @classname extends @inherited by publishing the properties
+    Title, TitleFont, LabelFont, LabelOrientation and Scale and the
+    events OnGetNextLabel, OnFormatLabel and OnNeedLines. See @inherited
+    for a description of these. }
+  TdzChartAxis = class(TdzCustomChartAxis)
+  published
+    {: see @inherited }
+    property Title;
+    {: see @inherited }
+    property TitleFont;
+    {: see @inherited }
+    property LabelFont;
+    {: see @inherited }
+    property LabelOrientation;
+    {: see @inherited }
+    property OnGetNextLabel;
+    {: see @inherited }
+    property OnFormatLabel;
+    {: see @inherited }
+    property Scale;
+  end;
+
+  {: @name initializes a @inherited for a bottom axis, that is, it sets
+     the fNaturalLabelOrientation to vertical. }
+  TdzBottomChartAxis = class(TdzChartAxis)
+  public
+    {: @name creates a new @classname}
+    constructor Create(_Owner: TComponent); override;
+  end;
+
+  {: @name initializes a @inherited for a left axis, that is, it sets
+     the fNaturalLabelOrientation to horizontal. }
+  TdzLeftChartAxis = class(TdzChartAxis)
+  public
+    {: @name creates a new @classname}
+    constructor Create(_Owner: TComponent); override;
+  end;
+
+  {: Determines the position of the chart's legend or turns it off. }
+  TLegendPosition = (lpNoLegend, lpLeft, lpRight, lpTop, lpBottom);
+
+  {: @name describes a legend for a @link(TdzXYChart). }
+  TdzXYChartLegend = class(TdzCustomTitle)
+  protected
+    {: @Name stores the @link(Position) property }
+    fPosition: TLegendPosition;
+    {: @Name stores the @link(LegendFont) property }
+    fLegendFont: TFont;
+    {: @Name stores the @link(Frame) sub component }
+    fFrame: TdzChartFrame;
+    {: @Name stores the @link(BackGround) property }
+    fBackGround: TColor;
+    {: @Name stores the @link(Columns) property }
+    fColumns: integer;
+    {: @name is the setter method for the @link(Background) property }
+    procedure SetBackGround(const _Background: TColor);
+    {: @name is the setter method for the @link(Columns) property }
+    procedure SetColumns(_Columns: integer);
+    {: @name is the setter method for the @link(LegendFont) property }
+    procedure SetLegendFont(const _LegendFont: TFont);
+    {: @name is the setter method for the @link(Position) property }
+    procedure SetPosition(const _Position: TLegendPosition);
+  public
+    {: @name creates a new @classname object}
+    constructor Create(_Owner: TComponent); override;
+    {: @name destroys a @classname object }
+    destructor Destroy; override;
+  published
+    {: @name describes the font used to draw the legend entries }
+    property LegendFont: TFont read fLegendFont write SetLegendFont;
+    {: @name describes the position of the legend on the chart, if no legend
+       is desired, set to lpNoLegend }
+    property Position: TLegendPosition read fPosition write SetPosition;
+    {: @name describes the legend's frame, that is color, size etc. }
+    property Frame: TdzChartFrame read fFrame;
+    {: @name describes the background color used for the legend }
+    property BackGround: TColor read fBackGround write SetBackGround;
+    {: @name describes the legend's title. If set to an empty string,
+       no space is alloceted for the title. }
+    property Title stored true;
+    {: @name describes the font used to draw the legend's title }
+    property TitleFont;
+    {: @name is the number of columns in the legend }
+    property Columns: integer read fColumns write SetColumns;
+  end;
+
+  {: @name is internally used for storing point descriptions }
+  TdzPointDesc = class
+  protected
+    {: stores the point's X coordinate }
+    fX: double;
+    {: stores the point's Y coordinate }
+    fY: double;
+    {: stores the point's X position in pixels }
+    fXPos: integer;
+    {: stores the point's Y position in pixels }
+    fYPos: integer;
+  public
+    {: @Name creats a new @classname object }
+    constructor Create(const _x, _y: double; _XPos, _YPos: integer);
+  end;
+
+  {: Event procedure used in the @link(TdzXYChart.OnGetPointHint) event.
+     @param(Sender is the sending chart)
+     @param(X is the X coordinate of the point)
+     @param(Y is the Y coordinate of the point)
+     @param(Hint is the hint text, initialized to
+            @code(x = <xvalue>
+                  y = <yvalue>)
+            where the values are formatted calling the FormatLabel method
+            of the respective axis.
+            If set to an empty string, no hint will be displayed.) }
+  TOnGetPointHint = procedure(_Sender: TObject; const _x, _y: double; var _Hint: string) of object;
+
+  {: @name is the custom ancestor of TdzXYChart for drawing XY, scatter, line and bar charts }
+  TdzCustomXYChart = class(TdzCustomChart)
+  private
+  protected
+    {: @name stores the @link(BottomAxis) property }
+    FBottomAxis: TdzChartAxis;
+    {: @name stores the @link(LeftAxis) property }
+    FLeftAxis: TdzChartAxis;
+    {: @name stores the @link(Legend) property }
+    FLegend: TdzXYChartLegend;
+    {: @name stores the @link(MinX) property }
+    fMinX: Double;
+    {: @name stores the @link(MinY) property }
+    fMinY: Double;
+    {: @name stores the @link(MaxX) property }
+    fMaxX: Double;
+    {: @name stores the @link(MaxY) property }
+    fMaxY: Double;
+    {: @name stores an internally used list of @link(TdzPointDesc) objects }
+    fPoints: TObjectList;
+    {: @name stores an internally used list of IdzSingleValueDataSeries and
+       IdzMultiValueDataSeries interfaces }
+    fDataSeriesList: IInterfaceList;
+    {: @name stores the OnScaling event }
+    FOnScaling: TOnScaling;
+    {: @name stores the OnGetPointHint event }
+    FOnGetPointHint: TOnGetPointHint;
+    {: @name calculates the width of the bars in a bar chart }
+    function CalcBarWidth(const _Target: IdzGraphics): integer;
+    {: @name gets the maximum point count for all data series }
+    function GetDataSeriesMaxPointCount: integer;
+    {: @name draws a single point in a XY or Scatter chart
+       @param(Series is the data series for this point)
+       @param(AbsX is the absolute X position of the point in pixels (after scaling))
+       @param(AbsY is the absolute Y position of the point in pixels (after scaling))
+       @param(ForLegend is a boolean determining whether the point is drawn for
+              the legend or for the actual chart. This will switch the meaning of
+              psHorizontalLine and psVerticalLine for the legend.) }
+    procedure DrawPoint(const _Target: IdzGraphics; const _Series: IdzDataSeries; _AbsX, _AbsY: integer; _ForLegend: boolean = false);
+    {: @name draws a line between the given coordnates for a XY or line chart
+       @param(Series is the data series for this line)
+       @param(X1 is the X coordinate of the starting point in pixels (after scaling))
+       @param(Y1 is the Y coordinate of the starting point in pixels (after scaling))
+       @param(X2 is the X coordinate of the end point in pixels (after scaling))
+       @param(Y2 is the Y coordinate of the end point in pixels (after scaling)) }
+    procedure DrawLine(const _Target: IdzGraphics; const _Series: IdzDataSeries; _X1, _Y1, _X2, _Y2: integer);
+    {: @name calculates space for the chart's area by first calling the inherited method and
+       then substracting the space for the legend and the axis descriptions. }
+    function CalcChartRect(const _Target: IdzGraphics): TRect; override;
+    {: @name calculates space for the chart's drawing area (used for values) }
+    function CalcDrawRect(const _Target: IdzGraphics): TRect;
+    {: @name calculates the space used for the chart's legend }
+    function CalcLegendRect(const _Target: IdzGraphics; var _ChartRect: TRect): TRect;
+    {: @name scales the chart to the available drawing space }
+    procedure ScaleChart; override;
+    {: @name transform point's data to chart dimension for a given axis
+       (used internally by @link(NormalizePtX) and @link(NormalizeptY))
+       @param(Point is the point's position in regard to an axis)
+       @param(Min is the minimum of the axis)
+       @param(Max is the maximum of the axis)
+       @param(Size is the length of the axis in pixels) }
+    function NormalizePt(const _Point, _Min, _Max: double; _Size: integer): double;
+    {: @name transforms X-axis data to chart dimensions
+       @param(Point is the X-axis position of a point) }
+    function NormalizePtX(const _Target: IdzGraphics; const _Point: Double): Double;
+    {: @name transforms Y-axis data to chart dimensions
+       @param(Point is the Y-axis position of a point) }
+    function NormalizePtY(const _Target: IdzGraphics; const _Point: Double): Double;
+    {: @name draws the grid at the label positions of both axis
+       @param(Rect is the space used for the grid) }
+    procedure DrawGrid(const _Target: IdzGraphics; _Rect: TRect); override;
+    {: @name drawas the chart's bottom scale including ticks and labels }
+    procedure DrawBottomScale(const _Target: IdzGraphics); override;
+    {: @name drawas the chart's left scale including ticks and labels }
+    procedure DrawLeftScale(const _Target: IdzGraphics); override;
+    {: @name draws the chart's data points, lines and bars }
+    procedure DrawDataPoints(const _Target: IdzGraphics); override;
+    {: @name draws the frame items of the chart, that is the title, the legend and the
+       axis scales }
+    procedure DrawFrameItems(const _Target: IdzGraphics); override;
+    {: @name draws a legend entry for a data series
+       @param(Canvas is the canvas used for drawing)
+       @param(Series is the data series for which to draw the legend entry)
+       @param(X is the X coordinate in pixels of the entry)
+       @param(Y is the Y coordinate in pixels of the entry) }
+    procedure DrawLegendEntry(const _Target: IdzGraphics; const _Series: IdzDataSeries; _X, _Y: integer);
+    {: @name draws the chart's legend
+       @param(Canvas is the canvas used for drawing)
+       @param(LegendRect is the space for the legend) }
+    procedure DrawLegend(const _Target: IdzGraphics; _LegendRect: TRect);
+    {: @name overrides the inherited method to conditionally display point hints
+       @param(Shift describes the special keys pressed)
+       @param(X is the X coordinate in pixels of the mouse pointer)
+       @param(Y is the Y coordinate in pixels of the mouse pointer) }
+    procedure MouseMove(_Shift: TShiftState; _X, _Y: Integer); override;
+    {: @name calls the OnGetPointHint event if assigned }
+    procedure doGetPointHint(const _X, _Y: double; var _Hint: string);
+
+    property MinX: Double read fMinX;
+    property MaxX: Double read fMaxX;
+    property MinY: Double read fMinY;
+    property MaxY: Double read fMaxY;
+    property BottomAxis: TdzChartAxis read FBottomAxis;
+    property LeftAxis: TdzChartAxis read FLeftAxis;
+    property Legend: TdzXYChartLegend read FLegend;
+    property OnScaling: TOnScaling read FOnScaling write FOnScaling;
+    property OnGetPointHint: TOnGetPointHint read FOnGetPointHint write FOnGetPointHint;
+  public
+    constructor Create(AOwner: TComponent); override;
+    destructor Destroy; override;
+    {: Add a data series to the chart. (Note: the parameter is not 'const' because
+       this could run havoc with reference counting)
+       @param(DataSeries is a IdzSingleValueDataSeries or IdzMultiValueDataSeries
+              interface for a data series to add) }
+    function AddDataSeries(_DataSeries: IdzDataSeries): integer;
+    function RemoveDataSeries(const _DataSeries: IdzDataSeries): integer;
+  published
+  end;
+
+  TdzXYChart = class(TdzCustomXYChart)
+  published
+    property OnScaling;
+    property OnGetPointHint;
+    property Align;
+    property BackGround;
+    property ChartColor;
+    property Font;
+    property Grid;
+    property ChartTitle;
+    property BottomAxis;
+    property LeftAxis;
+    property Legend;
+    property ChartFrame;
+  end;
+
+implementation
+
+type
+  TLineDescription = class
+  protected
+    fColor: TColor;
+    fDescription: string;
+  public
+    constructor Create(_Color: TColor; const _Description: string);
+    property Color: TColor read fColor;
+    property Description: string read fDescription;
+  end;
+
+  { TLineDescription }
+
+constructor TLineDescription.Create(_Color: TColor; const _Description: string);
+begin
+  inherited Create;
+  fColor := _Color;
+  fDescription := _Description;
+end;
+
+{ TdzCustomXYChart }
+
+constructor TdzCustomXYChart.Create(AOwner: TComponent);
+begin
+  inherited Create(AOwner);
+
+  fPoints := TObjectList.Create;
+
+  FBottomAxis := TdzBottomChartAxis.Create(Self);
+  FBottomAxis.SetSubComponent(true);
+  FBottomAxis.Name := self.Name + 'BottomAxis';
+  FBottomAxis.Title := DEFAULT_X_AXIS_NAME;
+  FBottomAxis.TitleFont.Name := 'Arial';
+  FBottomAxis.TitleFont.Size := 8;
+  FBottomAxis.LabelFont.Name := 'Arial';
+  FBottomAxis.LabelFont.Size := 8;
+
+  FLeftAxis := TdzLeftChartAxis.Create(self);
+  FLeftAxis.SetSubComponent(true);
+  FLeftAxis.Name := self.Name + 'LeftAxis';
+  FLeftAxis.Title := DEFAULT_Y_AXIS_NAME;
+  FLeftAxis.TitleFont.Name := 'Arial';
+  FLeftAxis.TitleFont.Size := 8;
+
+  FLegend := TdzXYChartLegend.Create(Self);
+  FLegend.SetSubComponent(true);
+  FLegend.Name := self.Name + 'Legend';
+  FLegend.Position := lpBottom;
+  FLegend.Title := DEFAULT_LEGEND_TITLE;
+  FLegend.TitleFont.Name := 'Arial';
+  FLegend.TitleFont.Size := 8;
+  FLegend.TitleFont.Style := [fsBold];
+  FLegend.LegendFont.Name := 'Arial';
+  FLegend.LegendFont.Size := 8;
+  FLegend.BackGround := clWhite;
+  FLegend.Columns := 1;
+
+  fDataSeriesList := TInterfaceList.Create;
+
+  fMinX := -1;
+  fMaxX := 1;
+  fMinY := -1;
+  fMaxY := 1;
+end;
+
+destructor TdzCustomXYChart.Destroy;
+var
+  i: integer;
+begin
+  FreeAndNil(fPoints);
+
+  for i := 0 to fDataSeriesList.Count - 1 do
+    (fDataSeriesList[i] as IdzDataSeries).Notification(Self, opRemove);
+  FLegend.Free;
+  FBottomAxis.Free;
+  FLeftAxis.Free;
+  fDataSeriesList := nil;
+  inherited Destroy;
+end;
+
+function TdzCustomXYChart.CalcLegendRect(const _Target: IdzGraphics; var _ChartRect: TRect): TRect;
+var
+  Cnvs: IdzCanvas;
+
+  function CalcLongestSeriesText: integer;
+  var
+    i: integer;
+    w: integer;
+    Series: IdzDataSeries;
+  begin
+    Result := 0;
+    for i := 0 to fDataSeriesList.Count - 1 do
+      begin
+        Series := fDataSeriesList[i] as IdzDataSeries;
+        w := Cnvs.TextWidth(Series.GetCaption);
+        if w > Result then
+          Result := w;
+      end;
+  end;
+
+var
+  i: integer;
+  Cnt: integer;
+  h: integer;
+  MaxW: integer;
+  TitleWidth: integer;
+begin
+  Result := _ChartRect;
+
+  if fLegend.Position = lpNoLegend then
+    begin
+      // no legend -> size 0
+      Result.Right := Result.Left;
+      Result.Bottom := Result.Top;
+      exit;
+    end;
+
+  Cnvs := _Target.Canvas;
+  if fLegend.Title <> '' then
+    begin
+      Cnvs.Font := fLegend.TitleFont;
+      h := Round(Cnvs.TextHeight('Aj') * 1.5);
+      TitleWidth := Cnvs.TextWidth(fLegend.Title);
+    end
+  else
+    begin
+      TitleWidth := 0;
+      h := 0;
+    end;
+  Cnvs.Font := fLegend.LegendFont;
+  Cnt := 0;
+  for i := 0 to fDataSeriesList.Count - 1 do
+    if (fDataSeriesList[i] as IdzDataSeries).GetCaption <> '' then
+      Inc(Cnt);
+  MaxW := (CalcLongestSeriesText + 30 + 8) * fLegend.Columns;
+  h := h + Ceil(Cnt / fLegend.Columns) * Round(Cnvs.TextHeight('Aj') * 1.5);
+  if TitleWidth > MaxW then
+    MaxW := TitleWidth;
+  h := h + 8;
+  MaxW := MaxW;
+  case fLegend.Position of
+    lpLeft:
+      begin
+        Result.Right := Result.Left + MaxW;
+        Result.Top := (Result.Bottom - Result.Top - h) div 2;
+        Result.Bottom := Result.Top + h;
+        _ChartRect.Left := _ChartRect.Left + MaxW + 8;
+      end;
+    lpRight:
+      begin
+        Result.Left := Result.Right - MaxW;
+        Result.Top := (Result.Bottom - Result.Top - h) div 2;
+        Result.Bottom := Result.Top + h;
+        _ChartRect.Right := _ChartRect.Right - MaxW - 8;
+      end;
+    lpTop:
+      begin
+        Result.Bottom := Result.Top + h;
+        Result.Left := (Result.Right - Result.Left - MaxW) div 2;
+        Result.Right := Result.Left + MaxW;
+        _ChartRect.Top := _ChartRect.Top + h + 8;
+      end;
+    lpBottom:
+      begin
+        Result.Top := Result.Bottom - h;
+        Result.Left := (Result.Right - Result.Left - MaxW) div 2;
+        Result.Right := Result.Left + MaxW;
+        _ChartRect.Bottom := _ChartRect.Bottom - h - 8;
+      end;
+  end;
+end;
+
+function TdzCustomXYChart.CalcChartRect(const _Target: IdzGraphics): TRect;
+var
+  Cnvs: IdzCanvas;
+  LegendRect: TRect;
+begin
+  Result := inherited CalcChartRect(_Target);
+
+  // in addition leave some space for the Axis labels and the legend
+
+  LegendRect := CalcLegendRect(_Target, Result);
+
+  Cnvs := _Target.Canvas;
+
+  // leave 1.5 times the axis caption height for the axis captions
+  fLeftAxis.InitDefaultLabels(0, MinY, MaxY, Cnvs);
+  Result.Left := Result.Left + LeftAxis.CalcLabelingSpace(Cnvs);
+
+  fBottomAxis.InitDefaultLabels(0, MinX, MaxX, Cnvs);
+  Result.Bottom := Result.Bottom - BottomAxis.CalcLabelingSpace(Cnvs);
+end;
+
+{ CalcDrawRect - get area for drawing }
+
+function TdzCustomXYChart.CalcDrawRect(const _Target: IdzGraphics): TRect;
+begin
+  Result := CalcChartRect(_Target);
+  { offset inwards 3 and 4 percent }
+  Result.Left := Result.Left + ((4 * Width) div 100);
+  Result.Top := Result.Top + ((3 * Width) div 100);
+  Result.Right := Result.Right - ((4 * Width) div 100);
+  Result.Bottom := Result.Bottom - ((3 * Width) div 100);
+end;
+
+function TdzCustomXYChart.GetDataSeriesMaxPointCount: integer;
+var
+  i: integer;
+  Series: IdzDataSeries;
+begin
+  Result := 0;
+  for i := 0 to fDataSeriesList.Count - 1 do
+    begin
+      Series := fDataSeriesList[i] as IdzDataSeries;
+      if Series.GetPointCount > Result then
+        Result := Series.GetPointCount;
+    end;
+end;
+
+{ GetBarWidth - get width of bars for bar chart }
+
+function TdzCustomXYChart.CalcBarWidth(const _Target: IdzGraphics): integer;
+const
+  MaxBarWidth: integer = 15;
+var
+  DrawRect: TRect;
+  PointCount: integer;
+begin
+  DrawRect := CalcDrawRect(_Target);
+  PointCount := GetDataSeriesMaxPointCount;
+  if PointCount > 0 then
+    Result := (((DrawRect.Right - DrawRect.Left) div PointCount) div 2)
+  else
+    Result := DrawRect.Right - DrawRect.Left;
+  if Result > MaxBarWidth then
+    Result := MaxBarWidth;
+end;
+
+{ ScaleChart - calculate extrema }
+
+procedure TdzCustomXYChart.ScaleChart;
+var
+  i: integer;
+  MinX, MaxX: double;
+  MinY, MaxY: double;
+  dbl: double;
+  SumHalf: double;
+  AbsDiffHalf: double;
+  Series: IdzDataSeries;
+  First: boolean;
+begin
+  // determine min and max values from all data series
+  if BottomAxis.Scale.Automatic then
+    begin
+      fMinX := Infinity;
+      fMaxX := NegInfinity;
+    end
+  else
+    begin
+      fMinX := BottomAxis.Scale.Min;
+      fMaxX := BottomAxis.Scale.Max;
+    end;
+  if LeftAxis.Scale.Automatic then
+    begin
+      fMinY := Infinity;
+      fMaxY := NegInfinity;
+    end
+  else
+    begin
+      fMinY := LeftAxis.Scale.Min;
+      fMaxY := LeftAxis.Scale.Max;
+    end;
+
+  First := True;
+  for i := 0 to fDataSeriesList.Count - 1 do
+    begin
+      Series := fDataSeriesList[i] as IdzDataSeries;
+      if Series.GetMinAndMax(MinX, MaxX, MinY, MaxY) then
+        begin
+          if BottomAxis.Scale.Automatic then
+            begin
+              if not IsInfinite(MaxX) and not IsInfinite(MinX) then
+                begin
+                  SumHalf := (MaxX + MinX) / 2;
+                  AbsDiffHalf := abs(MaxX - MinX) / 2;
+
+                  dbl := SumHalf - AbsDiffHalf;
+                  if First or (dbl < fMinX) then
+                    fMinX := dbl;
+
+                  dbl := SumHalf + AbsDiffHalf;
+                  if First or (dbl > fMaxX) then
+                    fMaxX := dbl;
+                end;
+            end;
+
+          if LeftAxis.Scale.Automatic then
+            begin
+              if not IsInfinite(MaxY) and not IsInfinite(MinY) then
+                begin
+                  SumHalf := (MaxY + MinY) / 2;
+                  AbsDiffHalf := abs(MaxY - MinY) / 2;
+
+                  dbl := SumHalf - AbsDiffHalf;
+                  if First or (dbl < fMinY) then
+                    fMinY := dbl;
+
+                  dbl := SumHalf + AbsDiffHalf;
+                  if First or (dbl > fMaxY) then
+                    fMaxY := dbl;
+                end;
+            end;
+          First := False;
+        end;
+    end;
+
+  if IsInfinite(fMinX) then
+    fMinX := 0;
+  if IsInfinite(fMaxX) then
+    fMaxX := 0;
+  if IsInfinite(fMinY) then
+    fMinY := 0;
+  if IsInfinite(fMaxY) then
+    fMaxY := 0;
+
+  if Assigned(FOnScaling) then
+    FOnScaling(Self, fMinX, fMaxX, fMinY, fMaxY);
+
+  // make sure minima and maxima are not equal or in wrong order
+  if fMaxX - fMinX <= 0 then
+    begin
+      fMinX := fMaxX - 0.1;
+      fMaxX := fMaxX + 0.1;
+    end;
+  if fMaxY - fMinY <= 0 then
+    begin
+      fMinY := fMaxY - 0.1;
+      fMaxY := fMaxY + 0.1;
+    end;
+end;
+
+{ procedure to draw grids if desired }
+
+procedure TdzCustomXYChart.DrawGrid(const _Target: IdzGraphics; _Rect: TRect);
+var
+  Cnvs: IdzCanvas;
+  GraphWd: integer;
+  GraphHt: integer;
+  RangeX: double;
+  RangeY: double;
+  DrawRect: TRect;
+  ChartRect: TRect;
+
+  procedure DoDrawGridX(_Pos: double);
+  var
+    XPos: integer;
+  begin
+    XPos := Round(DrawRect.Left + ((_Pos - fMinX) * GraphWd) / RangeX);
+    Cnvs.Line(XPos, ChartRect.Top + FChartFrame.Width, XPos, ChartRect.Bottom - FChartFrame.Width);
+  end;
+
+  procedure DoDrawGridY(_Pos: double);
+  var
+    YPos: integer;
+  begin
+    YPos := Round(DrawRect.Bottom - ((_Pos - fMinY) * GraphHt) / RangeY);
+    Cnvs.Line(ChartRect.Left + FChartFrame.Width, YPos, ChartRect.Right - FChartFrame.Width, YPos);
+  end;
+
+var
+  Idx: integer;
+  Value: double;
+begin
+  if FGrid.GridType = gtNone then
+    Exit;
+  DrawRect := CalcDrawRect(_Target);
+  ChartRect := CalcChartRect(_Target);
+  Cnvs := _Target.Canvas;
+  Cnvs.Pen.Width := 1;
+  GraphWd := (DrawRect.Right - DrawRect.Left);
+  GraphHt := (DrawRect.Bottom - DrawRect.Top);
+
+  RangeX := fMaxX - fMinX;
+  RangeY := fMaxY - fMinY;
+
+  Cnvs.Pen.Color := FGrid.Color;
+  Cnvs.Pen.Style := FGrid.LineStyle;
+
+  if Grid.GridType in [gtVert, gtBoth] then
+    begin
+      BottomAxis.InitDefaultLabels(GraphWd, fMinX, fMaxX, Cnvs);
+      Value := fMinX;
+      Idx := 0;
+      while not BottomAxis.GetNextLabel(Idx, Value) do
+        begin
+          DoDrawGridX(Value);
+          Inc(Idx);
+        end;
+    end;
+
+  if Grid.GridType in [gtBoth, gtHorz] then
+    begin
+      LeftAxis.InitDefaultLabels(GraphHt, fMinY, fMaxY, Cnvs);
+      Value := fMinY;
+      Idx := 0;
+      while not LeftAxis.GetNextLabel(Idx, Value) do
+        begin
+          DoDrawGridY(Value);
+          Inc(Idx);
+        end;
+    end;
+end;
+
+procedure TdzCustomXYChart.DrawBottomScale;
+var
+  DrawRect: TRect;
+  ChartRect: TRect;
+  Cnvs: IdzCanvas;
+  TextHeight: integer;
+
+  procedure DoDrawScale(_Offs: integer; _Value: Double);
+  var
+    s: string;
+    x: integer;
+    y: integer;
+    w: integer;
+  begin
+    s := BottomAxis.FormatLabel(_Value);
+    x := DrawRect.Left + _Offs;
+    y := ChartRect.Bottom;
+    if BottomAxis.LabelOrientation = loVertical then
+      w := Cnvs.TextWidthAngle(90, s)
+    else
+      w := Cnvs.TextWidth(s);
+
+    Cnvs.Line(x, y, x, y - FChartFrame.Width - 5);
+
+    if FBottomAxis.LabelOrientation = loVertical then
+      begin
+        x := x + 1;
+{$IFDEF MSWINDOWS}
+        // x is used differently in Windows and QT
+        // in Windows x is the left point of the text
+        // in QT it is the base line
+        // this should really be handled in TextOutAngle, but ...
+        x := x - TextHeight div 2;
+{$ENDIF MSWINDOWS}
+{$IFDEF LINUX} // maybe this should really be "ifdef QT" or something
+        x := x + TextHeight div 4;
+{$ENDIF LINUX}
+        Cnvs.TextOutAngle(90, x, y + 3 + w, s)
+      end
+    else
+      Cnvs.TextOut(x + 1 - w div 2, y + 3, s);
+  end;
+
+var
+  Idx: integer;
+  Value: double;
+  GraphWid: integer;
+  Range: Double;
+begin
+  ChartRect := CalcChartRect(_Target);
+  DrawRect := CalcDrawRect(_Target);
+  GraphWid := (DrawRect.Right - DrawRect.Left);
+  Range := fMaxX - fMinX;
+  Cnvs := _Target.Canvas;
+  Cnvs.Pen.Color := clBlack;
+  Cnvs.Brush.Color := FBackGround;
+  Cnvs.Font := fBottomAxis.LabelFont;
+  FBottomAxis.InitDefaultLabels(GraphWid, fMinX, fMaxX, Cnvs);
+  TextHeight := Cnvs.TextHeight('Aj');
+  Value := fMinX;
+  Idx := 0;
+  while not FBottomAxis.GetNextLabel(Idx, Value) do
+    begin
+      DoDrawScale(Round(((Value - fMinX) * GraphWid) / Range), Value);
+      Inc(Idx);
+    end;
+end;
+
+procedure TdzCustomXYChart.DrawLeftScale;
+var
+  GraphHt: integer;
+  DrawRect: TRect;
+  ChartRect: TRect;
+  Cnvs: IdzCanvas;
+  TextHeight: integer;
+
+  procedure DoDrawScale(_Offs: integer; _Value: Double);
+  var
+    S: string;
+    x: integer;
+    y: integer;
+    w: integer;
+  begin
+    S := FLeftAxis.FormatLabel(_Value);
+    x := ChartRect.Left;
+    y := DrawRect.Bottom - _Offs;
+    w := Cnvs.TextWidth(s);
+
+    Cnvs.Line(x, y, x + FChartFrame.Width + 5, y);
+
+    if FLeftAxis.LabelOrientation = loVertical then
+      begin
+        x := x - 3;
+{$IFDEF MSWINDOWS}
+        // x is used differently in Windows and QT
+        // in Windows x is the left point of the text
+        // in QT it is the base line
+        // this should really be handled in TextOutAngle, but ...
+        x := x - TextHeight;
+{$ENDIF MSWINDOWS}
+        Cnvs.TextOutAngle(90, x, y + (w div 2), S);
+      end
+    else
+      Cnvs.TextOut(x - 3 - w, y - (TextHeight div 2), S);
+  end;
+
+  function Log10Z(const _Value: double): extended;
+  begin
+    if _Value = 0 then
+      Result := 0
+    else
+      Result := Log10(_Value);
+  end;
+
+var
+  Idx: integer;
+  Value: double;
+  Range: Double;
+begin
+  ChartRect := CalcChartRect(_Target);
+  DrawRect := CalcDrawRect(_Target);
+  GraphHt := (DrawRect.Bottom - DrawRect.Top);
+  Range := fMaxY - fMinY;
+  Cnvs := _Target.Canvas;
+  Cnvs.Pen.Color := clBlack;
+  Cnvs.Brush.Color := FBackGround;
+  Cnvs.Font := FLeftAxis.LabelFont;
+  TextHeight := Cnvs.TextHeight('Aj');
+  FLeftAxis.InitDefaultLabels(GraphHt, fMinY, fMaxY, Cnvs);
+  Value := fMinY;
+  Idx := 0;
+  while not FLeftAxis.GetNextLabel(Idx, Value) do
+    begin
+//      case LeftAxis.Scale.ScaleType of
+//        stLogarithmic:
+//          DoDrawScale(Round(Log10Z(Value) * GraphHt), Value);
+//      else
+        DoDrawScale(Round(((Value - fMinY) * GraphHt) / Range), Value);
+//      end;
+      Inc(Idx);
+    end;
+end;
+
+function TdzCustomXYChart.NormalizePt(const _Point, _Min, _Max: double; _Size: integer): double;
+var
+  Range: double;
+begin
+  Result := _Point;
+  Range := _Max - _Min;
+  if Range > 0 then
+    Result := ((Result - _Min) * _Size) / Range;
+end;
+
+{ NormalizePtX - transform  X-axis data to chart dimensions }
+
+function TdzCustomXYChart.NormalizePtX(const _Target: IdzGraphics; const _Point: Double): Double;
+var
+  DrawRect: TRect;
+begin
+  DrawRect := CalcDrawRect(_Target);
+  Result := NormalizePt(_Point, fMinX, fMaxX, DrawRect.Right - DrawRect.Left);
+end;
+
+{ NormalizePtY - transform  Y-axis data to chart dimensions }
+
+function TdzCustomXYChart.NormalizePtY(const _Target: IdzGraphics; const _Point: Double): Double;
+var
+  DrawRect: TRect;
+begin
+  DrawRect := CalcDrawRect(_Target);
+  Result := NormalizePt(_Point, fMinY, fMaxY, DrawRect.Bottom - DrawRect.Top);
+end;
+
+procedure TdzCustomXYChart.DrawPoint(const _Target: IdzGraphics; const _Series: IdzDataSeries; _AbsX, _AbsY: integer; _ForLegend: boolean);
+const // for a equilateral triangle
+  a = 9;
+  e = a / 1.7320508075689; // sqrt(3)
+  d = e / 2;
+const
+  ARROW_LENGTH = 7;
+  ARROW_WIDTH = 4;
+var
+  Cnvs: IdzCanvas;
+begin
+  Cnvs := _Target.Canvas;
+  Cnvs.Pen.Color := _Series.GetPointColor;
+  Cnvs.Pen.Style := psSolid;
+  Cnvs.Pen.Width := 1;
+  Cnvs.Brush.Color := _Series.GetFillColor;
+  Cnvs.Brush.Style := bsSolid;
+  case _Series.GetPointStyle of
+    psRectangle:
+      begin
+        Cnvs.Rectangle(_AbsX - 3, _AbsY - 3, _AbsX + 4, _AbsY + 4);
+      end;
+    psCircle:
+      begin
+        Cnvs.Ellipse(_AbsX - 3, _AbsY - 3, _AbsX + 4, _AbsY + 4);
+      end;
+    psTriangle:
+      begin
+        Cnvs.DrawPolygon([Point(_AbsX, _AbsY - round(e)),
+          Point(_AbsX - Round(a / 2), _AbsY + round(d)),
+            Point(_AbsX + Round(a / 2), _AbsY + round(d)),
+            Point(_AbsX, _AbsY - round(e))]);
+      end;
+    psDownTriangle:
+      begin
+        Cnvs.DrawPolygon([Point(_AbsX, _AbsY + round(e)),
+          Point(_AbsX + Round(a / 2), _AbsY - round(d)),
+            Point(_AbsX - Round(a / 2), _AbsY - round(d)),
+            Point(_AbsX, _AbsY + round(e))]);
+      end;
+    psCross:
+      begin
+        Cnvs.Line(_AbsX + 3, _AbsY, _AbsX - 3, _AbsY);
+        Cnvs.Line(_AbsX, _AbsY + 3, _AbsX, _AbsY - 3);
+      end;
+    psDiagCross:
+      begin
+        Cnvs.Line(_AbsX - 3, _AbsY - 3, _AbsX + 3, _AbsY + 3);
+        Cnvs.Line(_AbsX - 3, _AbsY + 3, _AbsX + 3, _AbsY - 3);
+      end;
+    psStar:
+      begin
+        Cnvs.Line(_AbsX + 3, _AbsY + 3, _AbsX - 3, _AbsY - 3);
+        Cnvs.Line(_AbsX + 3, _AbsY - 3, _AbsX - 3, _AbsY + 3);
+        Cnvs.Line(_AbsX - 3, _AbsY, _AbsX + 3, _AbsY);
+        Cnvs.Line(_AbsX, _AbsY - 3, _AbsX, _AbsY + 3);
+      end;
+    psDiamond:
+      begin
+        Cnvs.DrawPolygon([
+          Point(_AbsX, _AbsY + 4),
+            Point(_AbsX + 4, _AbsY),
+            Point(_AbsX, _AbsY - 4),
+            Point(_AbsX - 4, _AbsY),
+            Point(_AbsX, _AbsY + 4)]);
+      end;
+    psSmallDot:
+      Cnvs.Ellipse(_AbsX - 1, _AbsY - 1, _AbsX + 2, _AbsY + 2);
+    psDownArrow:
+      begin
+        Cnvs.DrawPolygon([
+          Point(_AbsX, _AbsY),
+            Point(_AbsX - ARROW_WIDTH, _AbsY - ARROW_WIDTH),
+            Point(_AbsX - 1, _AbsY - ARROW_WIDTH),
+            Point(_AbsX - 1, _AbsY - ARROW_LENGTH),
+            Point(_AbsX + 1, _AbsY - ARROW_LENGTH),
+            Point(_AbsX + 1, _AbsY - ARROW_WIDTH),
+            Point(_AbsX + ARROW_WIDTH, _AbsY - ARROW_WIDTH),
+            Point(_AbsX, _AbsY)]);
+      end;
+    psUpArrow:
+      begin
+        Cnvs.DrawPolygon([
+          Point(_AbsX, _AbsY),
+            Point(_AbsX - ARROW_WIDTH, _AbsY + ARROW_WIDTH),
+            Point(_AbsX - 1, _AbsY + ARROW_WIDTH),
+            Point(_AbsX - 1, _AbsY + ARROW_LENGTH),
+            Point(_AbsX + 1, _AbsY + ARROW_LENGTH),
+            Point(_AbsX + 1, _AbsY + ARROW_WIDTH),
+            Point(_AbsX + ARROW_WIDTH, _AbsY + ARROW_WIDTH),
+            Point(_AbsX, _AbsY)]);
+      end;
+    psHorizontalLine:
+      begin
+        if _ForLegend then
+          Cnvs.Line(_AbsX, _AbsY + 3, _AbsX, _AbsY - 3)
+        else
+          Cnvs.Line(_AbsX + 3, _AbsY, _AbsX - 3, _AbsY);
+      end;
+    psVerticalLine:
+      begin
+        if _ForLegend then
+          Cnvs.Line(_AbsX + 3, _AbsY, _AbsX - 3, _AbsY)
+        else
+          Cnvs.Line(_AbsX, _AbsY + 3, _AbsX, _AbsY - 3);
+      end;
+  else // psNone
+    // no points
+  end;
+end;
+
+procedure TdzCustomXYChart.DrawLine(const _Target: IdzGraphics; const _Series: IdzDataSeries; _X1, _Y1, _X2, _Y2: integer);
+var
+  Cnvs: IdzCanvas;
+begin
+  Cnvs := _Target.Canvas;
+  Cnvs.Pen.Color := _Series.GetLineColor;
+  Cnvs.Pen.Style := _Series.GetLineStyle;
+  Cnvs.Pen.Width := 1;
+  Cnvs.Line(_X1, _Y1, _X2, _Y2);
+end;
+
+function ComparePoints(_Item1, _Item2: pointer): integer;
+var
+  Pd1: TdzPointDesc;
+  pd2: TdzPointDesc;
+begin
+  pd1 := _Item1;
+  pd2 := _Item2;
+  Result := Pd2.fXPos - Pd1.fXPos;
+  if Result = 0 then
+    Result := Pd2.fYPos - pd1.fYPos;
+end;
+
+procedure TdzCustomXYChart.DrawDataPoints(const _Target: IdzGraphics);
+var
+  Cnvs: IdzCanvas;
+  DrawRect: TRect;
+  ChartRect: TRect;
+  BarWidth: integer;
+
+  procedure DrawBar(const _Series: IdzDataSeries; const _Point: IdzDataPoint);
+  begin
+    Cnvs.Pen.Color := _Series.GetLineColor;
+    Cnvs.Pen.Width := 1;
+    Cnvs.Brush.Style := bsSolid;
+    Cnvs.Brush.Color := _Series.GetFillColor;
+    Cnvs.Rectangle(DrawRect.Left + Ceil(NormalizePtX(_Target, _Point.GetX)) - BarWidth,
+      DrawRect.Bottom - Round(NormalizePtY(_Target, _Point.GetY)),
+      DrawRect.Left + Floor(NormalizePtX(_Target, _Point.GetX)) + BarWidth,
+      DrawRect.Bottom);
+  end;
+
+  procedure DrawSeriesLines(const _Series: IdzSingleValueDataSeries); overload;
+
+    function CalcPointX(const _Value: double): integer;
+    begin
+      if _Series.GetChartType = ctAlternatingLine then
+        begin
+          if IsInfinite(_Value) then
+            begin
+              if Sign(_Value) < 0 then
+                Result := ChartRect.Left
+              else
+                Result := ChartRect.Right;
+            end
+          else
+            begin
+               Result := DrawRect.Left + Round(NormalizePtX(_Target, _Value));
+               if Result < ChartRect.Left then
+                 Result := ChartRect.Left
+               else if Result > ChartRect.Right then
+                 Result := ChartRect.Right;
+            end;
+        end
+      else
+        Result := DrawRect.Left + Round(NormalizePtX(_Target, _Value));
+    end;
+
+    function CalcPointY(const _Value: double): integer;
+    begin
+      if _Series.GetChartType = ctAlternatingLine then
+        begin
+          if IsInfinite(_Value) then
+            begin
+              if Sign(_Value) < 0 then
+                Result := ChartRect.Bottom
+              else
+                Result := ChartRect.Top;
+            end
+          else
+            begin
+              Result := DrawRect.Bottom - Round(NormalizePtY(_Target, _Value));
+              if Result > ChartRect.Bottom then
+                Result := ChartRect.Bottom
+              else if Result < ChartRect.Top then
+                Result := ChartRect.Top;
+            end;
+        end
+      else
+        Result := DrawRect.Bottom - Round(NormalizePtY(_Target, _Value));
+    end;
+
+  var
+    Point: IdzDataPoint;
+    i: integer;
+    x, y: integer;
+    OldX, OldY: integer;
+    LineIsOn: boolean;
+  begin
+    if not (_Series.GetChartType in [ctLine, ctXY, ctAlternatingLine]) then
+      exit; // no lines for other types
+
+    Point := _Series.GetDataPoint(0);
+    OldX := CalcPointX(Point.GetX);
+    OldY := CalcPointY(Point.GetY);
+    LineIsOn := true;
+    for i := 1 to _Series.GetPointCount - 1 do
+      begin
+        Point := _Series.GetDataPoint(i);
+        x := CalcPointX(Point.GetX);
+        y := CalcPointY(Point.GetY);
+        case _Series.GetChartType of
+          ctLine:
+            begin
+              DrawLine(_Target, _Series, OldX, OldY, x, y);
+            end;
+          ctAlternatingLine:
+            begin
+              if LineIsOn then
+                DrawLine(_Target, _Series, OldX, OldY, x, y);
+              LineIsOn := not LineIsOn;
+            end;
+          ctXY:
+            begin
+              DrawLine(_Target, _Series, OldX, OldY, x, y);
+              fPoints.Add(TdzPointDesc.Create(Point.GetX, Point.GetY, x, y));
+              DrawPoint(_Target, _Series, x, y);
+            end;
+        end;
+        Oldx := x;
+        OldY := y;
+      end;
+    if LineIsOn and (_Series.GetChartType = ctAlternatingLine) then
+      DrawLine(_Target, _Series, OldX, OldY, CalcPointX(Infinity), OldY);
+  end;
+
+  procedure DrawSeriesLines(const _Series: IdzMultiValueDataSeries); overload;
+  begin
+  end;
+
+  procedure DrawSeriesPoints(const _Series: IdzSingleValueDataSeries); overload;
+  var
+    Point: IdzDataPoint;
+    i: integer;
+    x, y: integer;
+    Value: double;
+  begin
+    if not (_Series.GetChartType in [ctBar, ctScatter, ctXY, ctAlternatingLine]) then
+      exit; // no point markers for other types
+
+    for i := 0 to _Series.GetPointCount - 1 do
+      begin
+        Point := _Series.GetDataPoint(i);
+
+        Value := Point.GetX;
+        if IsInfinite(Value) then
+          Continue; // infinite points can not be drawn
+        x := DrawRect.Left + Round(NormalizePtX(_Target, Value));
+
+        Value := Point.GetY;
+        if IsInfinite(Value) then
+          Continue; // infinite points can not be drawn
+        y := DrawRect.Bottom - Round(NormalizePtY(_Target, Value));
+
+        case _Series.GetChartType of
+          ctBar:
+            DrawBar(_Series, Point);
+          ctScatter,
+            ctAlternatingLine,
+            ctXY:
+            begin
+              fPoints.Add(TdzPointDesc.Create(Point.GetX, Point.GetY, x, y));
+              DrawPoint(_Target, _Series, x, y);
+            end;
+        end;
+      end;
+  end;
+
+  procedure DrawSeriesPoints(const _Series: IdzMultiValueDataSeries); overload;
+  var
+    Point: IdzMultiValueDataPoint;
+    PtIdx: integer;
+    ValIdx: integer;
+    x, YMin, YMax: integer;
+    YOpen, YClose: integer;
+    y: integer;
+  begin
+    for PtIdx := 0 to _Series.GetPointCount - 1 do
+      begin
+        Point := _Series.GetDataPoint(PtIdx);
+        if Point.GetValueCount = 0 then
+          Continue;
+        x := DrawRect.Left + Round(NormalizePtX(_Target, Point.GetX));
+        YMin := DrawRect.Bottom - Round(NormalizePtY(_Target, Point.GetY(0)));
+        YMax := DrawRect.Bottom - Round(NormalizePtY(_Target, Point.GetY(Point.GetValueCount - 1)));
+        if Point.GetValueCount > 1 then
+          begin
+            YOpen := DrawRect.Bottom - Round(NormalizePtY(_Target, Point.GetY(1)));
+            YClose := DrawRect.Bottom - Round(NormalizePtY(_Target, Point.GetY(Point.GetValueCount - 2)));
+          end
+        else
+          begin
+            YOpen := YMin;
+            YClose := YMax;
+          end;
+        case _Series.GetChartType of
+          ctHighLow:
+            DrawLine(_Target, _Series, x, YMin, x, YMax);
+          ctHighLowOpenClose:
+            begin
+              DrawLine(_Target, _Series, x, YMin, x, YMax);
+              if Point.GetValueCount > 1 then
+                begin
+                  DrawLine(_Target, _Series, x - 5, YOpen, x, YOpen);
+                  DrawLine(_Target, _Series, x, YClose, x + 5, YClose);
+                end;
+            end;
+          ctCandle:
+            begin
+              DrawLine(_Target, _Series, x, YMin, x, YMax);
+              if Point.GetValueCount > 1 then
+                begin
+                  Cnvs.Pen.Color := _Series.GetLineColor;
+                  Cnvs.Pen.Width := 1;
+                  Cnvs.Brush.Style := bsSolid;
+                  if YOpen > YClose then
+                    Cnvs.Brush.Color := _Series.GetBullishColor
+                  else
+                    Cnvs.Brush.Color := _Series.GetBearishColor;
+                  Cnvs.Rectangle(X - 3, YOpen, X + 4, YClose);
+                end;
+            end;
+        end;
+        for ValIdx := 0 to Point.GetValueCount - 1 do
+          begin
+            y := DrawRect.Bottom - Round(NormalizePtY(_Target, Point.GetY(ValIdx)));
+            DrawPoint(_Target, _Series, x, y);
+          end;
+      end;
+  end;
+
+var
+  SeriesIdx: integer;
+  Series: IdzDataSeries;
+  Rgn: hRgn;
+begin
+  fPoints.Clear;
+  ChartRect := CalcChartRect(_Target);
+  DrawRect := CalcDrawRect(_Target);
+  Cnvs := _Target.Canvas;
+  BarWidth := CalcBarWidth(_Target);
+
+  Rgn := CreateRectRgn(ChartRect.Left + 1, ChartRect.Top + 1, ChartRect.Right - 1, ChartRect.Bottom - 1);
+//  Rgn := CreateRectRgn(DrawRect.Left - 5, DrawRect.Top - 5, DrawRect.Right + 5, DrawRect.Bottom + 5);
+  try
+    Cnvs.SetClipRgn(Rgn);
+    for SeriesIdx := 0 to fDataSeriesList.Count - 1 do
+      begin
+        Series := fDataSeriesList[SeriesIdx] as IdzDataSeries;
+        if Series.GetPointCount <> 0 then
+          begin
+            if Series.IsMulti then
+              DrawSeriesLines(Series as IdzMultiValueDataSeries)
+            else
+              DrawSeriesLines(Series as IdzSingleValueDataSeries);
+          end;
+      end;
+
+    for SeriesIdx := 0 to fDataSeriesList.Count - 1 do
+      begin
+        Series := fDataSeriesList[SeriesIdx] as IdzDataSeries;
+        if Series.GetPointCount <> 0 then
+          begin
+            if Series.IsMulti then
+              DrawSeriesPoints(Series as IdzMultiValueDataSeries)
+            else
+              DrawSeriesPoints(Series as IdzSingleValueDataSeries);
+          end;
+      end;
+  finally
+    DeleteObject(Rgn);
+  end;
+
+  Cnvs.Pen.Color := clBlack;
+
+  fPoints.Sort(ComparePoints);
+end;
+
+function TdzCustomXYChart.AddDataSeries(_DataSeries: IdzDataSeries): integer;
+begin
+  if not Supports(_DataSeries, IdzSingleValueDataSeries) and not Supports(_DataSeries, IdzMultiValueDataSeries) then
+    raise EInvalidDataSeries.CreateFmt('%s must implement either IdzSingleValueDataSeries or IdzMultiValueDataSeries',
+      [_DataSeries.GetCaption]);
+  Result := fDataSeriesList.Add(_DataSeries);
+  Refresh;
+end;
+
+function TdzCustomXYChart.RemoveDataSeries(const _DataSeries: IdzDataSeries): integer;
+begin
+  Result := fDataSeriesList.Remove(_DataSeries);
+  Refresh;
+end;
+
+procedure TdzCustomXYChart.DrawLegendEntry(const _Target: IdzGraphics; const _Series: IdzDataSeries; _X, _Y: integer);
+var
+  h: integer;
+  s: string;
+  Cnvs: IdzCanvas;
+begin
+  Cnvs := _Target.Canvas;
+  s := _Series.GetCaption;
+  h := Cnvs.TextHeight(s) div 2;
+  DrawLine(_Target, _Series, _X + 2, _Y + h, _X + 25, _Y + h);
+  DrawPoint(_Target, _Series, _X + 13, _Y + h, true);
+  Cnvs.Brush.Color := FLegend.BackGround;
+  Cnvs.TextOut(_x + 30, _y, s);
+end;
+
+procedure TdzCustomXYChart.DrawLegend(const _Target: IdzGraphics; _LegendRect: TRect);
+
+  procedure DrawLineEntry(const _Canvas: IdzCanvas; const _LineDesc: TLineDescription;
+    _X, _Y: integer);
+  var
+    h: integer;
+    s: string;
+  begin
+    s := _LineDesc.Description;
+    h := _Canvas.TextHeight(s) div 2;
+
+    _Canvas.Pen.Color := _LineDesc.Color;
+    _Canvas.Pen.Style := psSolid;
+    _Canvas.Pen.Width := 1;
+    _Canvas.Line(_X + 2, _Y + h, _X + 25, _Y + h);
+
+    _Canvas.TextOut(_x + 30, _y, s);
+  end;
+
+var
+  Column: integer;
+  Row: integer;
+
+  procedure NextColumn;
+  begin
+    Inc(Column);
+    if Column >= FLegend.Columns then
+      begin
+        Column := 0;
+        Inc(Row);
+      end;
+  end;
+
+var
+  s: string;
+  Offs: integer;
+  h: integer;
+  w: integer;
+  i: integer;
+  Cnvs: IdzCanvas;
+  Series: IdzDataSeries;
+begin
+  if fLegend.Position = lpNoLegend then
+    exit;
+
+  Cnvs := _Target.Canvas;
+  Cnvs.Pen := fLegend.Frame.Pen;
+  Cnvs.Brush.Color := fLegend.BackGround;
+  Cnvs.Brush.Style := bsSolid;
+  if FLegend.Frame.Rounded then
+    Cnvs.RoundRect(_LegendRect.Left, _LegendRect.Top,
+      _LegendRect.Right, _LegendRect.Bottom,
+      15, 15)
+  else
+    Cnvs.Rectangle(_LegendRect);
+
+  Cnvs.Font := FLegend.TitleFont;
+  s := FLegend.Title;
+  h := Cnvs.TextWidth(s);
+  Cnvs.TextOut((_LegendRect.Left + _LegendRect.Right - h) div 2, _LegendRect.Top + 4, s);
+  Offs := Round(Cnvs.TextHeight(s) * 1.5);
+
+  Cnvs.Font := FLegend.LegendFont;
+  w := (_LegendRect.Right - _LegendRect.Left) div FLegend.Columns;
+  h := Round(Cnvs.TextHeight('Aj') * 1.5);
+
+  Column := 0;
+  Row := 0;
+
+  for i := 0 to fDataSeriesList.Count - 1 do
+    begin
+      Series := fDataSeriesList[i] as IdzDataSeries;
+      if Series.GetCaption <> '' then
+        begin
+          DrawLegendEntry(_Target, Series,
+            _LegendRect.Left + 4 + Column * w,
+            _LegendRect.Top + 4 + Offs + Row * h);
+          NextColumn;
+        end;
+    end;
+end;
+
+procedure TdzCustomXYChart.DrawFrameItems(const _Target: IdzGraphics);
+var
+  Cnvs: IdzCanvas;
+  LegendRect: TRect;
+  FrameRect: TRect;
+  ChartRect: TRect;
+  s: string;
+begin
+  inherited;
+  FrameRect := inherited CalcChartRect(_Target);
+  LegendRect := CalcLegendRect(_Target, FrameRect);
+
+  ChartRect := CalcChartRect(_Target);
+
+  Cnvs := _Target.Canvas;
+
+  DrawLegend(_Target, LegendRect);
+
+  Cnvs.Font := FBottomAxis.TitleFont;
+  Cnvs.Brush.Color := fBackGround;
+  s := FBottomAxis.Title;
+  Cnvs.TextOut((ChartRect.Right + ChartRect.Left - Cnvs.TextWidth(s)) div 2,
+    FrameRect.Bottom - Cnvs.TextHeight(s), s);
+
+  Cnvs.Font := FLeftAxis.TitleFont;
+  s := FLeftAxis.Title;
+  Cnvs.TextOutAngle(90, FrameRect.Left,
+    (ChartRect.Bottom + ChartRect.Top + Cnvs.TextWidth(s)) div 2, s);
+end;
+
+procedure TdzCustomXYChart.MouseMove(_Shift: TShiftState; _X, _Y: Integer);
+var
+  i: integer;
+  PointDesc: TdzPointDesc;
+  BestGuess: TdzPointDesc;
+  MinDistance: double;
+  Distance: double;
+  x, y: double;
+  s: string;
+begin
+  inherited;
+  MinDistance := 10;
+  BestGuess := nil;
+  for i := 0 to fPoints.Count - 1 do
+    begin
+      PointDesc := fPoints[i] as TdzPointDesc;
+      if (Abs(PointDesc.fXPos - _X) < 10) and (Abs(PointDesc.fYPos - _Y) < 10) then
+        begin
+          Distance := sqrt(sqr(PointDesc.fXPos - _X) + sqr(PointDesc.fYPos - _Y));
+          if Distance < MinDistance then
+            begin
+              BestGuess := PointDesc;
+              MinDistance := Distance;
+              if MinDistance = 0 then
+                break;
+            end;
+        end;
+    end;
+  if Assigned(BestGuess) then
+    begin
+      x := BestGuess.fX;
+      y := BestGuess.fY;
+
+      s := format('x = %s'#13#10'y = %s',
+        [FBottomAxis.FormatLabel(X),
+        FLeftAxis.FormatLabel(Y)]);
+      doGetPointHint(x, y, s);
+      self.Hint := s;
+      self.ShowHint := s <> '';
+    end
+  else
+    self.ShowHint := false;
+end;
+
+procedure TdzCustomXYChart.doGetPointHint(const _X, _Y: double; var _Hint: string);
+begin
+  if Assigned(fOnGetPointHint) then
+    fOnGetPointHint(self, _X, _Y, _Hint);
+end;
+
+{ TdzCustomChartAxis }
+
+constructor TdzCustomChartAxis.Create(_Owner: TComponent);
+begin
+  inherited Create(_Owner);
+  fNaturalLabelOrientation := loHorizontal;
+  fLabelFont := TFont.Create;
+  fLabelFont.OnChange := self.FontChanged;
+  fLabelOrientation := loHorizontal;
+  fScale := TdzAxisScale.Create(self);
+  fScale.Name := self.Name + 'Scale';
+  fScale.SetSubComponent(true);
+end;
+
+destructor TdzCustomChartAxis.Destroy;
+begin
+  fScale.Free;
+  fLabelFont.Free;
+  inherited;
+end;
+
+function TdzCustomChartAxis.FormatLabel(const _Value: double): string;
+begin
+  Result := FloatToStr(_Value);
+  if Assigned(fOnFormatLabel) then
+    FOnFormatLabel(fChart, _Value, Result);
+end;
+
+function TdzCustomChartAxis.CalcLabelingSpace(const _Canvas: IdzCanvas): integer;
+var
+  i: integer;
+  dbl: double;
+  Max: integer;
+  w: integer;
+begin
+  _Canvas.Font := TitleFont;
+  Result := Round(_Canvas.TextHeight('Aj') * 1.5);
+
+  _Canvas.Font := LabelFont;
+  if LabelOrientation = fNaturalLabelOrientation then
+    begin
+      Max := 0;
+      i := 0;
+      while not Self.GetNextLabel(i, dbl) do
+        begin
+          w := _Canvas.TextWidth(FormatLabel(dbl));
+          if w > Max then
+            Max := w;
+          Inc(i);
+        end;
+      Result := Result + Max;
+    end
+  else
+    Result := Result + _Canvas.TextHeight('Aj');
+end;
+
+function TdzCustomChartAxis.GetNextLabel(_Idx: integer; var _Value: double): boolean;
+begin
+  if Assigned(fOnGetNextLabel) then
+    begin
+      Result := true;
+      fOnGetNextLabel(fChart, _Idx, _Value, Result);
+      exit;
+    end;
+
+  Result := _Idx > fScale.Divisions;
+  if not Result then
+//    case fScale.ScaleType of
+//      stLogarithmic:
+//        begin
+//          _Value := fScale.Min + exp((_Idx * (ln(fScale.Max - fScale.Min) / ln(10)) / fScale.Divisions) * ln(10));
+//        end;
+//    else // stLinear
+      _Value := fScale.Min + _Idx * (fScale.Max - fScale.Min) / fScale.Divisions;
+//    end;
+end;
+
+procedure TdzCustomChartAxis.SetLabelFont(_LabelFont: TFont);
+begin
+  fLabelFont.Assign(_LabelFont);
+end;
+
+procedure TdzCustomChartAxis.SetLabelOrientation(_LabelOrientation: TAxisLabelOrientation);
+begin
+  if _LabelOrientation <> fLabelOrientation then
+    begin
+      fLabelOrientation := _LabelOrientation;
+      RefreshChart;
+    end;
+end;
+
+procedure TdzCustomChartAxis.InitDefaultLabels(_Size: integer; const _Min, _Max: double; const _Canvas: IdzCanvas);
+begin
+  if fScale.Automatic then
+    begin
+      fScale.fMin := _Min;
+      fScale.fMax := _Max;
+
+      if _Size = 0 then
+        fScale.fDivisions := 10
+      else
+        begin
+          _Canvas.Font := LabelFont;
+          if LabelOrientation = fNaturalLabelOrientation then
+            fScale.fDivisions := _Size div (2 * _Canvas.TextHeight('Aj'))
+          else
+            fScale.fDivisions := _Size div (2 * _Canvas.TextWidth(FormatLabel(_Max)));
+          if fScale.fDivisions < 1 then
+            fScale.fDivisions := 1
+          else if fScale.fDivisions > 5 then
+            fScale.fDivisions := 10;
+        end;
+    end;
+end;
+
+{ TdzBottomChartAxis }
+
+constructor TdzBottomChartAxis.Create(_Owner: TComponent);
+begin
+  inherited;
+  fNaturalLabelOrientation := loVertical;
+end;
+
+{ TdzLeftChartAxis }
+
+constructor TdzLeftChartAxis.Create(_Owner: TComponent);
+begin
+  inherited;
+  fNaturalLabelOrientation := loHorizontal;
+end;
+
+{ TdzXYChartLegend }
+
+constructor TdzXYChartLegend.Create(_Owner: TComponent);
+begin
+  inherited;
+  fLegendFont := TFont.Create;
+  fLegendFont.OnChange := self.FontChanged;
+  fFrame := TdzChartFrame.Create(Self, _Owner as TdzCustomChart);
+  fFrame.SetSubComponent(true);
+  FFrame.Name := Self.Name + 'Frame';
+  fFrame.Color := clBlack;
+  fFrame.Width := 1;
+  fFrame.Rounded := false;
+  fColumns := 1;
+end;
+
+destructor TdzXYChartLegend.Destroy;
+begin
+  fFrame.Free;
+  fLegendFont.Free;
+  inherited;
+end;
+
+procedure TdzXYChartLegend.SetBackGround(const _Background: TColor);
+begin
+  if fBackGround <> _Background then
+    begin
+      fBackGround := _Background;
+      RefreshChart;
+    end;
+end;
+
+procedure TdzXYChartLegend.SetColumns(_Columns: integer);
+begin
+  if _Columns < 1 then
+    _Columns := 1;
+  if fColumns <> _Columns then
+    begin
+      fColumns := _Columns;
+      RefreshChart;
+    end;
+end;
+
+procedure TdzXYChartLegend.SetLegendFont(const _LegendFont: TFont);
+begin
+  fLegendFont.Assign(_LegendFont);
+end;
+
+procedure TdzXYChartLegend.SetPosition(const _Position: TLegendPosition);
+begin
+  if fPosition <> _Position then
+    begin
+      fPosition := _Position;
+      RefreshChart;
+    end;
+end;
+
+{ TdzPointDesc }
+
+constructor TdzPointDesc.Create(const _x, _y: double; _XPos, _YPos: integer);
+begin
+  inherited Create;
+  fX := _x;
+  fY := _y;
+  fXPos := _XPos;
+  fYPos := _YPos;
+end;
+
+{ TdzCustomAxisScale }
+
+constructor TdzCustomAxisScale.Create(_Owner: TComponent);
+begin
+  inherited;
+  fAutomatic := true;
+  fMin := -1;
+  fMax := 1;
+  fDivisions := 1;
+end;
+
+procedure TdzCustomAxisScale.RefreshChart;
+begin
+  if Assigned(Owner) and (Owner is TdzCustomChartAxis) then
+    (Owner as TdzCustomChartAxis).RefreshChart;
+end;
+
+procedure TdzCustomAxisScale.SetAutomatic(const _Automatic: boolean);
+begin
+  if fAutomatic <> _Automatic then
+    begin
+      fAutomatic := _Automatic;
+      RefreshChart;
+    end;
+end;
+
+procedure TdzCustomAxisScale.SetDivisions(const _Divisions: double);
+begin
+  if not fAutomatic and (fDivisions <> _Divisions) and (_Divisions >= 1) then
+    begin
+      fDivisions := _Divisions;
+      RefreshChart;
+    end;
+end;
+
+procedure TdzCustomAxisScale.SetMax(const _Max: double);
+begin
+  if not fAutomatic and (fMax <> _Max) then
+    begin
+      fMax := _Max;
+      RefreshChart;
+    end;
+end;
+
+procedure TdzCustomAxisScale.SetMin(const _Min: double);
+begin
+  if not fAutomatic and (fMin <> _Min) then
+    begin
+      fMin := _Min;
+      RefreshChart;
+    end;
+end;
+
+procedure TdzCustomAxisScale.SetScaleType(const _ScaleType: TScaleType);
+begin
+  if fScaleType <> _ScaleType then
+    begin
+      fScaleType := _ScaleType;
+      RefreshChart;
+    end;
+end;
+
+end.
+



From twm at mail.berlios.de  Sun Jan 31 17:29:15 2010
From: twm at mail.berlios.de (twm at mail.berlios.de)
Date: Sun, 31 Jan 2010 17:29:15 +0100
Subject: [Dzchart-svncheckins] r374 - utilities/dzLib/trunk/dzAdoDb/src
Message-ID: <201001311629.o0VGTFlF001387@sheep.berlios.de>

Author: twm
Date: 2010-01-31 17:29:13 +0100 (Sun, 31 Jan 2010)
New Revision: 374

Modified:
   utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas
Log:
initialize username, databasename and servername to empty strings, even though that should not be necessary (Delphi sometimes does not init them)

Modified: utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas
===================================================================
--- utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas	2010-01-31 14:12:03 UTC (rev 373)
+++ utilities/dzLib/trunk/dzAdoDb/src/c_dzAdoConnection.pas	2010-01-31 16:29:13 UTC (rev 374)
@@ -102,6 +102,9 @@
   s: string;
   i: Integer;
 begin
+  Result.Username := '';
+  Result.Database := '';
+  Result.ServerName := '';
   Result.ServerType := DetermineServerType(_ConnectionString);
   sl := TStringList.Create;
   try



